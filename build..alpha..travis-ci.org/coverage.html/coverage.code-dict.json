{"/home/travis/build/npmtest/node-npmtest-terminal-kit/test.js":"/* istanbul instrument in package npmtest_terminal_kit */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/lib.npmtest_terminal_kit.js":"/* istanbul instrument in package npmtest_terminal_kit */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_terminal_kit = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_terminal_kit = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-terminal-kit && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_terminal_kit */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_terminal_kit\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_terminal_kit.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_terminal_kit.rollup.js'] =\n            local.assetsDict['/assets.npmtest_terminal_kit.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_terminal_kit.__dirname + '/lib.npmtest_terminal_kit.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/termkit.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\nvar termkit = {} ;\nmodule.exports = termkit ;\n\n\n\n// Load submodules in the termkit tree\ntermkit.tty = require( './tty.js' ) ;\n\n// For some reason, starting from node v4, once process.stdin getter is triggered, the 'tty' command would not work properly.\n// This 'hack' cache the result of the command 'tty' if we are in the linux console, so 'gpm' can work.\nif ( process.env.TERM === 'linux' ) { termkit.tty.getPath() ; }\n\nObject.assign( termkit , require( './misc.js' ) ) ;\nObject.assign( termkit , require( './detectTerminal.js' ) ) ;\n\ntermkit.image = require( './image.js' ) ;\ntermkit.Rect = require( './Rect.js' ) ;\ntermkit.ScreenBuffer = require( './ScreenBuffer.js' ) ;\ntermkit.ScreenBufferHD = require( './ScreenBufferHD.js' ) ;\ntermkit.TextBuffer = require( './TextBuffer.js' ) ;\ntermkit.autoComplete = require( './autoComplete.js' ) ;\ntermkit.spChars = require( './spChars.js' ) ;\n\ntermkit.Terminal = require( './Terminal.js' ) ;\ntermkit.createTerminal = termkit.Terminal.create ;\n\n// Lazy loading?\ntermkit.Element = require( './document/Element.js' ) ;\ntermkit.Document = require( './document/Document.js' ) ;\ntermkit.Container = require( './document/Container.js' ) ;\ntermkit.Text = require( './document/Text.js' ) ;\ntermkit.Button = require( './document/Button.js' ) ;\ntermkit.TextInput = require( './document/TextInput.js' ) ;\ntermkit.Form = require( './document/Form.js' ) ;\ntermkit.RowMenu = require( './document/RowMenu.js' ) ;\ntermkit.ColumnMenu = require( './document/ColumnMenu.js' ) ;\ntermkit.DropDownMenu = require( './document/DropDownMenu.js' ) ;\ntermkit.Layout = require( './document/Layout.js' ) ;\n\n\n\n// The default terminal will be lazily created\nObject.defineProperty( termkit , 'terminal' , {\n\tconfigurable: true ,\n\tenumerable: true ,\n\tget: function () {\n\t\t\n\t\tvar guessed = termkit.guessTerminal() ;\n\t\tvar guessedTerminal = termkit.createTerminal( {\n\t\t\tstdin: process.stdin ,\n\t\t\tstdout: process.stdout ,\n\t\t\tstderr: process.stderr ,\n\t\t\tgeneric: guessed.generic || 'unknown' ,\n\t\t\tappId: guessed.safe ? guessed.appId : undefined ,\n\t\t//\tappName: guessed.safe ? guessed.appName : undefined ,\n\t\t\tprocessSigwinch: true\n\t\t\t// couldTTY: true\n\t\t} ) ;\n\t\t\n\t\tObject.defineProperty( termkit , 'terminal' , { value: guessedTerminal , enumerable: true } ) ;\n\t\t\n\t\treturn guessedTerminal ;\n\t}\n} ) ;\n\n\n\n// The default terminal will be lazily created\nObject.defineProperty( termkit , 'realTerminal' , {\n\tconfigurable: true ,\n\tenumerable: true ,\n\tget: function () {\n\t\t\n\t\tvar guessed = termkit.guessTerminal() ;\n\t\tvar input = termkit.tty.getInput() ;\n\t\tvar output = termkit.tty.getOutput() ;\n\t\t\n\t\tvar guessedTerminal = termkit.createTerminal( {\n\t\t\tstdin: input ,\n\t\t\tstdout: output ,\n\t\t\tstderr: process.stderr ,\n\t\t\tgeneric: guessed.generic || 'unknown' ,\n\t\t\tappId: guessed.safe ? guessed.appId : undefined ,\n\t\t//\tappName: guessed.safe ? guessed.appName : undefined ,\n\t\t\tprocessSigwinch: true\n\t\t\t// couldTTY: true\n\t\t} ) ;\n\t\t\n\t\tObject.defineProperty( termkit , 'realTerminal' , { value: guessedTerminal , enumerable: true } ) ;\n\t\t\n\t\treturn guessedTerminal ;\n\t}\n} ) ;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/tty.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n//var exec = require( 'child_process' ).exec ;\n//var spawn = require( 'child_process' ).spawn ;\nvar execSync = require( 'child_process' ).execSync ;\nvar fs = require( 'fs' ) ;\nvar tty = require( 'tty' ) ;\n\n\n\n\nvar tty_ = {} ;\nmodule.exports = tty_ ;\n\n\n\nvar cachedGetPath ;\n\n/*\n\tgetPath( [stdin] )\n\t\t* stdin: a stream that is the current STDIN of the terminal\n\t\n\tReturns an object, where:\n\t\t* ttyPath: the path of the tty\n\t\t* ttyIndex: the index number of the tty, only if it is a /dev/tty*, /dev/pts/* return null\n*/\ntty_.getPath = function getPath( stdin )\n{\n\tvar cacheIt , result , ttyPath , ttyIndex , matches ;\n\t\n\t// Manage arguments\n\tif ( ! stdin )\n\t{\n\t\t// getPath() does not work as soon as process.stdin getter is triggered (since node v4)\n\t\t// So 0 should be used instead of process.stdin\n\t\tstdin = 0 ;\n\t\t//stdin = process.stdin ;\n\t}\n\t\n\tif ( stdin === 0 || stdin === process.stdin )\n\t{\n\t\tif ( cachedGetPath ) { return cachedGetPath ; }\n\t\tcacheIt = true ;\n\t}\n\t\t\n\t\n\ttry {\n\t\t// if no stdio are passed, the command will report 'not a TTY'\n\t\tttyPath = execSync( 'tty' , { stdio: [ stdin , null , null ] } ).toString() ;\n\t}\n\tcatch ( error ) {\n\t\tttyPath = error.stdout.toString() ;\n\t}\n\t\n\tttyPath = ttyPath.trim() ;\n\t\n\t//console.log( 'TTY path:' , ttyPath ) ;\n\t\n\tmatches = ttyPath.match( /\\/dev\\/tty([0-9]*)/ ) ;\n\t\n\tttyIndex = matches ? matches[ 1 ] || null : null ;\n\t\n\tresult = {\n\t\tpath: ttyPath ,\n\t\tindex: ttyIndex\n\t} ;\n\t\n\tif ( cacheIt ) { cachedGetPath = result ; }\n\t\n\treturn result ;\n} ;\n\n\n\n/*\n\tgetInput()\n\t\n\tOpen a TTY input file descriptor and transform it into a regular node.js TTY input stream.\n\tIt returns the TTY input `Stream` use instead of process.stdin\n\t\n\tThis code was borrowed from the 'ttys' module by Nathan Rajlich.\n*/\ntty_.getInput = function getInput()\n{\n\tvar inputFd , input ;\n\t\n\tinputFd = fs.openSync( '/dev/tty' , 'r' ) ;\n\tif ( ! tty.isatty( inputFd ) ) { throw new Error( 'Input file descriptor is not a TTY.' ) ; }\n\tinput = new tty.ReadStream( inputFd ) ;\n\tinput._type = 'tty' ;\n\t\n\treturn input ;\n} ;\n\n\n\n/*\n\tgetOutput()\n\t\n\tOpen a TTY output file descriptor and transform it into a regular node.js TTY output stream.\n\tIt returns the TTY output `Stream` use instead of process.stdin\n\t\n\tThis code was borrowed from the 'ttys' module by Nathan Rajlich.\n*/\ntty_.getOutput = function getOutput()\n{\n\tvar outputFd , output ;\n\t\n\toutputFd = fs.openSync( '/dev/tty' , 'w' ) ;\n\tif ( ! tty.isatty( outputFd ) ) { throw new Error( 'Output file descriptor is not a TTY.' ) ; }\n\toutput = new tty.WriteStream( outputFd ) ;\n\toutput._type = 'tty' ;\n\t\n\t// Hack to have the stdout stream not keep the event loop alive.\n\t// See: https://github.com/joyent/node/issues/1726\n\t// XXX: remove/fix this once src/node.js does something different as well.\n\t// @cronvel: that doesn't work much either...\n\tif ( output._handle && output._handle.unref )\n\t{\n\t\toutput._handle.unref() ;\n\t}\n\t\n\t// Update the \"columns\" and \"rows\" properties on the stdout stream\n\t// whenever the console window gets resized.\n\tif ( output._refreshSize )\n\t{\n\t\tprocess.on( 'SIGWINCH' , function () {\n\t\t\toutput._refreshSize() ;\n\t\t} ) ;\n\t}\n\t\n\treturn output ;\n} ;\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/misc.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\nvar misc = {} ;\nmodule.exports = misc ;\n\n\n\n// Color name to index\nmisc.color2index = function color2index( color )\n{\n\tswitch ( color.toLowerCase() )\n\t{\n\t\tcase 'black' : return 0 ;\n\t\tcase 'red' : return 1 ;\n\t\tcase 'green' : return 2 ;\n\t\tcase 'yellow' : return 3 ;\n\t\tcase 'blue' : return 4 ;\n\t\tcase 'magenta' : return 5 ;\n\t\tcase 'cyan' : return 6 ;\n\t\tcase 'white' : return 7 ;\n\t\tcase 'brightblack' : return 8 ;\n\t\tcase 'brightred' : return 9 ;\n\t\tcase 'brightgreen' : return 10 ;\n\t\tcase 'brightyellow' : return 11 ;\n\t\tcase 'brightblue' : return 12 ;\n\t\tcase 'brightmagenta' : return 13 ;\n\t\tcase 'brightcyan' : return 14 ;\n\t\tcase 'brightwhite' : return 15 ;\n\t\tdefault : return undefined ;\n\t}\n} ;\n\n\n\nmisc.hexToColor = function hexToColor( hex )\n{\n\t// Strip the # if necessary\n\tif ( hex[ 0 ] === '#' ) { hex = hex.slice( 1 ) ; }\n\t\n\treturn {\n\t\tr: parseInt( hex.slice( 0 , 2 ) , 16 ) ,\n\t\tg: parseInt( hex.slice( 2 , 4 ) , 16 ) ,\n\t\tb: parseInt( hex.slice( 4 , 6 ) , 16 ) ,\n\t\ta: parseInt( hex.slice( 6 , 8 ) , 16 )\n\t} ;\n} ;\n\n\n\n// Strip all control chars, if newline is true, only newline control chars are preserved\nmisc.stripControlChars = function stripControlChars( str , newline ) {\n\tif ( newline ) { return str.replace( /[\\x00-\\x09\\x0b-\\x1f\\x7f]/g , '' ) ; }\n\telse { return str.replace( /[\\x00-\\x1f\\x7f]/g , '' ) ; }\n} ;\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/detectTerminal.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\nvar exec = require( 'child_process' ).exec ;\nvar async = require( 'async-kit' ) ;\n\nvar termkit = require( './termkit.js' ) ;\n\n\n\n// Try to guess the terminal without any async system call, using TERM and COLORTERM\nexports.guessTerminal = function guessTerminal()\n{\n\tvar envVar ;\n\t\n\tvar tTrueColor = process.env.COLORTERM && process.env.COLORTERM.match( /^(truecolor|24bits?)$/ ) ;\n\t\n\tvar appId = process.env.COLORTERM && ! tTrueColor ? process.env.COLORTERM : process.env.TERM ;\n\t\n\tvar ssh = process.env.SSH_CONNECTION ? true : false ;\n\t\n\t// safe is true if we are sure about our guess\n\tvar safe = process.env.TERM !== 'xterm' && process.env.TERM !== 'xterm-256color' ;\n\t\n\tvar t256color = ( process.env.TERM && process.env.TERM.match( /256/ ) ) ||\n\t\t( process.env.COLORTERM && process.env.COLORTERM.match( /256/ ) ) ;\n\t\n\tvar generic = appId ;\n\t\n\tswitch ( appId )\n\t{\n\t\tcase 'xterm' :\n\t\tcase 'xterm-256color' :\n\t\t\tif ( safe ) { break ; }\n\t\t\t\n\t\t\tif ( tTrueColor )\n\t\t\t{\n\t\t\t\tappId = generic = 'xterm-truecolor' ;\n\t\t\t}\n\t\t\t\n\t\t\t// Many terminal advertise them as xterm, we will try to guess some of them here,\n\t\t\t// using environment variable\n\t\t\tfor ( envVar in process.env )\n\t\t\t{\n\t\t\t\tif ( envVar.match( /KONSOLE/ ) )\n\t\t\t\t{\n\t\t\t\t\tappId = t256color ? 'konsole-256color' : 'konsole' ;\n\t\t\t\t\tsafe = true ;\n\t\t\t\t\tbreak ;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif ( parseInt( process.env.VTE_VERSION ) >= 3803 )\n\t\t\t{\n\t\t\t\t// Stupid gnome-terminal do not define the COLORTERM environment variable anymore...\n\t\t\t\t// There are a bunch of more or less useless GNOME env variable, but none that advertise about gnome-terminal itself.\n\t\t\t\t// So... At time of writing (2015-04-28), it looks like only gnome-terminal set the VTE_VERSION environment variable.\n\t\t\t\t// We will use that to detect it, but flag it unsafe.\n\t\t\t\tappId = t256color ? 'gnome-256color' : 'gnome' ;\n\t\t\t\tsafe = false ;\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t\t\n\t\t\tbreak ;\n\t\t\n\t\tcase 'linux' :\n\t\tcase 'aterm':\n\t\tcase 'kuake':\n\t\tcase 'tilda':\n\t\tcase 'terminology':\n\t\tcase 'wterm':\n\t\tcase 'mrxvt':\n\t\t\tbreak ;\n\t\tcase 'gnome':\n\t\tcase 'gnome-256color':\n\t\tcase 'gnome-terminal':\n\t\tcase 'gnome-terminal-256color':\n\t\tcase 'terminator':\t// it uses gnome terminal lib\n\t\tcase 'guake':\t// same here\n\t\t\tappId = t256color ? 'gnome-256color' : 'gnome' ;\n\t\t\tbreak ;\n\t\tcase 'konsole' :\n\t\t\tappId = t256color ? 'konsole-256color' : 'konsole' ;\n\t\t\tbreak ;\n\t\tcase 'rxvt':\n\t\tcase 'rxvt-xpm':\n\t\tcase 'rxvt-unicode-256color':\n\t\tcase 'urxvt256c':\n\t\tcase 'urxvt256c-ml':\n\t\tcase 'rxvt-unicode':\n\t\tcase 'urxvt':\n\t\tcase 'urxvt-ml':\n\t\t\tif ( process.env.TERM === 'rxvt' ) { appId = 'rxvt-256color' ; }\n\t\t\telse { appId = t256color ? 'rxvt-256color' : 'rxvt' ; }\n\t\t\tbreak ;\n\t\tcase 'xfce' :\n\t\tcase 'xfce-terminal' :\n\t\tcase 'xfce4-terminal' :\n\t\t\tappId = 'xfce' ;\n\t\t\tbreak ;\n\t\tcase 'eterm':\n\t\tcase 'Eterm':\n\t\t\tappId = t256color ? 'eterm-256color' : 'eterm' ;\n\t\t\tbreak ;\n\t\tcase 'atomic-terminal' :\n\t\t\tappId = 'atomic-terminal' ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\tgeneric = appId = generic.toLowerCase() ;\n\t\t\tbreak ;\n\t}\n\t\n\treturn { appId: appId , safe: safe , generic: safe ? appId : generic , ssh: ssh } ;\n} ;\n\n\n\n// Work localy, do not work over SSH\nexports.getParentTerminalInfo = function getParentTerminalInfo( callback )\n{\n\tvar appName , appId , pid = process.pid ;\n\t\n\tif ( process.env.SSH_CONNECTION )\n\t{\n\t\tcallback( new Error( 'SSH connection detected, .getParentTerminalInfo() is useless in this context.' ) ) ;\n\t\treturn ;\n\t}\n\t\n\tvar t256color = process.env.TERM && process.env.TERM.match( /256/ ) ? true : false ;\n\t\n\tasync.do( [\n\t\tfunction( asyncCallback ) {\n\t\t\texec( 'ps -h -o ppid -p ' + pid , function( error , stdout ) {\n\t\t\t\tif ( error ) { asyncCallback( error ) ; return ; }\n\t\t\t\tpid = parseInt( stdout ) ;\n\t\t\t\tasyncCallback() ;\n\t\t\t} ) ;\n\t\t} ,\n\t\tfunction( asyncCallback ) {\n\t\t\texec( 'ps -h -o comm -p ' + pid , function( error , stdout ) {\n\t\t\t\tif ( error ) { asyncCallback( error ) ; return ; }\n\t\t\t\tappName = stdout.trim() ;\n\t\t\t\tasyncCallback() ;\n\t\t\t} ) ;\n\t\t}\n\t] )\n\t.while( function( error , results , asyncCallback ) {\n\t\t\n\t\tif ( error ) { asyncCallback( error ) ; return ; }\n\t\t\n\t\t//console.log( 'found:' , appName , pid ) ;\n\t\t\n\t\t// Do NOT skip the first, there are case where the terminal may run directly node.js without any shell in between\n\t\t//if ( ++ loop <= 1 ) { asyncCallback( undefined , true ) ; return ; }\n\t\t\n\t\tswitch ( appName )\n\t\t{\n\t\t\tcase 'linux' :\n\t\t\tcase 'xterm' :\n\t\t\tcase 'konsole' :\n\t\t\tcase 'gnome-terminal':\n\t\t\tcase 'aterm':\n\t\t\tcase 'guake':\n\t\t\tcase 'kuake':\n\t\t\tcase 'tilda':\n\t\t\tcase 'terminology':\n\t\t\tcase 'wterm':\n\t\t\tcase 'mrxvt':\n\t\t\t\tappId = t256color ? appName + '-256color' : appName ;\n\t\t\t\tbreak ;\n\t\t\tcase 'atomic-terminal':\n\t\t\t\tappId = appName ;\n\t\t\t\tbreak ;\n\t\t\tcase 'login':\n\t\t\t\tappName = 'linux' ;\n\t\t\t\tappId = appName ;\n\t\t\t\tbreak ;\n\t\t\t// Use terminator as gnome-terminal, since it uses the gnome-terminal renderer\n\t\t\tcase 'terminator':\n\t\t\t\tappId = t256color ? 'gnome-256color' : 'gnome' ;\n\t\t\t\tbreak ;\n\t\t\t// Use rxvt as xterm-256color\n\t\t\tcase 'rxvt':\n\t\t\tcase 'urxvt256c':\n\t\t\tcase 'urxvt256c-ml':\n\t\t\t\tappId = 'rxvt-256color' ;\n\t\t\t\tbreak ;\n\t\t\t// Use rxvt as xterm\n\t\t\tcase 'urxvt':\n\t\t\tcase 'urxvt-ml':\n\t\t\t\tappId = 'rxvt' ;\n\t\t\t\tbreak ;\n\t\t\t// xfce4-terminal\n\t\t\tcase 'xfce4-terminal' :\n\t\t\t\tappId = 'xfce' ;\n\t\t\t\tbreak ;\n\t\t\tcase 'gnome-terminal-':\n\t\t\t\tappName = 'gnome-terminal' ;\n\t\t\t\tappId = t256color ? 'gnome-256color' : 'gnome' ;\n\t\t\t\tbreak ;\n\t\t\tcase 'Eterm':\n\t\t\tcase 'eterm':\n\t\t\t\tappName = 'Eterm' ;\n\t\t\t\tappId = t256color ? 'eterm-256color' : 'eterm' ;\n\t\t\t\tbreak ;\n\t\t\tdefault :\n\t\t\t\t\n\t\t\t\tif ( appName.match( /gnome-terminal/ ) )\n\t\t\t\t{\n\t\t\t\t\tappName = 'gnome-terminal' ;\n\t\t\t\t\tappId = t256color ? 'gnome-256color' : 'gnome' ;\n\t\t\t\t\tbreak ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( pid === 1 ) { asyncCallback( new Error( 'Terminal not found' ) ) ; }\n\t\t\t\telse { asyncCallback( undefined , true ) ; }\n\t\t\t\treturn ;\n\t\t}\n\t\t\n\t\tasyncCallback( undefined , false ) ;\n\t} )\n\t.exec( function( error ) {\n\t\tif ( error ) { callback( error ) ; return ; }\n\t\tcallback( undefined , { appId: appId , appName: appName , pid: pid , safe: true } ) ;\n\t} ) ;\n} ;\n\n\n\n// Work localy, do not work over SSH\nexports.getDetectedTerminal = function getDetectedTerminal( callback )\n{\n\tvar guessed = termkit.guessTerminal() ;\n\t\n\tif ( guessed.safe || guessed.ssh )\n\t{\n\t\t// If we have a good guess, use it now\n\t\tcallback( undefined , termkit.createTerminal( {\n\t\t\tstdin: process.stdin ,\n\t\t\tstdout: process.stdout ,\n\t\t\tstderr: process.stderr ,\n\t\t\tgeneric: ( process.env.TERM && process.env.TERM.toLowerCase() ) || 'unknown' ,\n\t\t\tappId: guessed.safe ? guessed.appId : undefined ,\n\t\t\t//  appName: guessed.safe ? guessed.appName : undefined ,\n\t\t\tprocessSigwinch: true\n\t\t\t// couldTTY: true\n\t\t} ) ) ;\n\t\t\n\t\treturn ;\n\t}\n\t\n\ttermkit.getParentTerminalInfo( function( error , info ) {\n\t\t\n\t\tif ( error )\n\t\t{\n\t\t\t// Do not issue error\n\t\t\tcallback( undefined , termkit.createTerminal( {\n\t\t\t\tstdin: process.stdin ,\n\t\t\t\tstdout: process.stdout ,\n\t\t\t\tstderr: process.stderr ,\n\t\t\t\tgeneric: ( process.env.TERM && process.env.TERM.toLowerCase() ) || 'unknown' ,\n\t\t\t\tappId: guessed.safe ? guessed.appId : undefined ,\n\t\t\t\t//  appName: guessed.safe ? guessed.appName : undefined ,\n\t\t\t\tprocessSigwinch: true\n\t\t\t\t// couldTTY: true\n\t\t\t} ) ) ;\n\t\t\t\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tcallback( undefined , termkit.createTerminal( {\n\t\t\tstdin: process.stdin ,\n\t\t\tstdout: process.stdout ,\n\t\t\tstderr: process.stderr ,\n\t\t\tgeneric: ( process.env.TERM && process.env.TERM.toLowerCase() ) || 'unknown' ,\n\t\t\tappId: info.appId ,\n\t\t\tappName: info.appName ,\n\t\t\tpid: info.pid ,\n\t\t\tprocessSigwinch: true\n\t\t} ) ) ;\n\t} ) ;\n} ;\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/image.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\nvar ndarray = require( 'ndarray' ) ;\n\n\n\nvar image = {} ;\nmodule.exports = image ;\n\n\n\nimage.load = function load( fn , filepath , options , callback )\n{\n\tvar getPixels = require( 'get-pixels' ) ;\n\t\n\tif ( typeof options === 'function' ) { callback = options ; options = {} ; }\n\telse if ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tgetPixels( filepath , function( error , pixels ) {\n\t\t\n\t\tif ( error )\n\t\t{\n\t\t\tcallback( new Error( 'Bad image path: ' + error ) ) ;\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tif ( pixels.shape.length === 4 )\n\t\t{\n\t\t\t// Probably a GIF or a format having animation,\n\t\t\t// we just extract the first image: a 3D array\n\t\t\tpixels = pixels.pick( 0 , null , null , null ) ;\n\t\t}\n\t\t\n\t\tif ( options.shrink ) { pixels = image.shrinkNdarrayImage( pixels , options.shrink ) ; }\n\t\t\n\t\tcallback( undefined , fn( pixels , options ) ) ;\n\t} ) ;\n} ;\n\n\n\n// Naive interpolation\nimage.shrinkNdarrayImage = function shrinkNdarrayImage( pixels , options )\n{\n\tvar rate = Math.min( options.width / pixels.shape[ 0 ] , options.height / pixels.shape[ 1 ] ) ;\n\tif ( rate >= 1 ) { return pixels ; }\n\t\n\tvar dstWidth = Math.ceil( pixels.shape[ 0 ] * rate ) ;\n\tvar dstHeight = Math.ceil( pixels.shape[ 1 ] * rate ) ;\n\t\n\tvar xDst , yDst , xSrc , xSrcMin , xSrcMax , ySrc , ySrcMin , ySrcMax ,\n\t\tr , g , b , a , count ,\n\t\thasAlpha = pixels.shape[ 2 ] === 4 ;\n\t\n\tvar shrinkedPixels = ndarray(\n\t\tnew Uint8Array( dstWidth * dstHeight * pixels.shape[ 2 ] ) ,\n\t\t[ dstWidth , dstHeight , pixels.shape[ 2 ] ]\n\t) ;\n\t\n\tfor ( xDst = 0 ; xDst < dstWidth ; xDst ++ )\n\t{\n\t\tfor ( yDst = 0 ; yDst < dstHeight ; yDst ++ )\n\t\t{\n\t\t\txSrcMin = Math.ceil( xDst / rate ) ;\n\t\t\txSrcMax = Math.min( Math.ceil( ( xDst + 1 ) / rate - 1 ) , pixels.shape[ 0 ] - 1 ) ;\n\t\t\tySrcMin = Math.ceil( yDst / rate ) ;\n\t\t\tySrcMax = Math.min( Math.ceil( ( yDst + 1 ) / rate - 1 ) , pixels.shape[ 1 ] - 1 ) ;\n\t\t\tcount = r = g = b = a = 0 ;\n\t\t\t\n\t\t\tfor ( xSrc = xSrcMin ; xSrc <= xSrcMax ; xSrc ++ )\n\t\t\t{\n\t\t\t\tfor ( ySrc = ySrcMin ; ySrc <= ySrcMax ; ySrc ++ )\n\t\t\t\t{\n\t\t\t\t\tr += pixels.get( xSrc , ySrc , 0 ) ;\n\t\t\t\t\tg += pixels.get( xSrc , ySrc , 1 ) ;\n\t\t\t\t\tb += pixels.get( xSrc , ySrc , 2 ) ;\n\t\t\t\t\tif ( hasAlpha ) { a += pixels.get( xSrc , ySrc , 3 ) ; }\n\t\t\t\t\tcount ++ ;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tshrinkedPixels.set( xDst , yDst , 0 , Math.round( r / count ) ) ;\n\t\t\tshrinkedPixels.set( xDst , yDst , 1 , Math.round( g / count ) ) ;\n\t\t\tshrinkedPixels.set( xDst , yDst , 2 , Math.round( b / count ) ) ;\n\t\t\tif ( hasAlpha ) { shrinkedPixels.set( xDst , yDst , 3 , Math.round( a / count ) ) ; }\n\t\t}\n\t}\n\t\n\treturn shrinkedPixels ;\n} ;\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/Rect.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\n//var tree = require( 'tree-kit' ) ;\n//var async = require( 'async-kit' ) ;\nvar termkit = require( './termkit.js' ) ;\n\n\n\n\n\n\t\t\t/* Rect: rectangular region, clipping, etc */\n\n\n\nfunction Rect() { throw new Error( '[terminal] Cannot create a termkit.Rect directly, use termkit.Rect.create() instead.' ) ; }\nmodule.exports = Rect ;\n\n\n\n/*\n\tnew Rect( xmin , ymin , xmax , ymax )\n\tnew Rect( object ) having properties: xmin , ymin , xmax , ymax\n\tnew Rect( Terminal )\n\tnew Rect( ScreenBuffer )\n*/\nRect.create = function createRect( src )\n{\n\tvar rect = Object.create( Rect.prototype ) ;\n\t\n\tif ( src && ( typeof src === 'object' || typeof src === 'function' ) )\n\t{\n\t\tif ( src instanceof termkit.Terminal )\n\t\t{\n\t\t\trect.set( {\n\t\t\t\txmin: 1 ,\n\t\t\t\tymin: 1 ,\n\t\t\t\txmax: src.width ,\n\t\t\t\tymax: src.height\n\t\t\t} ) ;\n\t\t}\n\t\telse if ( src instanceof termkit.ScreenBuffer )\n\t\t{\n\t\t\trect.set( {\n\t\t\t\txmin: 0 ,\n\t\t\t\tymin: 0 ,\n\t\t\t\txmax: src.width - 1 ,\n\t\t\t\tymax: src.height - 1\n\t\t\t} ) ;\n\t\t}\n\t\telse if ( src instanceof termkit.TextBuffer )\n\t\t{\n\t\t\trect.set( {\n\t\t\t\txmin: 0 ,\n\t\t\t\tymin: 0 ,\n\t\t\t\txmax: src.width - 1 ,\n\t\t\t\tymax: src.height - 1\n\t\t\t} ) ;\n\t\t}\n\t\telse if ( src instanceof Rect )\n\t\t{\n\t\t\trect.set( src ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ( src.xmin || src.ymin || src.xmax || src.ymax )\n\t\t\t{\n\t\t\t\trect.set( {\n\t\t\t\t\txmin: src.xmin !== undefined ? src.xmin : 0 ,\n\t\t\t\t\tymin: src.ymin !== undefined ? src.ymin : 0 ,\n\t\t\t\t\txmax: src.xmax !== undefined ? src.xmax : 1 ,\n\t\t\t\t\tymax: src.ymax !== undefined ? src.ymax : 1\n\t\t\t\t} ) ;\n\t\t\t}\n\t\t\telse if ( src.x || src.y || src.width || src.height )\n\t\t\t{\n\t\t\t\trect.set( {\n\t\t\t\t\txmin: src.x !== undefined ? src.x : 0 ,\n\t\t\t\t\tymin: src.y !== undefined ? src.y : 0 ,\n\t\t\t\t\txmax: src.width !== undefined ? src.x + src.width - 1 : 1 ,\n\t\t\t\t\tymax: src.height !== undefined ? src.y + src.height - 1 : 1\n\t\t\t\t} ) ;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\trect.set( {\n\t\t\txmin: arguments[ 0 ] !== undefined ? arguments[ 0 ] : 0 ,\n\t\t\tymin: arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0 ,\n\t\t\txmax: arguments[ 2 ] !== undefined ? arguments[ 2 ] : 1 ,\n\t\t\tymax: arguments[ 3 ] !== undefined ? arguments[ 3 ] : 1\n\t\t} ) ;\n\t}\n\t\n\treturn rect ;\n} ;\n\n\n\nRect.prototype.set = function rectSet( object )\n{\n\tvar key ;\n\t\n\tfor ( key in object )\n\t{\n\t\tswitch ( key )\n\t\t{\n\t\t\tcase 'xmin' :\n\t\t\tcase 'xmax' :\n\t\t\tcase 'ymin' :\n\t\t\tcase 'ymax' :\n\t\t\t\tObject.defineProperty( this , key , { value: Math.floor( object[ key ] ) , enumerable: true , configurable: true } ) ;\n\t\t\t\tbreak ;\n\t\t}\n\t}\n\t\n\tObject.defineProperties( this , {\n\t\twidth: { value: this.xmax - this.xmin + 1 , enumerable: true , configurable: true } ,\n\t\theight: { value: this.ymax - this.ymin + 1 , enumerable: true , configurable: true } ,\n\t\tisNull: { value: this.xmin > this.xmax || this.ymin > this.ymax , enumerable: true , configurable: true }\n\t} ) ;\n} ;\n\n\n\n// Clip the src according to the dst, offset* are offsets of the srcRect relative to the dst coordinate system\nRect.prototype.clip = function clip( dstRect , offsetX , offsetY , dstClipping )\n{\n\tvar srcRect = this ;\n\t\n\toffsetX = offsetX || 0 ;\n\toffsetY = offsetY || 0 ;\n\t\n\tsrcRect.set( {\n\t\txmin: Math.max( srcRect.xmin , dstRect.xmin - offsetX ) ,\n\t\tymin: Math.max( srcRect.ymin , dstRect.ymin - offsetY ) ,\n\t\txmax: Math.min( srcRect.xmax , dstRect.xmax - offsetX ) ,\n\t\tymax: Math.min( srcRect.ymax , dstRect.ymax - offsetY )\n\t} ) ;\n\t\n\tif ( dstClipping )\n\t{\n\t\tdstRect.set( {\n\t\t\txmin: Math.max( dstRect.xmin , srcRect.xmin + offsetX ) ,\n\t\t\tymin: Math.max( dstRect.ymin , srcRect.ymin + offsetY ) ,\n\t\t\txmax: Math.min( dstRect.xmax , srcRect.xmax + offsetX ) ,\n\t\t\tymax: Math.min( dstRect.ymax , srcRect.ymax + offsetY )\n\t\t} ) ;\n\t}\n\t\n\treturn this ;\n} ;\n\n\n\n/*\n\tGiven a srcRect, a dstRect, offsetX and offsetY, return an array of up to 4 objects consisting of the same properties\n\tfound in entry, wrapping the src into the dst, i.e. the src is always fully visible in the dst, it is just as if\n\tthe dst where circular\n\t\n\tMandatory params:\n\t\t* dstRect\n\t\t* srcRect\n\t\t* offsetX\n\t\t* offsetY\n\tOptionnal params:\n\t\t* wrapOnly: 'x' , 'y' (only wrap along that axis)\n*/\nRect.wrappingRect = function wrappingRect( p )\n{\n\tvar regions = [] , nw , ne , sw , se ;\n\t\n\t\n\t// Originate, North-West region\n\tnw = {\n\t\tsrcRect: Rect.create( p.srcRect ) ,\n\t\tdstRect: Rect.create( p.dstRect ) ,\n\t\toffsetX: p.offsetX ,\n\t\toffsetY: p.offsetY\n\t} ;\n\t\n\t// Modulate offsets so they are in-range\n\tif ( p.wrapOnly !== 'y' )\n\t{\n\t\tnw.offsetX = nw.offsetX % p.dstRect.width ;\n\t\tif ( nw.offsetX < 0 ) { nw.offsetX += p.dstRect.width ; }\n\t}\n\t\n\tif ( p.wrapOnly !== 'x' )\n\t{\n\t\tnw.offsetY = nw.offsetY % p.dstRect.height ;\n\t\tif ( nw.offsetY < 0 ) { nw.offsetY += p.dstRect.height ; }\n\t}\n\t\n\t// Mutual clipping\n\tnw.srcRect.clip( nw.dstRect , nw.offsetX , nw.offsetY , true ) ;\n\tif ( ! nw.srcRect.isNull ) { regions.push( nw ) ; }\n\t\n\t// Wrap-x North-Est region\n\tif ( nw.srcRect.width < p.srcRect.width && p.wrapOnly !== 'y' )\n\t{\n\t\tne = {\n\t\t\tsrcRect: Rect.create( p.srcRect ) ,\n\t\t\tdstRect: Rect.create( p.dstRect ) ,\n\t\t\toffsetX: nw.offsetX - p.dstRect.width ,\n\t\t\toffsetY: nw.offsetY\n\t\t} ;\n\t\t\n\t\t// Mutual clipping\n\t\tne.srcRect.clip( ne.dstRect , ne.offsetX , ne.offsetY , true ) ;\n\t\tif ( ! ne.srcRect.isNull ) { regions.push( ne ) ; }\n\t}\n\t\n\t\n\t// Wrap-y South-West region\n\tif ( nw.srcRect.height < p.srcRect.height && p.wrapOnly !== 'x' )\n\t{\n\t\tsw = {\n\t\t\tsrcRect: Rect.create( p.srcRect ) ,\n\t\t\tdstRect: Rect.create( p.dstRect ) ,\n\t\t\toffsetX: nw.offsetX ,\n\t\t\toffsetY: nw.offsetY - p.dstRect.height\n\t\t} ;\n\t\t\n\t\t// Mutual clipping\n\t\tsw.srcRect.clip( sw.dstRect , sw.offsetX , sw.offsetY , true ) ;\n\t\tif ( ! sw.srcRect.isNull ) { regions.push( sw ) ; }\n\t}\n\t\n\t\n\t// Wrap-x + wrap-y South-Est region, do it only if it has wrapped already\n\tif ( ne && sw )\n\t{\n\t\tse = {\n\t\t\tsrcRect: Rect.create( p.srcRect ) ,\n\t\t\tdstRect: Rect.create( p.dstRect ) ,\n\t\t\toffsetX: nw.offsetX - p.dstRect.width ,\n\t\t\toffsetY: nw.offsetY - p.dstRect.height\n\t\t} ;\n\t\t\n\t\t// Mutual clipping\n\t\tse.srcRect.clip( se.dstRect , se.offsetX , se.offsetY , true ) ;\n\t\tif ( ! se.srcRect.isNull ) { regions.push( se ) ; }\n\t}\n\t\n\treturn regions ;\n} ;\n\n\n\n/*\n\tThis iterator generate synchronous line or cell for dst & src Rect.\n\tIt is totally buffer agnostic.\n\tBuffer specificities should be added in p.context by the callee.\n\t\n\tIterator.\n\tMandatory params:\n\t\t* dstRect\n\t\t* srcRect\n\t\t* type: 'line' or 'cell'\n\tOptionnal params:\n\t\t* context: an object that will be transmitted as is to the iterator\n\t\t* dstClipRect\n\t\t* srcClipRect\n\t\t* offsetX\n\t\t* offsetY\n\t\t* multiply\n*/\nRect.regionIterator = function regionIterator( p , iterator )\n{\n\tvar i , j , srcX , srcY , dstX , dstY , srcStart , dstStart ;\n\t\n\tif ( ! p.multiply ) { p.multiply = 1 ; }\n\tif ( ! p.offsetX ) { p.offsetX = 0 ; }\n\tif ( ! p.offsetY ) { p.offsetY = 0 ; }\n\t\n\tif ( p.dstClipRect ) { p.dstClipRect.clip( p.dstRect ) ; }\n\telse { p.dstClipRect = Rect.create( p.dstRect ) ; }\n\t\n\tif ( p.srcClipRect ) { p.srcClipRect.clip( p.srcRect ) ; }\n\telse { p.srcClipRect = Rect.create( p.srcRect ) ; }\n\t\n\t// Mutual clipping\n\tp.srcClipRect.clip( p.dstClipRect , p.offsetX , p.offsetY , true ) ;\n\t\n\t// If out of bounds, or if everything is clipped away, return now\n\tif ( p.dstRect.isNull || p.srcClipRect.isNull || p.dstClipRect.isNull ) { return ; }\n\t\n\tswitch ( p.type )\n\t{\n\t\tcase 'line' :\n\t\t\tfor ( j = 0 ; j < p.srcClipRect.height ; j ++ )\n\t\t\t{\n\t\t\t\tsrcY = p.srcClipRect.ymin + j ;\n\t\t\t\tdstY = p.dstClipRect.ymin + j ;\n\t\t\t\t\n\t\t\t\titerator( {\n\t\t\t\t\tcontext: p.context ,\n\t\t\t\t\tsrcXmin: p.srcClipRect.xmin ,\n\t\t\t\t\tsrcXmax: p.srcClipRect.xmax ,\n\t\t\t\t\tsrcY: srcY ,\n\t\t\t\t\tsrcStart: ( srcY * p.srcRect.width + p.srcClipRect.xmin ) * p.multiply ,\n\t\t\t\t\tsrcEnd: ( srcY * p.srcRect.width + p.srcClipRect.xmax + 1 ) * p.multiply ,\n\t\t\t\t\tdstXmin: p.dstClipRect.xmin ,\n\t\t\t\t\tdstXmax: p.dstClipRect.xmax ,\n\t\t\t\t\tdstY: dstY ,\n\t\t\t\t\tdstStart: ( dstY * p.dstRect.width + p.dstClipRect.xmin ) * p.multiply ,\n\t\t\t\t\tdstEnd: ( dstY * p.dstRect.width + p.dstClipRect.xmax + 1 ) * p.multiply\n\t\t\t\t} ) ;\n\t\t\t}\n\t\t\tbreak ;\n\t\t\t\n\t\tcase 'cell' :\n\t\t\tfor ( j = 0 ; j < p.srcClipRect.height ; j ++ )\n\t\t\t{\n\t\t\t\tfor ( i = 0 ; i < p.srcClipRect.width ; i ++ )\n\t\t\t\t{\n\t\t\t\t\tsrcX = p.srcClipRect.xmin + i ;\n\t\t\t\t\tsrcY = p.srcClipRect.ymin + j ;\n\t\t\t\t\t\n\t\t\t\t\tdstX = p.dstClipRect.xmin + i ;\n\t\t\t\t\tdstY = p.dstClipRect.ymin + j ;\n\t\t\t\t\t\n\t\t\t\t\tsrcStart = ( srcY * p.srcRect.width + srcX ) * p.multiply ;\n\t\t\t\t\tdstStart = ( dstY * p.dstRect.width + dstX ) * p.multiply ;\n\t\t\t\t\t\n\t\t\t\t\titerator( {\n\t\t\t\t\t\tcontext: p.context ,\n\t\t\t\t\t\tsrcX: srcX ,\n\t\t\t\t\t\tsrcY: srcY ,\n\t\t\t\t\t\tsrcStart: srcStart ,\n\t\t\t\t\t\tsrcEnd: srcStart + p.multiply ,\n\t\t\t\t\t\tdstX: dstX ,\n\t\t\t\t\t\tdstY: dstY ,\n\t\t\t\t\t\tdstStart: dstStart ,\n\t\t\t\t\t\tdstEnd: dstStart + p.multiply\n\t\t\t\t\t} ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak ;\n\t}\n} ;\n\n\n\n/*\n\tThis is the tile-variant of the regionIterator.\n\t\n\tIterator.\n\tMandatory params:\n\t\t* dstRect\n\t\t* srcRect\n\t\t* type: 'line' or 'cell'\n\tOptionnal params:\n\t\t* context: an object that will be transmitted as is to the iterator\n\t\t* dstClipRect\n\t\t* srcClipRect\n\t\t* offsetX\n\t\t* offsetY\n\t\t* multiply\n*/\nRect.tileIterator = function tileIterator( p , iterator )\n{\n\tvar srcI , srcJ , srcX , srcY , dstI , dstJ , dstX , dstY , streak , srcStart , dstStart ;\n\t\n\tif ( ! p.multiply ) { p.multiply = 1 ; }\n\tif ( ! p.offsetX ) { p.offsetX = 0 ; }\n\tif ( ! p.offsetY ) { p.offsetY = 0 ; }\n\t\n\tif ( p.dstClipRect ) { p.dstClipRect.clip( p.dstRect ) ; }\n\telse { p.dstClipRect = Rect.create( p.dstRect ) ; }\n\t\n\tif ( p.srcClipRect ) { p.srcClipRect.clip( p.srcRect ) ; }\n\telse { p.srcClipRect = Rect.create( p.srcRect ) ; }\n\t\n\t\n\tswitch ( p.type )\n\t{\n\t\tcase 'cell' :\n\t\t\tfor ( dstJ = 0 ; dstJ < p.dstClipRect.height ; dstJ ++ )\n\t\t\t{\n\t\t\t\tsrcJ = ( dstJ - p.offsetY ) % p.srcClipRect.height ;\n\t\t\t\tif ( srcJ < 0 ) { srcJ += p.srcClipRect.height ; }\n\t\t\t\t\n\t\t\t\tfor ( dstI = 0 ; dstI < p.dstClipRect.width ; dstI ++ )\n\t\t\t\t{\n\t\t\t\t\tsrcI = ( dstI - p.offsetX ) % p.srcClipRect.width ;\n\t\t\t\t\tif ( srcI < 0 ) { srcI += p.srcClipRect.width ; }\n\t\t\t\t\t\n\t\t\t\t\tsrcX = p.srcClipRect.xmin + srcI ;\n\t\t\t\t\tsrcY = p.srcClipRect.ymin + srcJ ;\n\t\t\t\t\t\n\t\t\t\t\tdstX = p.dstClipRect.xmin + dstI ;\n\t\t\t\t\tdstY = p.dstClipRect.ymin + dstJ ;\n\t\t\t\t\t\n\t\t\t\t\tsrcStart = ( srcY * p.srcRect.width + srcX ) * p.multiply ;\n\t\t\t\t\tdstStart = ( dstY * p.dstRect.width + dstX ) * p.multiply ;\n\t\t\t\t\t\n\t\t\t\t\titerator( {\n\t\t\t\t\t\tcontext: p.context ,\n\t\t\t\t\t\tsrcX: srcX ,\n\t\t\t\t\t\tsrcY: srcY ,\n\t\t\t\t\t\tsrcStart: srcStart ,\n\t\t\t\t\t\tsrcEnd: srcStart + p.multiply ,\n\t\t\t\t\t\tdstX: dstX ,\n\t\t\t\t\t\tdstY: dstY ,\n\t\t\t\t\t\tdstStart: dstStart ,\n\t\t\t\t\t\tdstEnd: dstStart + p.multiply\n\t\t\t\t\t} ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak ;\n\t\t\t\n\t\tcase 'line' :\n\t\t\tfor ( dstJ = 0 ; dstJ < p.dstClipRect.height ; dstJ ++ )\n\t\t\t{\n\t\t\t\tsrcJ = ( dstJ - p.offsetY ) % p.srcClipRect.height ;\n\t\t\t\tif ( srcJ < 0 ) { srcJ += p.srcClipRect.height ; }\n\t\t\t\t\n\t\t\t\tdstI = 0 ;\n\t\t\t\twhile ( dstI < p.dstClipRect.width )\n\t\t\t\t{\n\t\t\t\t\tsrcI = ( dstI - p.offsetX ) % p.srcClipRect.width ;\n\t\t\t\t\tif ( srcI < 0 ) { srcI += p.srcClipRect.width ; }\n\t\t\t\t\t\n\t\t\t\t\tstreak = Math.min( p.srcClipRect.width - srcI , p.dstClipRect.width - dstI ) ;\n\t\t\t\t\t\n\t\t\t\t\tsrcX = p.srcClipRect.xmin + srcI ;\n\t\t\t\t\tsrcY = p.srcClipRect.ymin + srcJ ;\n\t\t\t\t\t\n\t\t\t\t\tdstX = p.dstClipRect.xmin + dstI ;\n\t\t\t\t\tdstY = p.dstClipRect.ymin + dstJ ;\n\t\t\t\t\t\n\t\t\t\t\tsrcStart = ( srcY * p.srcRect.width + srcX ) * p.multiply ;\n\t\t\t\t\tdstStart = ( dstY * p.dstRect.width + dstX ) * p.multiply ;\n\t\t\t\t\t\n\t\t\t\t\titerator( {\n\t\t\t\t\t\tcontext: p.context ,\n\t\t\t\t\t\tsrcXmin: srcX ,\n\t\t\t\t\t\tsrcXmax: srcX + streak - 1 ,\n\t\t\t\t\t\tsrcY: srcY ,\n\t\t\t\t\t\tsrcStart: srcStart ,\n\t\t\t\t\t\tsrcEnd: srcStart + streak * p.multiply ,\n\t\t\t\t\t\tdstXmin: dstX ,\n\t\t\t\t\t\tdstXmax: dstX + streak - 1 ,\n\t\t\t\t\t\tdstY: dstY ,\n\t\t\t\t\t\tdstStart: dstStart ,\n\t\t\t\t\t\tdstEnd: dstStart + streak * p.multiply\n\t\t\t\t\t} ) ;\n\t\t\t\t\t\n\t\t\t\t\tdstI += streak ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak ;\n\t}\n} ;\n\n\n\n/*\n\tThis is the wrap-variant of the regionIterator.\n\t\n\tIterator.\n\tMandatory params:\n\t\t* dstRect\n\t\t* srcRect\n\t\t* type: 'line' or 'cell'\n\tOptionnal params:\n\t\t* context: an object that will be transmitted as is to the iterator\n\t\t* dstClipRect\n\t\t* srcClipRect\n\t\t* offsetX\n\t\t* offsetY\n\t\t* multiply\n\t\t* wrapOnly: 'x' , 'y' (only wrap along that axis)\n*/\nRect.wrapIterator = function wrapIterator( p , iterator )\n{\n\tvar i , regions ;\n\t\n\tregions = Rect.wrappingRect( {\n\t\tdstRect: p.dstClipRect ,\n\t\tsrcRect: p.srcClipRect ,\n\t\toffsetX: p.offsetX ,\n\t\toffsetY: p.offsetY ,\n\t\twrapOnly: p.wrap\n\t} ) ;\n\t\n\tfor ( i = 0 ; i < regions.length ; i ++ )\n\t{\n\t\tp.dstClipRect = regions[ i ].dstRect ;\n\t\tp.srcClipRect = regions[ i ].srcRect ;\n\t\tp.offsetX = regions[ i ].offsetX ;\n\t\tp.offsetY = regions[ i ].offsetY ;\n\t\tRect.regionIterator( p , iterator ) ;\n\t}\n} ;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/ScreenBuffer.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\n//var tree = require( 'tree-kit' ) ;\n//var async = require( 'async-kit' ) ;\n\n//var events = require( 'events' ) ;\nvar NextGenEvents = require( 'nextgen-events' ) ;\nvar fs = require( 'fs' ) ;\nvar string = require( 'string-kit' ) ;\nvar punycode = require( 'punycode' ) ;\n\n\n\nfunction ScreenBuffer() { throw new Error( 'Cannot create ScreenBuffer object directly.' ) ; }\nmodule.exports = ScreenBuffer ;\nScreenBuffer.prototype = Object.create( NextGenEvents.prototype ) ;\nScreenBuffer.prototype.constructor = ScreenBuffer ;\nScreenBuffer.prototype.bitsPerColor = 8 ;\n\n\n\nvar termkit = require( './termkit.js' ) ;\n\n\n\n/*\n\toptions:\n\t\t* width: buffer width (default to dst.width)\n\t\t* height: buffer height (default to dst.height)\n\t\t* dst: writting destination\n\t\t* x: default position in the dst\n\t\t* y: default position in the dst\n\t\t* wrap: default wrapping behavior of .put()\n\t\t* noFill: do not call .fill() with default values at ScreenBuffer creation\n\t\t* blending: false/null or true or object (blending options): default blending params (can be overriden by .draw())\n*/\nScreenBuffer.create = function create( options )\n{\n\t// Manage options\n\tif ( ! options ) { options = {} ; }\n\t\n\tvar self = Object.create( ScreenBuffer.prototype , {\n\t\t// a terminal or another screenBuffer\n\t\tdst: { value: options.dst , writable: true , enumerable: true } ,\n\t\twidth: { enumerable: true , configurable: true ,\n\t\t\tvalue: Math.floor( options.width ) || ( options.dst ? options.dst.width : 1 )\n\t\t} ,\n\t\theight: { enumerable: true , configurable: true ,\n\t\t\tvalue: Math.floor( options.height ) || ( options.dst ? options.dst.height : 1 )\n\t\t} ,\n\t\tx: { writable: true , enumerable: true , value:\n\t\t\toptions.x !== undefined ? options.x : ( options.dst && options.dst instanceof termkit.Terminal ? 1 : 0 )\n\t\t} ,\n\t\ty: { writable: true , enumerable: true , value:\n\t\t\toptions.y !== undefined ? options.y : ( options.dst && options.dst instanceof termkit.Terminal ? 1 : 0 )\n\t\t} ,\n\t\tcx: { value: 0 , writable: true , enumerable: true } ,\n\t\tcy: { value: 0 , writable: true , enumerable: true } ,\n\t\tblending: { value: options.blending || false , writable: true , enumerable: true } ,\n\t\twrap: { value: !! options.wrap , writable: true , enumerable: true }\n\t} ) ;\n\t\n\tObject.defineProperties( self , {\n\t\tbuffer: { enumerable: true , configurable: true ,\n\t\t\tvalue: Buffer.allocUnsafe( self.width * self.height * self.ITEM_SIZE ) \n\t\t}\n\t} ) ;\n\t\n\tif ( ! options.noFill ) { self.fill() ; }\n\t\n\treturn self ;\n} ;\n\n\n\n/*\n\toptions:\n\t\t* attr: attributes passed to .put()\n\t\t* transparencyChar: a char that is transparent\n\t\t* transparencyType: bit flags for the transparency char\n*/\nScreenBuffer.createFromString = function createFromString( options , data )\n{\n\tvar x , y , len , attr , attrTrans , width , height , self ;\n\t\n\t// Manage options\n\tif ( ! options ) { options = {} ; }\n\t\n\tif ( typeof data !== 'string' )\n\t{\n\t\tif ( ! data.toString ) { throw new Error( '[terminal] ScreenBuffer.createFromDataString(): argument #1 should be a string or provide a .toString() method.' ) ; }\n\t\tdata = data.toString() ;\n\t}\n\t\n\t// Transform the data into an array of lines\n\tdata = termkit.stripControlChars( data , true ).split( '\\n' ) ;\n\t\n\t// Compute the buffer size\n\twidth = 0 ;\n\theight = data.length ;\n\t\n\tattr = options.attr !== undefined ? options.attr : ScreenBuffer.prototype.DEFAULT_ATTR ;\n\tif ( attr && typeof attr === 'object' && ! attr.BYTES_PER_ELEMENT ) { attr = ScreenBuffer.object2attr( attr ) ; }\n\t\n\tattrTrans = attr ;\n\t\n\tif ( options.transparencyChar )\n\t{\n\t\tif ( ! options.transparencyType ) { attrTrans |= TRANSPARENCY ; }\n\t\telse { attrTrans |= options.transparencyType & TRANSPARENCY ; }\n\t}\n\t\n\t// Compute the width of the screenBuffer\n\tfor ( y = 0 ; y < data.length ; y ++ )\n\t{\n\t\tif ( data[ y ].length > width ) { width = data[ y ].length ; }\n\t}\n\t\n\t// Create the buffer with the right width & height\n\tself = ScreenBuffer.create( { width: width , height: height } ) ;\n\t\n\t// Fill the buffer with data\n\tfor ( y = 0 ; y < data.length ; y ++ )\n\t{\n\t\tif ( ! options.transparencyChar )\n\t\t{\n\t\t\tself.put( { x: 0 , y: y , attr: attr } , data[ y ] ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlen = data[ y ].length ;\n\t\t\t\n\t\t\tfor ( x = 0 ; x < len ; x ++ )\n\t\t\t{\n\t\t\t\tif ( data[ y ][ x ] === options.transparencyChar )\n\t\t\t\t{\n\t\t\t\t\tself.put( { x: x , y: y , attr: attrTrans } , data[ y ][ x ] ) ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tself.put( { x: x , y: y , attr: attr } , data[ y ][ x ] ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn self ;\n} ;\n\n\n\n// Backward compatibility\nScreenBuffer.createFromChars = ScreenBuffer.createFromString ;\n\n\n\n/*\n\toptions:\n\t\tchar: the buffer will be filled with that char\n\t\tattr: the attribute to fill\n\t\tbuffer: used when we want to clear a Buffer instance, not a ScreenBuffer instance\n*/\n// Shared\nScreenBuffer.prototype.fill = function fill( options )\n{\n\t//this.buffer.fill( 0 ) ; return this ;\n\t\n\tvar i , attr , char , length ,\n\t\tclearBuffer = this.CLEAR_BUFFER ,\n\t\tbuffer = this.buffer ;\n\t\n\tif ( options && typeof options === 'object' ) \n\t{\n\t\tclearBuffer = Buffer.allocUnsafe( this.ITEM_SIZE ) ;\n\t\t\n\t\t// Write the attributes\n\t\tattr = options.attr !== undefined ? options.attr : this.DEFAULT_ATTR ;\n\t\tif ( attr && typeof attr === 'object' && ! attr.BYTES_PER_ELEMENT ) { attr = this.object2attr( attr ) ; }\n\t\t\n\t\tthis.writeAttr( clearBuffer , attr , 0 ) ;\n\t\t\n\t\t// Write the character\n\t\tchar = options.char && typeof options.char === 'string' ? options.char : ' ' ;\n\t\tchar = punycode.ucs2.encode( [ punycode.ucs2.decode( termkit.stripControlChars( char ) )[ 0 ] ] ) ;\n\t\t\n\t\t//clearBuffer.write( char , this.ATTR_SIZE , this.CHAR_SIZE ) ;\n\t\tthis.writeChar( clearBuffer , char , 0 ) ;\n\t\t\n\t\t// This option is used when we want to clear a Buffer instance, not a ScreenBuffer instance\n\t\tif ( options.buffer ) { buffer = options.buffer ; }\n\t}\n\t\n\t// It is always an integer\n\tlength = buffer.length / this.ITEM_SIZE ;\n\t\n\tfor ( i = 0 ; i < length ; i ++ )\n\t{\n\t\tclearBuffer.copy( buffer , i * this.ITEM_SIZE ) ;\n\t}\n} ;\n\n\n\n/*\n\tput( options , str )\n\tput( options , format , [arg1] , [arg2] , ... )\n\t\n\toptions:\n\t\t* x: bypass this.cx\n\t\t* y: bypass this.cy\n\t\t* attr: standard attributes\n\t\t* wrap: text wrapping, when the cursor move beyond the last column, it is moved to the begining of the next line\n\t\t* direction: 'right' (default), 'left', 'up', 'down' or 'none'/null (do not move after puting a char)\n\t\t* dx: x increment after each character (default: 1)\n\t\t* dy: y increment after each character (default: 0)\n*/\n// Shared\nScreenBuffer.prototype.put = function put( options , str )\n{\n\tvar i , x , y , dx , dy , attr , wrap , characters , len , offset ;\n\t\n\t// Manage options\n\tif ( ! options ) { options = {} ; }\n\t\n\tif ( options.wrap !== undefined ) { wrap = options.wrap ; }\n\telse { wrap = this.wrap ; }\n\t\n\tx = Math.floor( options.x !== undefined ? options.x : this.cx ) ;\n\ty = Math.floor( options.y !== undefined ? options.y : this.cy ) ;\n\t\n\t\n\t// Process directions/increments\n\tdx = 1 ;\n\tdy = 0 ;\n\t\n\tswitch ( options.direction )\n\t{\n\t\t//case 'right' : // not needed, use the default dx & dy\n\t\tcase 'left' :\n\t\t\tdx = -1 ;\n\t\t\tbreak ;\n\t\tcase 'up' :\n\t\t\tdx = 0 ;\n\t\t\tdy = -1 ;\n\t\t\tbreak ;\n\t\tcase 'down' :\n\t\t\tdx = 0 ;\n\t\t\tdy = 1 ;\n\t\t\tbreak ;\n\t\tcase null :\n\t\tcase 'none' :\n\t\t\tdx = 0 ;\n\t\t\tdy = 0 ;\n\t\t\tbreak ;\n\t}\n\t\n\tif ( typeof options.dx === 'number' ) { dx = options.dx ; }\n\tif ( typeof options.dy === 'number' ) { dy = options.dy ; }\n\t\n\t\n\t// Process attributes\n\tattr = options.attr !== undefined ? options.attr : this.DEFAULT_ATTR ;\n\tif ( attr && typeof attr === 'object' && ! attr.BYTES_PER_ELEMENT ) { attr = this.object2attr( attr ) ; }\n\t\n\t\n\t// Process the input string\n\tif ( typeof str !== 'string' )\n\t{\n\t\tif ( str.toString ) { str = str.toString() ; }\n\t\telse { return ; }\n\t}\n\t\n\tif ( arguments.length > 2 ) { str = string.format.apply( undefined , Array.prototype.slice.call( arguments , 1 ) ) ; }\n\tstr = termkit.stripControlChars( str ) ;\n\t\n\t// /!\\ Fix that punycode thing, and don't forget to fix Terminal#put() too... /!\\\n\tcharacters = punycode.ucs2.decode( str ) ;\n\tlen = characters.length ;\n\t\n\tfor ( i = 0 ; i < len ; i ++ )\n\t{\n\t\toffset = ( y * this.width + x ) * this.ITEM_SIZE ;\n\t\t\n\t\t//if ( offset >= 0 && offset < this.buffer.length )\n\t\tif ( x >= 0 && x < this.width && y >= 0 && y < this.height )\n\t\t{\n\t\t\t// Write the attributes\n\t\t\tthis.writeAttr( this.buffer , attr , offset ) ;\n\t\t\t\n\t\t\t// Write the character\n\t\t\tthis.writeChar( this.buffer , punycode.ucs2.encode( [ characters[ i ] ] ) , offset ) ;\n\t\t}\n\t\t\n\t\tx += dx ;\n\t\ty += dy ;\n\t\t\n\t\tif ( x < 0 )\n\t\t{\n\t\t\tif ( ! wrap ) { x = 0 ; break ; }\n\t\t\tx = this.width - 1 ;\n\t\t\ty -- ;\n\t\t}\n\t\telse if ( x >= this.width )\n\t\t{\n\t\t\tif ( ! wrap ) { x = this.width - 1 ; break ; }\n\t\t\tx = 0 ;\n\t\t\ty ++ ;\n\t\t}\n\t\t\n\t\tif ( y < 0 ) { y = 0 ; break ; }\n\t\telse if ( y >= this.height ) { y = this.height - 1 ; break ; }\n\t}\n\t\n\tthis.cx = x ;\n\tthis.cy = y ;\n} ;\n\n\n\n/*\n\toptions:\n\t\t* x: bypass this.cx\n\t\t* y: bypass this.cy\n*/\n// Shared\nScreenBuffer.prototype.get = function get( options )\n{\n\tvar x , y , offset ;\n\t\n\t// Manage options\n\tif ( ! options ) { options = {} ; }\n\t\n\tx = options.x !== undefined ? options.x : this.cx ;\n\ty = options.y !== undefined ? options.y : this.cy ;\n\t\n\tif ( typeof x !== 'number' || x < 0 || x >= this.width ) { return null ; }\n\telse { x = Math.floor( x ) ; }\n\t\n\tif ( typeof y !== 'number' || y < 0 || y >= this.height ) { return null ; }\n\telse { y = Math.floor( y ) ; }\n\t\n\toffset = ( y * this.width + x ) * this.ITEM_SIZE ;\n\t\n\treturn {\n\t\tattr: this.attr2object( this.readAttr( this.buffer , offset ) ) ,\n\t\tchar: this.readChar( this.buffer , offset )\n\t} ;\n} ;\n\n\n\n// Resize a screenBuffer, using a termkit.Rect\n// Shared\nScreenBuffer.prototype.resize = function resize( fromRect )\n{\n\t// Do not reference directly the userland variable, clone it\n\tfromRect = termkit.Rect.create( fromRect ) ;\n\t\n\tvar offsetX = - fromRect.xmin ,\n\t\toffsetY = - fromRect.ymin ;\n\t\n\t// Create the toRect region\n\tvar toRect = termkit.Rect.create( {\n\t\txmin: 0 ,\n\t\tymin: 0 ,\n\t\txmax: fromRect.width - 1 ,\n\t\tymax: fromRect.height - 1\n\t} ) ;\n\t\n\tfromRect.clip( termkit.Rect.create( this ) ) ;\n\t\n\tif ( toRect.isNull ) { return false ; }\n\t\n\t// Generate a new buffer\n\tvar resizedBuffer = Buffer.allocUnsafe( toRect.width * toRect.height * this.ITEM_SIZE ) ;\n\tthis.fill( { buffer: resizedBuffer } ) ;\n\t\n\t// We use the blit to reconstruct the buffer geometry\n\ttermkit.Rect.regionIterator( {\n\t\ttype: 'line' ,\n\t\tcontext: { srcBuffer: this.buffer , dstBuffer: resizedBuffer } ,\n\t\tdstRect: toRect ,\n\t\tdstClipRect: termkit.Rect.create( toRect ) ,\n\t\tsrcRect: termkit.Rect.create( this ) ,\n\t\tsrcClipRect: fromRect ,\n\t\toffsetX: offsetX ,\n\t\toffsetY: offsetY ,\n\t\tmultiply: this.ITEM_SIZE\n\t} , this.blitterLineIterator.bind( this ) ) ;\n\t\n\t// Now, we have to replace the old buffer with the new, and set the width & height\n\tObject.defineProperties( this , {\n\t\twidth: { value: toRect.width , enumerable: true , configurable: true } ,\n\t\theight: { value: toRect.height , enumerable: true , configurable: true } ,\n\t\tbuffer: { value: resizedBuffer , enumerable: true , configurable: true }\n\t} ) ;\n\t\n\t// Disable the lastBuffer, so `draw( { delta: true } )` will not be bugged\n\tthis.lastBuffer = null ;\n\t\n\t// This exists to improve compatibilities with the Terminal object\n\tthis.emit( 'resize' , this.width , this.height ) ;\n\t\n\treturn true ;\n} ;\n\n\n\n// Shared\nScreenBuffer.prototype.draw = function draw( options )\n{\n\tvar stats ;\n\t\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\t// Transmitted options (do not edit the user provided options, clone them)\n\tvar tr = {\n\t\tdst: options.dst || this.dst ,\n\t\toffsetX: options.x !== undefined ? Math.floor( options.x ) : Math.floor( this.x ) ,\n\t\toffsetY: options.y !== undefined ? Math.floor( options.y ) : Math.floor( this.y ) ,\n\t\tdstClipRect: options.dstClipRect ? termkit.Rect.create( options.dstClipRect ) : undefined ,\n\t\tsrcClipRect: options.srcClipRect ? termkit.Rect.create( options.srcClipRect ) : undefined ,\n\t\tdelta: options.delta ,\n\t\tblending: options.blending !== undefined ? options.blending : this.blending ,\n\t\twrap: options.wrap ,\n\t\ttile: options.tile\n\t} ;\n\t\n\tif ( tr.dst instanceof ScreenBuffer )\n\t{\n\t\treturn this.blitter( tr ) ;\n\t}\n\telse if ( tr.dst instanceof termkit.Terminal )\n\t{\n\t\treturn this.terminalBlitter( tr ) ;\n\t}\n} ;\n\n\n\n// Shared\nScreenBuffer.prototype.moveTo = function moveTo( x , y )\n{\n\tthis.cx = Math.max( 0 , Math.min( x , this.width - 1 ) ) ;\n\tthis.cy = Math.max( 0 , Math.min( y , this.height - 1 ) ) ;\n} ;\n\n\n\n// Shared\nScreenBuffer.prototype.drawCursor = function drawCursor( options )\n{\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tvar dst = options.dst || this.dst ;\n\t\n\tif ( dst instanceof ScreenBuffer )\n\t{\n\t\tdst.moveTo( this.cx + this.x , this.cy + this.y ) ;\n\t}\n\telse if ( dst instanceof termkit.Terminal )\n\t{\n\t\tdst.moveTo(\n\t\t\tMath.max( 1 , Math.min( this.cx + this.x , dst.width ) ) ,\n\t\t\tMath.max( 1 , Math.min( this.cy + this.y , dst.height ) )\n\t\t) ;\n\t}\n} ;\n\n\n\n// Shared\nScreenBuffer.prototype.blitter = function blitter( p )\n{\n\tvar tr , iterator , iteratorCallback ;\n\t\n\t// Default options & iterator\n\ttr = {\n\t\ttype: 'line' ,\n\t\tcontext: { srcBuffer: this.buffer , dstBuffer: p.dst.buffer , blending: p.blending } ,\n\t\tdstRect: termkit.Rect.create( p.dst ) ,\n\t\tsrcRect: termkit.Rect.create( this ) ,\n\t\tdstClipRect: p.dstClipRect || termkit.Rect.create( p.dst ) ,\n\t\tsrcClipRect: p.srcClipRect || termkit.Rect.create( this ) ,\n\t\toffsetX: p.offsetX ,\n\t\toffsetY: p.offsetY ,\n\t\twrap: p.wrap ,\n\t\ttile: p.tile ,\n\t\tmultiply: this.ITEM_SIZE\n\t} ;\n\t\n\titerator = 'regionIterator' ;\n\titeratorCallback = this.blitterLineIterator.bind( this ) ;\n\t\n\t\n\t// If blending is on, switch to the cell iterator\n\tif ( p.blending )\n\t{\n\t\ttr.type = 'cell' ;\n\t\titeratorCallback = this.blitterCellBlendingIterator.bind( this ) ;\n\t}\n\t\n\tif ( p.wrap ) { iterator = 'wrapIterator' ; }\n\telse if ( p.tile ) { iterator = 'tileIterator' ; }\n\telse { iterator = 'regionIterator' ; }\n\t\n\ttermkit.Rect[ iterator ]( tr , iteratorCallback ) ;\n} ;\n\n\n\n// Shared\nScreenBuffer.prototype.blitterLineIterator = function blitterLineIterator( p )\n{\n\tp.context.srcBuffer.copy( p.context.dstBuffer , p.dstStart , p.srcStart , p.srcEnd ) ;\n} ;\n\n\n\nScreenBuffer.prototype.blitterCellBlendingIterator = function blitterCellBlendingIterator( p )\n{\n\tvar blending = this.readAttr( p.context.srcBuffer , p.srcStart ) & TRANSPARENCY ;\n\t\n\tif ( blending === NONE )\n\t{\n\t\t// Fully visible, copy it\n\t\tp.context.srcBuffer.copy( p.context.dstBuffer , p.dstStart , p.srcStart , p.srcEnd ) ;\n\t\treturn ;\n\t}\n\t\n\tif ( blending === TRANSPARENCY )\n\t{\n\t\t// Fully transparent, do nothing\n\t\treturn ;\n\t}\n\t\n\t\n\t// Blending part...\n\t\n\tif ( ! ( blending & FG_TRANSPARENCY ) )\n\t{\n\t\t// Copy source foreground color\n\t\tp.context.srcBuffer.copy(\n\t\t\tp.context.dstBuffer ,\n\t\t\tp.dstStart + 3 ,\n\t\t\tp.srcStart + 3 ,\n\t\t\tp.srcStart + 4\n\t\t) ;\n\t}\n\t\n\tif ( ! ( blending & BG_TRANSPARENCY ) )\n\t{\n\t\t// Copy source background color\n\t\tp.context.srcBuffer.copy(\n\t\t\tp.context.dstBuffer ,\n\t\t\tp.dstStart + 2 ,\n\t\t\tp.srcStart + 2 ,\n\t\t\tp.srcStart + 3\n\t\t) ;\n\t}\n\t\n\tif ( ! ( blending & STYLE_TRANSPARENCY ) )\n\t{\n\t\t// Copy source style\n\t\tp.context.srcBuffer.copy(\n\t\t\tp.context.dstBuffer ,\n\t\t\tp.dstStart + 1 ,\n\t\t\tp.srcStart + 1 ,\n\t\t\tp.srcStart + 2\n\t\t) ;\n\t}\n\t\n\tif ( ! ( blending & CHAR_TRANSPARENCY ) )\n\t{\n\t\t// Copy source character\n\t\tp.context.srcBuffer.copy(\n\t\t\tp.context.dstBuffer ,\n\t\t\tp.dstStart + this.ATTR_SIZE ,\n\t\t\tp.srcStart + this.ATTR_SIZE ,\n\t\t\tp.srcEnd\n\t\t) ;\n\t}\n} ;\n\n\n\n// Shared\nScreenBuffer.prototype.terminalBlitter = function terminalBlitter( p )\n{\n\tvar tr , iterator , iteratorCallback , context ;\n\t\n\tcontext = {\n\t\tsrcBuffer: this.buffer ,\n\t\tblending: p.blending ,\n\t\tterm: p.dst ,\n\t\tdeltaEscapeSequence: p.dst.support.deltaEscapeSequence ,\n\t\tnfterm: p.dst.noFormat ,\n\t\tlastAttr: null ,\n\t\tsequence: '' ,\n\t\tcells: 0 ,\n\t\tmoves: 0 ,\n\t\tattrs: 0 ,\n\t\twrites: 0\n\t} ;\n\t\n\t// Default options & iterator\n\ttr = {\n\t\ttype: 'line' ,\n\t\tcontext: context ,\n\t\tdstRect: termkit.Rect.create( p.dst ) ,\n\t\tsrcRect: termkit.Rect.create( this ) ,\n\t\tdstClipRect: p.dstClipRect ,\n\t\tsrcClipRect: p.srcClipRect ,\n\t\toffsetX: p.offsetX ,\n\t\toffsetY: p.offsetY ,\n\t\tmultiply: this.ITEM_SIZE\n\t} ;\n\t\n\tif ( p.delta )\n\t{\n\t\tif ( ! this.lastBuffer || this.lastBuffer.length !== this.buffer.length )\n\t\t{\n\t\t\tthis.lastBuffer = Buffer.from( this.buffer ) ;\n\t\t\titeratorCallback = this.terminalBlitterLineIterator.bind( this ) ;\n\t\t}\n\t\telse if ( this.lastBufferUpToDate )\n\t\t{\n\t\t\tcontext.srcLastBuffer = this.lastBuffer ;\n\t\t\t\n\t\t\titeratorCallback = this.terminalBlitterCellIterator.bind( this ) ;\n\t\t\ttr.type = 'cell' ;\n\t\t}\n\t\t\n\t\tthis.lastBufferUpToDate = true ;\n\t}\n\telse\n\t{\n\t\tthis.lastBufferUpToDate = false ;\n\t\titeratorCallback = this.terminalBlitterLineIterator.bind( this ) ;\n\t}\n\t\n\t\n\tif ( p.wrap ) { iterator = 'wrapIterator' ; }\n\telse if ( p.tile ) { iterator = 'tileIterator' ; }\n\telse { iterator = 'regionIterator' ; }\n\t\n\ttermkit.Rect[ iterator ]( tr , iteratorCallback ) ;\n\t\n\t// Write remaining sequence\n\tif ( context.sequence.length ) { context.nfterm( context.sequence ) ; context.writes ++ ; }\n\t\n\t// Copy buffer to lastBuffer\n\t// Already done by terminalBlitterCellIterator()\n\t// if ( p.delta ) { this.buffer.copy( this.lastBuffer ) ; }\n\t\n\t// Return some stats back to the caller\n\treturn {\n\t\tcells: context.cells ,\n\t\tmoves: context.moves ,\n\t\tattrs: context.attrs ,\n\t\twrites: context.writes\n\t} ;\n} ;\n\n\n\nScreenBuffer.prototype.terminalBlitterLineIterator = function terminalBlitterLineIterator( p )\n{\n\tvar offset , attr ;\n\t\n\tp.context.sequence += p.context.term.optimized.moveTo( p.dstXmin , p.dstY ) ;\n\tp.context.moves ++ ;\n\t\n\tfor ( offset = p.srcStart ; offset < p.srcEnd ; offset += this.ITEM_SIZE )\n\t{\n\t\tattr = this.readAttr( p.context.srcBuffer , offset ) ;\n\t\t\n\t\tif ( attr !== p.context.lastAttr )\n\t\t{\n\t\t\tp.context.sequence += p.context.lastAttr === null || ! p.context.deltaEscapeSequence ?\n\t\t\t\tthis.generateEscapeSequence( p.context.term , attr ) :\n\t\t\t\tthis.generateDeltaEscapeSequence( p.context.term , attr , p.context.lastAttr ) ;\n\t\t\tp.context.lastAttr = attr ;\n\t\t\tp.context.attrs ++ ;\n\t\t}\n\t\t\n\t\tp.context.sequence += this.readChar( p.context.srcBuffer , offset ) ;\n\t\tp.context.cells ++ ;\n\t}\n\t\n\t// Output buffering saves a good amount of CPU usage both for the node's processus and the terminal processus\n\tif ( p.context.sequence.length > OUTPUT_THRESHOLD )\n\t{\n\t\tp.context.nfterm( p.context.sequence ) ;\n\t\tp.context.sequence = '' ;\n\t\tp.context.writes ++ ;\n\t}\n} ;\n\n\n\nScreenBuffer.prototype.terminalBlitterCellIterator = function terminalBlitterCellIterator( p )\n{\n\tvar attr = this.readAttr( p.context.srcBuffer , p.srcStart ) ;\n\t\n\t// If last buffer's cell === current buffer's cell, no need to refresh... skip that now\n\tif ( p.context.srcLastBuffer )\n\t{\n\t\tif (\n\t\t\tattr === this.readAttr( p.context.srcLastBuffer , p.srcStart ) &&\n\t\t\tthis.readChar( p.context.srcBuffer , p.srcStart ) === this.readChar( p.context.srcLastBuffer , p.srcStart ) )\n\t\t{\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tp.context.srcBuffer.copy( p.context.srcLastBuffer , p.srcStart , p.srcStart , p.srcEnd ) ;\n\t}\n\t\n\tp.context.cells ++ ;\n\t\n\tif ( p.dstX !== p.context.cx || p.dstY !== p.context.cy )\n\t{\n\t\tp.context.sequence += p.context.term.optimized.moveTo( p.dstX , p.dstY ) ;\n\t\tp.context.moves ++ ;\n\t}\n\t\n\tif ( attr !== p.context.lastAttr )\n\t{\n\t\tp.context.sequence += p.context.lastAttr === null || ! p.context.deltaEscapeSequence ?\n\t\t\tthis.generateEscapeSequence( p.context.term , attr ) :\n\t\t\tthis.generateDeltaEscapeSequence( p.context.term , attr , p.context.lastAttr ) ;\n\t\tp.context.lastAttr = attr ;\n\t\tp.context.attrs ++ ;\n\t}\n\t\n\tp.context.sequence += this.readChar( p.context.srcBuffer , p.srcStart ) ;\n\t\n\t// Output buffering saves a good amount of CPU usage both for the node's processus and the terminal processus\n\tif ( p.context.sequence.length > OUTPUT_THRESHOLD )\n\t{\n\t\tp.context.nfterm( p.context.sequence ) ;\n\t\tp.context.sequence = '' ;\n\t\tp.context.writes ++ ;\n\t}\n\t\n\t// Next expected cursor position\n\tp.context.cx = p.dstX + 1 ;\n\tp.context.cy = p.dstY ;\n} ;\n\n\n\nScreenBuffer.loadSyncV1 = function loadSync( filepath )\n{\n\tvar content , width , height , size , screenBuffer ;\n\t\n\t// Let it crash if nothing found\n\tcontent = fs.readFileSync( filepath ) ;\n\t\n\t// No header found?\n\tif ( content.length < HEADER_SIZE ) { throw new Error( 'No header found: this is not a ScreenBuffer file' ) ; }\n\t\n\t// See if we have got a 'SB' at the begining of the file\n\tif ( content[ 0 ] !== 83 || content[ 1 ] !== 66 ) { throw new Error( 'Magic number mismatch: this is not a ScreenBuffer file' ) ; }\n\t\n\t// Get the geometry\n\twidth = content.readUInt16BE( 4 ) ;\n\theight = content.readUInt16BE( 6 ) ;\n\t\n\t// Guess the file size\n\tsize = HEADER_SIZE + width * height * ScreenBuffer.prototype.ITEM_SIZE ;\n\t\n\t// Bad size?\n\tif ( content.length !== size ) { throw new Error( 'Bad file size: this is not a ScreenBuffer file' ) ; }\n\t\n\t// So the file exists, create a canvas based upon it\n\tscreenBuffer = ScreenBuffer.create( {\n\t\twidth: width ,\n\t\theight: height\n\t} ) ;\n\t\n\tcontent.copy( screenBuffer.buffer , 0 , HEADER_SIZE ) ;\n\t\n\treturn screenBuffer ;\n} ;\n\n\n\nScreenBuffer.prototype.saveSyncV1 = function saveSync( filepath )\n{\n\tvar content ;\n\t\n\tcontent = Buffer.allocUnsafe( HEADER_SIZE + this.buffer.length ) ;\n\t\n\t// Clear the header area\n\tcontent.fill( 0 , 0 , HEADER_SIZE ) ;\n\t\n\t// Write the 'SB' magic number\n\tcontent[ 0 ] = 83 ;\n\tcontent[ 1 ] = 66 ;\n\t\n\t// Set the geometry\n\tcontent.writeUInt16BE( this.width , 4 ) ;\n\tcontent.writeUInt16BE( this.height , 6 ) ;\n\t\n\tthis.buffer.copy( content , HEADER_SIZE ) ;\n\t\n\t// Let it crash if something bad happens\n\tfs.writeFileSync( filepath , content ) ;\n} ;\n\n\n\nScreenBuffer.loadSyncV2 = function loadSync( filepath )\n{\n\tvar i , content , header , screenBuffer ;\n\t\n\t// Let it crash if nothing found\n\tcontent = fs.readFileSync( filepath ) ;\n\t\n\t// See if we have got a 'SB' at the begining of the file\n\tif ( content.length < 3 || content.toString( 'ascii' , 0 , 3 ) !== 'SB\\n' )\n\t{\n\t\tthrow new Error( 'Magic number mismatch: this is not a ScreenBuffer file' ) ;\n\t}\n\t\n\t// search for the second \\n\n\tfor ( i = 3 ; i < content.length ; i ++ )\n\t{\n\t\tif ( content[ i ] === 0x0a ) { break ; }\n\t}\n\t\n\tif ( i === content.length )\n\t{\n\t\tthrow new Error( 'No header found: this is not a ScreenBuffer file' ) ;\n\t}\n\t\n\t// Try to parse a JSON header\n\ttry {\n\t\theader = JSON.parse( content.toString( 'utf8' , 3 , i ) ) ;\n\t}\n\tcatch( error ) {\n\t\tthrow new Error( 'No correct one-lined JSON header found: this is not a ScreenBuffer file' ) ;\n\t}\n\t\n\t// Mandatory header field\n\tif ( header.version === undefined || header.width === undefined || header.height === undefined )\n\t{\n\t\tthrow new Error( 'Missing mandatory header data, this is a corrupted or obsolete ScreenBuffer file' ) ;\n\t}\n\t\n\t// Check bitsPerColor\n\tif ( header.bitsPerColor && header.bitsPerColor !== ScreenBuffer.prototype.bitsPerColor )\n\t{\n\t\tthrow new Error( 'Bad Bits Per Color: ' + header.bitsPerColor + ' (should be ' + ScreenBuffer.prototype.bitsPerColor + ')' ) ;\n\t}\n\t\n\t// Bad size?\n\tif ( content.length !== i + 1 + header.width * header.height * ScreenBuffer.prototype.ITEM_SIZE )\n\t{\n\t\tthrow new Error( 'Bad file size: this is a corrupted ScreenBuffer file' ) ;\n\t}\n\t\n\t// So the file exists, create a canvas based upon it\n\tscreenBuffer = ScreenBuffer.create( {\n\t\twidth: header.width ,\n\t\theight: header.height\n\t} ) ;\n\t\n\tcontent.copy( screenBuffer.buffer , 0 , i + 1 ) ;\n\t\n\treturn screenBuffer ;\n} ;\n\n\n\n// This new format use JSON header for a maximal flexibility rather than a fixed binary header.\n// The header start with a magic number SB\\n then a compact single-line JSON that end with an \\n.\n// So the data part start after the second \\n, providing a variable header size.\n// This will allow adding meta data without actually changing the file format.\nScreenBuffer.prototype.saveSyncV2 = function saveSync( filepath )\n{\n\tvar content , header ;\n\t\n\theader = {\n\t\tversion: 2 ,\n\t\twidth: this.width ,\n\t\theight: this.height ,\n\t\tbpp: this.bpp\n\t} ;\n\t\n\theader = 'SB\\n' + JSON.stringify( header ) + '\\n' ;\n\t\n\tcontent = Buffer.allocUnsafe( header.length + this.buffer.length ) ;\n\tcontent.write( header ) ;\n\t\n\tthis.buffer.copy( content , header.length ) ;\n\t\n\t// Let it crash if something bad happens\n\tfs.writeFileSync( filepath , content ) ;\n} ;\n\n\n\nScreenBuffer.loadSync = ScreenBuffer.loadSyncV2 ;\nScreenBuffer.prototype.saveSync = ScreenBuffer.prototype.saveSyncV2 ;\n\n\n\nScreenBuffer.fromNdarrayImage = function fromNdarrayImage( pixels , options )\n{\n\tvar term = options.terminal || termkit.terminal ;\n\t\n\tvar x , xMax = pixels.shape[ 0 ] ,\n\t\ty , yMax = Math.ceil( pixels.shape[ 1 ] / 2 ) ,\n\t\thasAlpha = pixels.shape[ 2 ] === 4 ,\n\t\tmaxRegister = term.support['256colors'] ? 255 : 15 ,\n\t\tfgColor , bgColor ;\n\t\n\tvar image = termkit.ScreenBuffer.create( { width: xMax , height: yMax , blending: true , noFill: true } ) ;\n\t\n\tfor ( x = 0 ; x < xMax ; x ++ )\n\t{\n\t\tfor ( y = 0 ; y < yMax ; y ++ )\n\t\t{\n\t\t\tfgColor = term.registerForRgb(\n\t\t\t\tpixels.get( x , y * 2 , 0 ) ,\n\t\t\t\tpixels.get( x , y * 2 , 1 ) ,\n\t\t\t\tpixels.get( x , y * 2 , 2 ) ,\n\t\t\t\t0 , maxRegister\n\t\t\t) ;\n\t\t\t\n\t\t\tif ( y * 2 + 1 < pixels.shape[ 1 ] )\n\t\t\t{\n\t\t\t\tbgColor = term.registerForRgb(\n\t\t\t\t\tpixels.get( x , y * 2 + 1 , 0 ) ,\n\t\t\t\t\tpixels.get( x , y * 2 + 1 , 1 ) ,\n\t\t\t\t\tpixels.get( x , y * 2 + 1 , 2 ) ,\n\t\t\t\t\t0 , maxRegister\n\t\t\t\t) ;\n\t\t\t\t\n\t\t\t\timage.put(\n\t\t\t\t\t{\n\t\t\t\t\t\tx: x ,\n\t\t\t\t\t\ty: y ,\n\t\t\t\t\t\tattr: {\n\t\t\t\t\t\t\tcolor: fgColor ,\n\t\t\t\t\t\t\tfgTransparency: hasAlpha && pixels.get( x , y * 2 , 3 ) < 127 ,\n\t\t\t\t\t\t\tbgColor: bgColor ,\n\t\t\t\t\t\t\tbgTransparency: hasAlpha && pixels.get( x , y * 2 + 1 , 3 ) < 127\n\t\t\t\t\t\t}\n\t\t\t\t\t} ,\n\t\t\t\t\t'▀'\n\t\t\t\t) ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\timage.put(\n\t\t\t\t\t{\n\t\t\t\t\t\tx: x ,\n\t\t\t\t\t\ty: y ,\n\t\t\t\t\t\tattr: {\n\t\t\t\t\t\t\tcolor: fgColor ,\n\t\t\t\t\t\t\tfgTransparency: hasAlpha && pixels.get( x , y * 2 , 3 ) < 127 ,\n\t\t\t\t\t\t\tbgTransparency: true\n\t\t\t\t\t\t}\n\t\t\t\t\t} ,\n\t\t\t\t\t'▀'\n\t\t\t\t) ;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn image ;\n} ;\n\n\n\nScreenBuffer.loadImage = termkit.image.load.bind( ScreenBuffer , ScreenBuffer.fromNdarrayImage ) ;\n\n\n\n// Shared\nScreenBuffer.prototype.dumpChars = function dumpChars()\n{\n\tvar y , x , offset , str = '' ;\n\t\n\tfor ( y = 0 ; y < this.height ; y ++ )\n\t{\n\t\tfor ( x = 0 ; x < this.width ; x ++ )\n\t\t{\n\t\t\toffset = ( y * this.width + x ) * this.ITEM_SIZE ;\n\t\t\tstr += this.readChar( this.buffer , offset ) ;\n\t\t}\n\t\t\n\t\tstr += '\\n' ;\n\t}\n\t\n\treturn str ;\n} ;\n\n\n\nScreenBuffer.prototype.dump = function dump()\n{\n\tvar y , x , offset , str = '' ;\n\t\n\tfor ( y = 0 ; y < this.height ; y ++ )\n\t{\n\t\tfor ( x = 0 ; x < this.width ; x ++ )\n\t\t{\n\t\t\toffset = ( y * this.width + x ) * this.ITEM_SIZE ;\n\t\t\t\n\t\t\tstr += string.format( '%x%x%x%x ' ,\n\t\t\t\tthis.buffer.readUInt8( offset ) ,\n\t\t\t\tthis.buffer.readUInt8( offset + 1 ) ,\n\t\t\t\tthis.buffer.readUInt8( offset + 2 ) ,\n\t\t\t\tthis.buffer.readUInt8( offset + 3 )\n\t\t\t) ;\n\t\t\t\n\t\t\tstr += this.readChar( this.buffer , offset ) + ' ' ;\n\t\t}\n\t\t\n\t\tstr += '\\n' ;\n\t}\n\t\n\treturn str ;\n} ;\n\n\n\nScreenBuffer.prototype.readAttr = function readAttr( buffer , at )\n{\n\treturn buffer.readInt32BE( at ) ;\n} ;\n\n\n\nScreenBuffer.prototype.writeAttr = function writeAttr( buffer , attr , at )\n{\n\treturn buffer.writeInt32BE( attr , at ) ;\n} ;\n\n\n\nScreenBuffer.prototype.readChar = function readChar( buffer , at )\n{\n\tvar bytes ;\n\t\n\tat += this.ATTR_SIZE ;\n\t\n\tif ( buffer[ at ] < 0x80 ) { bytes = 1 ; }\n\telse if ( buffer[ at ] < 0xc0 ) { return '\\x00' ; } // We are in a middle of an unicode multibyte sequence... something was wrong...\n\telse if ( buffer[ at ] < 0xe0 ) { bytes = 2 ; }\n\telse if ( buffer[ at ] < 0xf0 ) { bytes = 3 ; }\n\telse if ( buffer[ at ] < 0xf8 ) { bytes = 4 ; }\n\telse if ( buffer[ at ] < 0xfc ) { bytes = 5 ; }\n\telse { bytes = 6 ; }\n\t\n\tif ( bytes > this.CHAR_SIZE ) { return '\\x00' ; }\n\t\n\treturn buffer.toString( 'utf8' , at , at + bytes ) ;\n} ;\n\n\n\nScreenBuffer.prototype.writeChar = function writeChar( buffer , char , at )\n{\n\treturn buffer.write( char , at + this.ATTR_SIZE , this.CHAR_SIZE ) ;\n} ;\n\n\n\nScreenBuffer.prototype.generateEscapeSequence = function generateEscapeSequence( term , attr )\n{\n\tvar color = attr & 255 ;\n\tvar bgColor = ( attr >>> 8 ) & 255 ;\n\t\n\tvar esc = term.optimized.styleReset +\n\t\tterm.optimized.color256[ color ] +\n\t\tterm.optimized.bgColor256[ bgColor ] ;\n\t\n\t// Style part\n\tif ( attr & BOLD ) { esc += term.optimized.bold ; }\n\tif ( attr & DIM ) { esc += term.optimized.dim ; }\n\tif ( attr & ITALIC ) { esc += term.optimized.italic ; }\n\tif ( attr & UNDERLINE ) { esc += term.optimized.underline ; }\n\tif ( attr & BLINK ) { esc += term.optimized.blink ; }\n\tif ( attr & INVERSE ) { esc += term.optimized.inverse ; }\n\tif ( attr & HIDDEN ) { esc += term.optimized.hidden ; }\n\tif ( attr & STRIKE ) { esc += term.optimized.strike ; }\n\t\n\treturn esc ;\n} ;\n\n\n\n// Generate only the delta between the last and new attributes, may speed up things for the terminal process\n// as well as consume less bandwidth, at the cost of small CPU increase in the application process\nScreenBuffer.prototype.generateDeltaEscapeSequence = function generateDeltaEscapeSequence( term , attr , lastAttr )\n{\n\t//console.log( 'generateDeltaEscapeSequence' ) ;\n\t\n\tvar esc = '' ,\n\t\tcolor = attr & 255 ,\n\t\tlastColor = lastAttr & 255 ,\n\t\tbgColor = ( attr >>> 8 ) & 255 ,\n\t\tlastBgColor = ( lastAttr >>> 8 ) & 255 ;\n\t\n\tif ( color !== lastColor ) { esc += term.optimized.color256[ color ] ; }\n\tif ( bgColor !== lastBgColor ) { esc += term.optimized.bgColor256[ bgColor ] ; }\n\t\n\tif ( ( attr & STYLE_MASK ) !== ( lastAttr & STYLE_MASK ) )\n\t{\n\t\t// Bold and dim style are particular: all terminal has noBold = noDim\n\t\t\n\t\tif ( ( attr & BOLD_DIM ) !== ( lastAttr & BOLD_DIM ) )\n\t\t{\n\t\t\tif ( ( ( lastAttr & BOLD ) && ! ( attr & BOLD ) ) ||\n\t\t\t\t( ( lastAttr & DIM ) && ! ( attr & DIM ) ) )\n\t\t\t{\n\t\t\t\tesc += term.optimized.noBold ;\n\t\t\t\tif ( attr & BOLD ) { esc += term.optimized.bold ; }\n\t\t\t\tif ( attr & DIM ) { esc += term.optimized.dim ; }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ( ( attr & BOLD ) && ! ( lastAttr & BOLD ) ) { esc += term.optimized.bold ; }\n\t\t\t\tif ( ( attr & DIM ) && ! ( lastAttr & DIM ) ) { esc += term.optimized.dim ; }\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ( ( attr & ITALIC ) !== ( lastAttr & ITALIC ) )\n\t\t{\n\t\t\tesc += attr & ITALIC ? term.optimized.italic : term.optimized.noItalic ;\n\t\t}\n\t\t\n\t\tif ( ( attr & UNDERLINE ) !== ( lastAttr & UNDERLINE ) )\n\t\t{\n\t\t\tesc += attr & UNDERLINE ? term.optimized.underline : term.optimized.noUnderline ;\n\t\t}\n\t\t\n\t\tif ( ( attr & BLINK ) !== ( lastAttr & BLINK ) )\n\t\t{\n\t\t\tesc += attr & BLINK ? term.optimized.blink : term.optimized.noBlink ;\n\t\t}\n\t\t\n\t\tif ( ( attr & INVERSE ) !== ( lastAttr & INVERSE ) )\n\t\t{\n\t\t\tesc += attr & INVERSE ? term.optimized.inverse : term.optimized.noInverse ;\n\t\t}\n\t\t\n\t\tif ( ( attr & HIDDEN ) !== ( lastAttr & HIDDEN ) )\n\t\t{\n\t\t\tesc += attr & HIDDEN ? term.optimized.hidden : term.optimized.noHidden ;\n\t\t}\n\t\t\n\t\tif ( ( attr & STRIKE ) !== ( lastAttr & STRIKE ) )\n\t\t{\n\t\t\tesc += attr & STRIKE ? term.optimized.strike : term.optimized.noStrike ;\n\t\t}\n\t}\n\t\n\treturn esc ;\n} ;\n\n\n\n\n\n\t\t\t/* \"static\" functions: they exist in both static and non-static for backward compatibility */\n\n\n\nScreenBuffer.attr2object = function attr2object( attr )\n{\n\tvar object = {} ;\n\t\n\tobject.color = attr & 255 ;\n\tobject.bgColor = ( attr >>> 8 ) & 255 ;\n\t\n\t// Style part\n\tif ( attr & BOLD ) { object.bold = true ; }\n\tif ( attr & DIM ) { object.dim = true ; }\n\tif ( attr & ITALIC ) { object.italic = true ; }\n\tif ( attr & UNDERLINE ) { object.underline = true ; }\n\tif ( attr & BLINK ) { object.blink = true ; }\n\tif ( attr & INVERSE ) { object.inverse = true ; }\n\tif ( attr & HIDDEN ) { object.hidden = true ; }\n\tif ( attr & STRIKE ) { object.strike = true ; }\n\t\n\t// Blending part\n\tif ( attr & FG_TRANSPARENCY ) { object.fgTransparency = true ; }\n\tif ( attr & BG_TRANSPARENCY ) { object.bgTransparency = true ; }\n\tif ( attr & STYLE_TRANSPARENCY ) { object.styleTransparency = true ; }\n\tif ( attr & CHAR_TRANSPARENCY ) { object.charTransparency = true ; }\n\tif ( ( attr & TRANSPARENCY ) === TRANSPARENCY ) { object.transparency = true ; }\n\t\n\treturn object ;\n} ;\n\n\n\nScreenBuffer.prototype.attr2object = function attr2object( attr )\n{\n\tvar object = {} ;\n\t\n\tobject.color = attr & 255 ;\n\tobject.bgColor = ( attr >>> 8 ) & 255 ;\n\t\n\t// Style part\n\tif ( attr & BOLD ) { object.bold = true ; }\n\tif ( attr & DIM ) { object.dim = true ; }\n\tif ( attr & ITALIC ) { object.italic = true ; }\n\tif ( attr & UNDERLINE ) { object.underline = true ; }\n\tif ( attr & BLINK ) { object.blink = true ; }\n\tif ( attr & INVERSE ) { object.inverse = true ; }\n\tif ( attr & HIDDEN ) { object.hidden = true ; }\n\tif ( attr & STRIKE ) { object.strike = true ; }\n\t\n\t// Blending part\n\tif ( attr & FG_TRANSPARENCY ) { object.fgTransparency = true ; }\n\tif ( attr & BG_TRANSPARENCY ) { object.bgTransparency = true ; }\n\tif ( attr & STYLE_TRANSPARENCY ) { object.styleTransparency = true ; }\n\tif ( attr & CHAR_TRANSPARENCY ) { object.charTransparency = true ; }\n\tif ( ( attr & TRANSPARENCY ) === TRANSPARENCY ) { object.transparency = true ; }\n\t\n\treturn object ;\n} ;\n\n\n\nScreenBuffer.object2attr = function object2attr( object )\n{\n\tvar attr = 0 ;\n\t\n\tif ( ! object || typeof object !== 'object' ) { object = {} ; }\n\t\n\t// Color part\n\tif ( typeof object.color === 'string' ) { object.color = termkit.color2index( object.color ) ; }\n\tif ( typeof object.color !== 'number' || object.color < 0 || object.color > 255 ) { object.color = 7 ; }\n\telse { object.color = Math.floor( object.color ) ; }\n\t\n\tattr += object.color ;\n\t\n\t// Background color part\n\tif ( typeof object.bgColor === 'string' ) { object.bgColor = termkit.color2index( object.bgColor ) ; }\n\tif ( typeof object.bgColor !== 'number' || object.bgColor < 0 || object.bgColor > 255 ) { object.bgColor = 0 ; }\n\telse { object.bgColor = Math.floor( object.bgColor ) ; }\n\t\n\tattr += object.bgColor << 8 ;\n\t\n\t// Style part\n\tif ( object.bold ) { attr |= BOLD ; }\n\tif ( object.dim ) { attr |= DIM ; }\n\tif ( object.italic ) { attr |= ITALIC ; }\n\tif ( object.underline ) { attr |= UNDERLINE ; }\n\tif ( object.blink ) { attr |= BLINK ; }\n\tif ( object.inverse ) { attr |= INVERSE ; }\n\tif ( object.hidden ) { attr |= HIDDEN ; }\n\tif ( object.strike ) { attr |= STRIKE ; }\n\t\n\t// Blending part\n\tif ( object.transparency ) { attr |= TRANSPARENCY ; }\n\tif ( object.fgTransparency ) { attr |= FG_TRANSPARENCY ; }\n\tif ( object.bgTransparency ) { attr |= BG_TRANSPARENCY ; }\n\tif ( object.styleTransparency ) { attr |= STYLE_TRANSPARENCY ; }\n\tif ( object.charTransparency ) { attr |= CHAR_TRANSPARENCY ; }\n\t\n\treturn attr ;\n} ;\n\n\n\nScreenBuffer.prototype.object2attr = function object2attr( object )\n{\n\tvar attr = 0 ;\n\t\n\tif ( ! object || typeof object !== 'object' ) { object = {} ; }\n\t\n\t// Color part\n\tif ( typeof object.color === 'string' ) { object.color = termkit.color2index( object.color ) ; }\n\tif ( typeof object.color !== 'number' || object.color < 0 || object.color > 255 ) { object.color = 7 ; }\n\telse { object.color = Math.floor( object.color ) ; }\n\t\n\tattr += object.color ;\n\t\n\t// Background color part\n\tif ( typeof object.bgColor === 'string' ) { object.bgColor = termkit.color2index( object.bgColor ) ; }\n\tif ( typeof object.bgColor !== 'number' || object.bgColor < 0 || object.bgColor > 255 ) { object.bgColor = 0 ; }\n\telse { object.bgColor = Math.floor( object.bgColor ) ; }\n\t\n\tattr += object.bgColor << 8 ;\n\t\n\t// Style part\n\tif ( object.bold ) { attr |= BOLD ; }\n\tif ( object.dim ) { attr |= DIM ; }\n\tif ( object.italic ) { attr |= ITALIC ; }\n\tif ( object.underline ) { attr |= UNDERLINE ; }\n\tif ( object.blink ) { attr |= BLINK ; }\n\tif ( object.inverse ) { attr |= INVERSE ; }\n\tif ( object.hidden ) { attr |= HIDDEN ; }\n\tif ( object.strike ) { attr |= STRIKE ; }\n\t\n\t// Blending part\n\tif ( object.transparency ) { attr |= TRANSPARENCY ; }\n\tif ( object.fgTransparency ) { attr |= FG_TRANSPARENCY ; }\n\tif ( object.bgTransparency ) { attr |= BG_TRANSPARENCY ; }\n\tif ( object.styleTransparency ) { attr |= STYLE_TRANSPARENCY ; }\n\tif ( object.charTransparency ) { attr |= CHAR_TRANSPARENCY ; }\n\t\n\treturn attr ;\n} ;\n\n\n\n\n\n\t\t\t/* Terminal instance compatibility */\n\n\n\n// Clear the buffer: fill it with blank\n// Shared\nScreenBuffer.prototype.clear = ScreenBuffer.prototype.fill ;\n\n\n\n\n\n\t\t\t/* Constants */\n\n\n\n// General purpose flags\nconst NONE = 0 ;\t// Nothing\n\n// Style mask and flags\nconst STYLE_MASK = 255 << 16 ;\n\nconst BOLD = 1 << 16 ;\nconst DIM = 2 << 16 ;\nconst ITALIC = 4 << 16 ;\nconst UNDERLINE = 8 << 16 ;\nconst BLINK = 16 << 16 ;\nconst INVERSE = 32 << 16 ;\nconst HIDDEN = 64 << 16 ;\nconst STRIKE = 128 << 16 ;\n\nconst BOLD_DIM = BOLD | DIM ;\n\n// Blending flags, mask and misc flags\nconst FG_TRANSPARENCY = 1 << 24 ;\nconst BG_TRANSPARENCY = 2 << 24 ;\nconst STYLE_TRANSPARENCY = 4 << 24 ;\nconst CHAR_TRANSPARENCY = 8 << 24 ;\nconst TRANSPARENCY = FG_TRANSPARENCY | BG_TRANSPARENCY | STYLE_TRANSPARENCY | CHAR_TRANSPARENCY ;\n\nconst LEADING_FULLWIDTH = 64 << 24 ;\nconst TRAILING_FULLWIDTH = 128 << 24 ;\n\n// Unused bits: 16 and 32\n\n\n\n// Tuning\nconst OUTPUT_THRESHOLD = 10000 ;\t// minimum amount of data to retain before sending them to the terminal\n\n// DEPRECATED version 1 of ScreenBuffer file format\nconst HEADER_SIZE = 40 ;\t// Header consists of 40 bytes\n\n\n\n// Data structure\nScreenBuffer.prototype.ATTR_SIZE = 4 ;\t// do not edit, everything use Buffer.writeInt32BE()\nScreenBuffer.prototype.CHAR_SIZE = 4 ;\nScreenBuffer.prototype.ITEM_SIZE = ScreenBuffer.prototype.ATTR_SIZE + ScreenBuffer.prototype.CHAR_SIZE ;\n\nScreenBuffer.prototype.DEFAULT_ATTR = ScreenBuffer.object2attr( { color: 'white' , bgColor: 'black' } ) ;\nScreenBuffer.prototype.CLEAR_ATTR = ScreenBuffer.object2attr( { color: 'white' , bgColor: 'black' , transparency: true } ) ;\nScreenBuffer.prototype.CLEAR_BUFFER = Buffer.allocUnsafe( ScreenBuffer.prototype.ITEM_SIZE ) ;\nScreenBuffer.prototype.CLEAR_BUFFER.writeInt32BE( ScreenBuffer.prototype.DEFAULT_ATTR , 0 ) ;\nScreenBuffer.prototype.CLEAR_BUFFER.write( ' \\x00\\x00\\x00' , ScreenBuffer.prototype.ATTR_SIZE ) ;\t// space\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/ScreenBufferHD.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\n//var tree = require( 'tree-kit' ) ;\n//var async = require( 'async-kit' ) ;\n\n//var events = require( 'events' ) ;\nvar NextGenEvents = require( 'nextgen-events' ) ;\nvar fs = require( 'fs' ) ;\nvar string = require( 'string-kit' ) ;\nvar punycode = require( 'punycode' ) ;\n\n\n\nfunction ScreenBufferHD() { throw new Error( 'Cannot create ScreenBufferHD object directly.' ) ; }\nmodule.exports = ScreenBufferHD ;\n\n\n\nvar termkit = require( './termkit.js' ) ;\n\n\n\nScreenBufferHD.prototype = Object.create( termkit.ScreenBuffer.prototype ) ;\nScreenBufferHD.prototype.constructor = ScreenBufferHD ;\nScreenBufferHD.prototype.bitsPerColor = 24 ;\n\n\n\n/*\n\toptions:\n\t\t* width: buffer width (default to dst.width)\n\t\t* height: buffer height (default to dst.height)\n\t\t* dst: writting destination\n\t\t* x: default position in the dst\n\t\t* y: default position in the dst\n\t\t* wrap: default wrapping behavior of .put()\n\t\t* noFill: do not call .fill() with default values at ScreenBuffer creation\n\t\t* blending: false/null or true or object (blending options): default blending params (can be overriden by .draw())\n*/\nScreenBufferHD.create = function create( options )\n{\n\t// Manage options\n\tif ( ! options ) { options = {} ; }\n\t\n\tvar self = Object.create( ScreenBufferHD.prototype , {\n\t\t// a terminal or another screenBuffer\n\t\tdst: { value: options.dst , writable: true , enumerable: true } ,\n\t\twidth: { enumerable: true , configurable: true ,\n\t\t\tvalue: Math.floor( options.width ) || ( options.dst ? options.dst.width : 1 )\n\t\t} ,\n\t\theight: { enumerable: true , configurable: true ,\n\t\t\tvalue: Math.floor( options.height ) || ( options.dst ? options.dst.height : 1 )\n\t\t} ,\n\t\tx: { writable: true , enumerable: true , value:\n\t\t\toptions.x !== undefined ? options.x : ( options.dst && options.dst instanceof termkit.Terminal ? 1 : 0 )\n\t\t} ,\n\t\ty: { writable: true , enumerable: true , value:\n\t\t\toptions.y !== undefined ? options.y : ( options.dst && options.dst instanceof termkit.Terminal ? 1 : 0 )\n\t\t} ,\n\t\tcx: { value: 0 , writable: true , enumerable: true } ,\n\t\tcy: { value: 0 , writable: true , enumerable: true } ,\n\t\tblending: { value: options.blending || false , writable: true , enumerable: true } ,\n\t\twrap: { value: !! options.wrap , writable: true , enumerable: true }\n\t} ) ;\n\t\n\tObject.defineProperties( self , {\n\t\tbuffer: { enumerable: true , configurable: true ,\n\t\t\tvalue: Buffer.allocUnsafe( self.width * self.height * self.ITEM_SIZE ) \n\t\t}\n\t} ) ;\n\t\n\tif ( ! options.noFill ) { self.fill() ; }\n\t\n\treturn self ;\n} ;\n\n\n\n/*\n\toptions:\n\t\t* attr: attributes passed to .put()\n\t\t* transparencyChar: a char that is transparent\n\t\t* transparencyType: bit flags for the transparency char\n*/\nScreenBufferHD.createFromString = function createFromString( options , data )\n{\n\tvar x , y , len , attr , attrTrans , width , height , self ;\n\t\n\t// Manage options\n\tif ( ! options ) { options = {} ; }\n\t\n\tif ( typeof data !== 'string' )\n\t{\n\t\tif ( ! data.toString ) { throw new Error( '[terminal] ScreenBufferHD.createFromDataString(): argument #1 should be a string or provide a .toString() method.' ) ; }\n\t\tdata = data.toString() ;\n\t}\n\t\n\t// Transform the data into an array of lines\n\tdata = termkit.stripControlChars( data , true ).split( '\\n' ) ;\n\t\n\t// Compute the buffer size\n\twidth = 0 ;\n\theight = data.length ;\n\t\n\tattr = options.attr !== undefined ? options.attr : ScreenBufferHD.prototype.DEFAULT_ATTR ;\n\tif ( attr && typeof attr === 'object' && ! attr.BYTES_PER_ELEMENT ) { attr = ScreenBufferHD.object2attr( attr ) ; }\n\t\n\tattrTrans = attr ;\n\t\n\tif ( options.transparencyChar )\n\t{\n\t\tif ( ! options.transparencyType ) { attrTrans |= ScreenBufferHD.prototype.TRANSPARENCY ; }\n\t\telse { attrTrans |= options.transparencyType & ScreenBufferHD.prototype.TRANSPARENCY ; }\n\t}\n\t\n\t// Compute the width of the screenBuffer\n\tfor ( y = 0 ; y < data.length ; y ++ )\n\t{\n\t\tif ( data[ y ].length > width ) { width = data[ y ].length ; }\n\t}\n\t\n\t// Create the buffer with the right width & height\n\tself = ScreenBufferHD.create( { width: width , height: height } ) ;\n\t\n\t// Fill the buffer with data\n\tfor ( y = 0 ; y < data.length ; y ++ )\n\t{\n\t\tif ( ! options.transparencyChar )\n\t\t{\n\t\t\tself.put( { x: 0 , y: y , attr: attr } , data[ y ] ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlen = data[ y ].length ;\n\t\t\t\n\t\t\tfor ( x = 0 ; x < len ; x ++ )\n\t\t\t{\n\t\t\t\tif ( data[ y ][ x ] === options.transparencyChar )\n\t\t\t\t{\n\t\t\t\t\tself.put( { x: x , y: y , attr: attrTrans } , data[ y ][ x ] ) ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tself.put( { x: x , y: y , attr: attr } , data[ y ][ x ] ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn self ;\n} ;\n\n\n\n// Backward compatibility\nScreenBufferHD.createFromChars = ScreenBufferHD.createFromString ;\n\n\n\nScreenBufferHD.prototype.blitterCellBlendingIterator = function blitterCellBlendingIterator( p )\n{\n\tvar attr = this.readAttr( p.context.srcBuffer , p.srcStart ) ;\n\t\n\tvar blendFn = ScreenBufferHD.blendFn.normal ;\n\tvar opacity = 1 ;\n\tvar blendSrcFgWithDstBg = false ;\n\t\n\tif ( typeof p.context.blending === 'object' )\n\t{\n\t\tif ( p.context.blending.fn ) { blendFn = p.context.blending.fn ; }\n\t\tif ( p.context.blending.opacity !== undefined ) { opacity = p.context.blending.opacity ; }\n\t\tif ( p.context.blending.blendSrcFgWithDstBg ) { blendSrcFgWithDstBg = true ; }\n\t}\n\t\n\tif (\n\t\t! ( attr[ BPOS_BLENDING ] & STYLE_TRANSPARENCY ) &&\n\t\t! ( attr[ BPOS_BLENDING ] & CHAR_TRANSPARENCY ) &&\n\t\tattr[ BPOS_A ] === 255 && attr[ BPOS_BG_A ] === 255 && opacity === 1 &&\n\t\tblendFn === ScreenBufferHD.blendFn.normal\n\t)\n\t{\n\t\t// Fully opaque, copy it\n\t\tp.context.srcBuffer.copy( p.context.dstBuffer , p.dstStart , p.srcStart , p.srcEnd ) ;\n\t\treturn ;\n\t}\n\t\n\tif (\n\t\t( attr[ BPOS_BLENDING ] & STYLE_TRANSPARENCY ) &&\n\t\t( attr[ BPOS_BLENDING ] & CHAR_TRANSPARENCY ) &&\n\t\t( ! opacity || ( attr[ BPOS_A ] === 0 && attr[ BPOS_BG_A ] === 0 ) )\n\t)\n\t{\n\t\t// Fully transparent, do nothing\n\t\treturn ;\n\t}\n\t\n\t// Blending part...\n\t\n\tvar alpha ;\t// Normalized alpha\n\t\n\tif ( attr[ BPOS_A ] )\n\t{\n\t\talpha = opacity * attr[ BPOS_A ] / 255 ;\n\t\t\n\t\tif ( blendSrcFgWithDstBg )\n\t\t{\n\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_R ] = alphaBlend(\n\t\t\t\tp.context.srcBuffer[ p.srcStart + BPOS_R ] ,\n\t\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_BG_R ] ,\n\t\t\t\talpha ,\n\t\t\t\tblendFn\n\t\t\t) ;\n\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_G ] = alphaBlend(\n\t\t\t\tp.context.srcBuffer[ p.srcStart + BPOS_G ] ,\n\t\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_BG_G ] ,\n\t\t\t\talpha ,\n\t\t\t\tblendFn\n\t\t\t) ;\n\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_B ] = alphaBlend(\n\t\t\t\tp.context.srcBuffer[ p.srcStart + BPOS_B ] ,\n\t\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_BG_B ] ,\n\t\t\t\talpha ,\n\t\t\t\tblendFn\n\t\t\t) ;\n\t\t\t// Blending alpha is special\n\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_A ] = alphaBlend(\n\t\t\t\tp.context.srcBuffer[ p.srcStart + BPOS_A ] ,\n\t\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_BG_A ] ,\n\t\t\t\topacity ,\n\t\t\t\tScreenBufferHD.blendFn.screen\n\t\t\t) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_R ] = alphaBlend(\n\t\t\t\tp.context.srcBuffer[ p.srcStart + BPOS_R ] ,\n\t\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_R ] ,\n\t\t\t\talpha ,\n\t\t\t\tblendFn\n\t\t\t) ;\n\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_G ] = alphaBlend(\n\t\t\t\tp.context.srcBuffer[ p.srcStart + BPOS_G ] ,\n\t\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_G ] ,\n\t\t\t\talpha ,\n\t\t\t\tblendFn\n\t\t\t) ;\n\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_B ] = alphaBlend(\n\t\t\t\tp.context.srcBuffer[ p.srcStart + BPOS_B ] ,\n\t\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_B ] ,\n\t\t\t\talpha ,\n\t\t\t\tblendFn\n\t\t\t) ;\n\t\t\t// Blending alpha is special\n\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_A ] = alphaBlend(\n\t\t\t\tp.context.srcBuffer[ p.srcStart + BPOS_A ] ,\n\t\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_A ] ,\n\t\t\t\topacity ,\n\t\t\t\tScreenBufferHD.blendFn.screen\n\t\t\t) ;\n\t\t}\n\t}\n\t\n\tif ( attr[ BPOS_BG_A ] )\n\t{\n\t\talpha = opacity * attr[ BPOS_BG_A ] / 255 ;\n\t\t\n\t\tp.context.dstBuffer[ p.dstStart + BPOS_BG_R ] = alphaBlend(\n\t\t\tp.context.srcBuffer[ p.srcStart + BPOS_BG_R ] ,\n\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_BG_R ] ,\n\t\t\talpha ,\n\t\t\tblendFn\n\t\t) ;\n\t\tp.context.dstBuffer[ p.dstStart + BPOS_BG_G ] = alphaBlend(\n\t\t\tp.context.srcBuffer[ p.srcStart + BPOS_BG_G ] ,\n\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_BG_G ] ,\n\t\t\talpha ,\n\t\t\tblendFn\n\t\t) ;\n\t\tp.context.dstBuffer[ p.dstStart + BPOS_BG_B ] = alphaBlend(\n\t\t\tp.context.srcBuffer[ p.srcStart + BPOS_BG_B ] ,\n\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_BG_B ] ,\n\t\t\talpha ,\n\t\t\tblendFn\n\t\t) ;\n\t\t// Blending alpha is special\n\t\tp.context.dstBuffer[ p.dstStart + BPOS_BG_A ] = alphaBlend(\n\t\t\tp.context.srcBuffer[ p.srcStart + BPOS_BG_A ] ,\n\t\t\tp.context.dstBuffer[ p.dstStart + BPOS_BG_A ] ,\n\t\t\topacity ,\n\t\t\tScreenBufferHD.blendFn.screen\n\t\t) ;\n\t}\n\t\n\tif ( ! ( attr[ BPOS_BLENDING ] & STYLE_TRANSPARENCY ) )\n\t{\n\t\tp.context.dstBuffer[ p.dstStart + BPOS_STYLE ] =\n\t\t\tp.context.srcBuffer[ p.srcStart + BPOS_STYLE ] ;\n\t}\n\t\n\tif ( ! ( attr[ BPOS_BLENDING ] & CHAR_TRANSPARENCY ) )\n\t{\n\t\t// Copy source character\n\t\tp.context.srcBuffer.copy(\n\t\t\tp.context.dstBuffer ,\n\t\t\tp.dstStart + this.ATTR_SIZE ,\n\t\t\tp.srcStart + this.ATTR_SIZE ,\n\t\t\tp.srcEnd\n\t\t) ;\n\t}\n} ;\n\n\n\nfunction alphaBlend( src , dest , alpha , fn )\n{\n\treturn Math.round( fn( src , dest ) * alpha + dest * ( 1 - alpha ) ) ;\n}\n\n\n\n// https://en.wikipedia.org/wiki/Blend_modes\nScreenBufferHD.blendFn = {\n\tnormal: src => src ,\n\tmultiply: ( src , dst ) => 255 * ( ( src / 255 ) * ( dst / 255 ) ) ,\n\tscreen: ( src , dst ) => 255 * ( 1 - ( 1 - src / 255 ) * ( 1 - dst / 255 ) ) ,\n\toverlay: ( src , dst ) => dst <= 127 ?\n\t\t255 * ( 2 * ( src / 255 ) * ( dst / 255 ) ) :\n\t\t255 * ( 1 - 2 * ( 1 - src / 255 ) * ( 1 - dst / 255 ) ) ,\n\thardLight: ( src , dst ) => src <= 127 ?\n\t\t255 * ( 2 * ( src / 255 ) * ( dst / 255 ) ) :\n\t\t255 * ( 1 - 2 * ( 1 - src / 255 ) * ( 1 - dst / 255 ) ) ,\n\tsoftLight: ( src , dst ) => {\n\t\tsrc /= 255 ;\n\t\tdst /= 255 ;\n\t\treturn 255 * (  ( 1 - 2 * src ) * dst * dst + 2 * src * dst  ) ;\n\t}\n} ;\n\n\n\nScreenBufferHD.prototype.terminalBlitterLineIterator = function terminalBlitterLineIterator( p )\n{\n\tvar offset , attr ;\n\t\n\tp.context.sequence += p.context.term.optimized.moveTo( p.dstXmin , p.dstY ) ;\n\tp.context.moves ++ ;\n\t\n\tfor ( offset = p.srcStart ; offset < p.srcEnd ; offset += this.ITEM_SIZE )\n\t{\n\t\tattr = this.readAttr( p.context.srcBuffer , offset ) ;\n\t\t\n\t\tif ( ! p.context.lastAttr || ! attr.equals( p.context.lastAttr ) )\n\t\t{\n\t\t\tp.context.sequence += ! p.context.lastAttr || ! p.context.deltaEscapeSequence ?\n\t\t\t\tthis.generateEscapeSequence( p.context.term , attr ) :\n\t\t\t\tthis.generateDeltaEscapeSequence( p.context.term , attr , p.context.lastAttr ) ;\n\t\t\tp.context.lastAttr = attr ;\n\t\t\tp.context.attrs ++ ;\n\t\t}\n\t\t\n\t\tp.context.sequence += this.readChar( p.context.srcBuffer , offset ) ;\n\t\tp.context.cells ++ ;\n\t}\n\t\n\t// Output buffering saves a good amount of CPU usage both for the node's processus and the terminal processus\n\tif ( p.context.sequence.length > OUTPUT_THRESHOLD )\n\t{\n\t\tp.context.nfterm( p.context.sequence ) ;\n\t\tp.context.sequence = '' ;\n\t\tp.context.writes ++ ;\n\t}\n} ;\n\n\n\nScreenBufferHD.prototype.terminalBlitterCellIterator = function terminalBlitterCellIterator( p )\n{\n\t//var attr = p.context.srcBuffer.readUInt32BE( p.srcStart ) ;\n\tvar attr = this.readAttr( p.context.srcBuffer , p.srcStart ) ;\n\t\n\t// If last buffer's cell === current buffer's cell, no need to refresh... skip that now\n\tif ( p.context.srcLastBuffer )\n\t{\n\t\tif (\n\t\t\tattr.equals( this.readAttr( p.context.srcLastBuffer , p.srcStart ) ) &&\n\t\t\tthis.readChar( p.context.srcBuffer , p.srcStart ) === this.readChar( p.context.srcLastBuffer , p.srcStart ) )\n\t\t{\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tp.context.srcBuffer.copy( p.context.srcLastBuffer , p.srcStart , p.srcStart , p.srcEnd ) ;\n\t}\n\t\n\tp.context.cells ++ ;\n\t\n\tif ( p.dstX !== p.context.cx || p.dstY !== p.context.cy )\n\t{\n\t\tp.context.sequence += p.context.term.optimized.moveTo( p.dstX , p.dstY ) ;\n\t\tp.context.moves ++ ;\n\t}\n\t\n\tif ( ! p.context.lastAttr || ! attr.equals( p.context.lastAttr ) )\n\t{\n\t\tp.context.sequence += ! p.context.lastAttr || ! p.context.deltaEscapeSequence ?\n\t\t\tthis.generateEscapeSequence( p.context.term , attr ) :\n\t\t\tthis.generateDeltaEscapeSequence( p.context.term , attr , p.context.lastAttr ) ;\n\t\tp.context.lastAttr = attr ;\n\t\tp.context.attrs ++ ;\n\t}\n\t\n\tp.context.sequence += this.readChar( p.context.srcBuffer , p.srcStart ) ;\n\t\n\t// Output buffering saves a good amount of CPU usage both for the node's processus and the terminal processus\n\tif ( p.context.sequence.length > OUTPUT_THRESHOLD )\n\t{\n\t\tp.context.nfterm( p.context.sequence ) ;\n\t\tp.context.sequence = '' ;\n\t\tp.context.writes ++ ;\n\t}\n\t\n\t// Next expected cursor position\n\tp.context.cx = p.dstX + 1 ;\n\tp.context.cy = p.dstY ;\n} ;\n\n\n\nScreenBufferHD.loadSyncV2 = function loadSync( filepath )\n{\n\tvar i , content , header , screenBuffer ;\n\t\n\t// Let it crash if nothing found\n\tcontent = fs.readFileSync( filepath ) ;\n\t\n\t// See if we have got a 'SB' at the begining of the file\n\tif ( content.length < 3 || content.toString( 'ascii' , 0 , 3 ) !== 'SB\\n' )\n\t{\n\t\tthrow new Error( 'Magic number mismatch: this is not a ScreenBufferHD file' ) ;\n\t}\n\t\n\t// search for the second \\n\n\tfor ( i = 3 ; i < content.length ; i ++ )\n\t{\n\t\tif ( content[ i ] === 0x0a ) { break ; }\n\t}\n\t\n\tif ( i === content.length )\n\t{\n\t\tthrow new Error( 'No header found: this is not a ScreenBufferHD file' ) ;\n\t}\n\t\n\t// Try to parse a JSON header\n\ttry {\n\t\theader = JSON.parse( content.toString( 'utf8' , 3 , i ) ) ;\n\t}\n\tcatch( error ) {\n\t\tthrow new Error( 'No correct one-lined JSON header found: this is not a ScreenBufferHD file' ) ;\n\t}\n\t\n\t// Mandatory header field\n\tif ( header.version === undefined || header.width === undefined || header.height === undefined )\n\t{\n\t\tthrow new Error( 'Missing mandatory header data, this is a corrupted or obsolete ScreenBufferHD file' ) ;\n\t}\n\t\n\t// Check bitsPerColor\n\tif ( header.bitsPerColor && header.bitsPerColor !== ScreenBufferHD.prototype.bitsPerColor )\n\t{\n\t\tthrow new Error( 'Bad Bits Per Color: ' + header.bitsPerColor + ' (should be ' + ScreenBufferHD.prototype.bitsPerColor + ')' ) ;\n\t}\n\t\n\t// Bad size?\n\tif ( content.length !== i + 1 + header.width * header.height * ScreenBufferHD.prototype.ITEM_SIZE )\n\t{\n\t\tthrow new Error( 'Bad file size: this is a corrupted ScreenBufferHD file' ) ;\n\t}\n\t\n\t// So the file exists, create a canvas based upon it\n\tscreenBuffer = ScreenBufferHD.create( {\n\t\twidth: header.width ,\n\t\theight: header.height\n\t} ) ;\n\t\n\tcontent.copy( screenBuffer.buffer , 0 , i + 1 ) ;\n\t\n\treturn screenBuffer ;\n} ;\n\n\n\n// This new format use JSON header for a maximal flexibility rather than a fixed binary header.\n// The header start with a magic number SB\\n then a compact single-line JSON that end with an \\n.\n// So the data part start after the second \\n, providing a variable header size.\n// This will allow adding meta data without actually changing the file format.\nScreenBufferHD.prototype.saveSyncV2 = function saveSync( filepath )\n{\n\tvar content , header ;\n\t\n\theader = {\n\t\tversion: 2 ,\n\t\twidth: this.width ,\n\t\theight: this.height\n\t} ;\n\t\n\theader = 'SB\\n' + JSON.stringify( header ) + '\\n' ;\n\t\n\tcontent = Buffer.allocUnsafe( header.length + this.buffer.length ) ;\n\tcontent.write( header ) ;\n\t\n\tthis.buffer.copy( content , header.length ) ;\n\t\n\t// Let it crash if something bad happens\n\tfs.writeFileSync( filepath , content ) ;\n} ;\n\n\n\nScreenBufferHD.loadSync = ScreenBufferHD.loadSyncV2 ;\nScreenBufferHD.prototype.saveSync = ScreenBufferHD.prototype.saveSyncV2 ;\n\n\n\nScreenBufferHD.fromNdarrayImage = function fromNdarrayImage( pixels , options )\n{\n\tvar x , xMax = pixels.shape[ 0 ] ,\n\t\ty , yMax = Math.ceil( pixels.shape[ 1 ] / 2 ) ,\n\t\thasAlpha = pixels.shape[ 2 ] === 4 ;\n\t\n\tvar image = termkit.ScreenBufferHD.create( { width: xMax , height: yMax , blending: true , noFill: true } ) ;\n\t\n\tfor ( x = 0 ; x < xMax ; x ++ )\n\t{\n\t\tfor ( y = 0 ; y < yMax ; y ++ )\n\t\t{\n\t\t\tif ( y * 2 + 1 < pixels.shape[ 1 ] )\n\t\t\t{\n\t\t\t\timage.put(\n\t\t\t\t\t{\n\t\t\t\t\t\tx: x ,\n\t\t\t\t\t\ty: y ,\n\t\t\t\t\t\tattr: {\n\t\t\t\t\t\t\tr: pixels.get( x , y * 2 , 0 ) ,\n\t\t\t\t\t\t\tg: pixels.get( x , y * 2 , 1 ) ,\n\t\t\t\t\t\t\tb: pixels.get( x , y * 2 , 2 ) ,\n\t\t\t\t\t\t\ta: hasAlpha ? pixels.get( x , y * 2 , 3 ) : 255 ,\n\t\t\t\t\t\t\tbgR: pixels.get( x , y * 2 + 1 , 0 ) ,\n\t\t\t\t\t\t\tbgG: pixels.get( x , y * 2 + 1 , 1 ) ,\n\t\t\t\t\t\t\tbgB: pixels.get( x , y * 2 + 1 , 2 ) ,\n\t\t\t\t\t\t\tbgA: hasAlpha ? pixels.get( x , y * 2 + 1 , 3 ) : 255\n\t\t\t\t\t\t}\n\t\t\t\t\t} ,\n\t\t\t\t\t'▀'\n\t\t\t\t) ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\timage.put(\n\t\t\t\t\t{\n\t\t\t\t\t\tx: x ,\n\t\t\t\t\t\ty: y ,\n\t\t\t\t\t\tattr: {\n\t\t\t\t\t\t\tr: pixels.get( x , y * 2 , 0 ) ,\n\t\t\t\t\t\t\tg: pixels.get( x , y * 2 , 1 ) ,\n\t\t\t\t\t\t\tb: pixels.get( x , y * 2 , 2 ) ,\n\t\t\t\t\t\t\ta: hasAlpha ? pixels.get( x , y * 2 , 3 ) : 255 ,\n\t\t\t\t\t\t\tbgR: 0 , bgG: 0 , bgB: 0 , bgA: 0\n\t\t\t\t\t\t}\n\t\t\t\t\t} ,\n\t\t\t\t\t'▀'\n\t\t\t\t) ;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn image ;\n} ;\n\n\n\nScreenBufferHD.loadImage = termkit.image.load.bind( ScreenBufferHD , ScreenBufferHD.fromNdarrayImage ) ;\n\n\n\nScreenBufferHD.prototype.dump = function dump()\n{\n\tvar y , x , offset , str = '' ;\n\t\n\tfor ( y = 0 ; y < this.height ; y ++ )\n\t{\n\t\tfor ( x = 0 ; x < this.width ; x ++ )\n\t\t{\n\t\t\toffset = ( y * this.width + x ) * this.ITEM_SIZE ;\n\t\t\t\n\t\t\tstr += string.format( '%x%x%x%x %x%x%x%x %x%x ' ,\n\t\t\t\tthis.buffer.readUInt8( offset ) ,\n\t\t\t\tthis.buffer.readUInt8( offset + 1 ) ,\n\t\t\t\tthis.buffer.readUInt8( offset + 2 ) ,\n\t\t\t\tthis.buffer.readUInt8( offset + 3 ) ,\n\t\t\t\tthis.buffer.readUInt8( offset + 4 ) ,\n\t\t\t\tthis.buffer.readUInt8( offset + 5 ) ,\n\t\t\t\tthis.buffer.readUInt8( offset + 6 ) ,\n\t\t\t\tthis.buffer.readUInt8( offset + 7 ) ,\n\t\t\t\tthis.buffer.readUInt8( offset + 8 ) ,\n\t\t\t\tthis.buffer.readUInt8( offset + 9 )\n\t\t\t) ;\n\t\t\t\n\t\t\tstr += this.readChar( this.buffer , offset ) + '  ' ;\n\t\t}\n\t\t\n\t\tstr += '\\n' ;\n\t}\n\t\n\treturn str ;\n} ;\n\n\n\nScreenBufferHD.prototype.readAttr = function readAttr( buffer , at )\n{\n\treturn buffer.slice( at , at + this.ATTR_SIZE ) ;\n} ;\n\n\n\nScreenBufferHD.prototype.writeAttr = function writeAttr( buffer , attr , at )\n{\n\treturn attr.copy( buffer , at ) ;\n} ;\n\n\n\nScreenBufferHD.prototype.readChar = function readChar( buffer , at )\n{\n\tvar bytes ;\n\t\n\tat += this.ATTR_SIZE ;\n\t\n\tif ( buffer[ at ] < 0x80 ) { bytes = 1 ; }\n\telse if ( buffer[ at ] < 0xc0 ) { return '\\x00' ; } // We are in a middle of an unicode multibyte sequence... something was wrong...\n\telse if ( buffer[ at ] < 0xe0 ) { bytes = 2 ; }\n\telse if ( buffer[ at ] < 0xf0 ) { bytes = 3 ; }\n\telse if ( buffer[ at ] < 0xf8 ) { bytes = 4 ; }\n\telse if ( buffer[ at ] < 0xfc ) { bytes = 5 ; }\n\telse { bytes = 6 ; }\n\t\n\tif ( bytes > this.CHAR_SIZE ) { return '\\x00' ; }\n\t\n\treturn buffer.toString( 'utf8' , at , at + bytes ) ;\n} ;\n\n\n\nScreenBufferHD.prototype.writeChar = function writeChar( buffer , char , at )\n{\n\treturn buffer.write( char , at + this.ATTR_SIZE , this.CHAR_SIZE ) ;\n} ;\n\n\n\nScreenBufferHD.prototype.generateEscapeSequence = function generateEscapeSequence( term , attr )\n{\n\tvar esc = term.optimized.styleReset +\n\t\tterm.optimized.color24bits( attr[ BPOS_R ] , attr[ BPOS_G ] , attr[ BPOS_B ] ) +\n\t\tterm.optimized.bgColor24bits( attr[ BPOS_BG_R ] , attr[ BPOS_BG_G ] , attr[ BPOS_BG_B ] ) ;\n\t\n\tvar style = attr[ BPOS_STYLE ] ;\n\t\n\t// Style part\n\tif ( style & BOLD ) { esc += term.optimized.bold ; }\n\tif ( style & DIM ) { esc += term.optimized.dim ; }\n\tif ( style & ITALIC ) { esc += term.optimized.italic ; }\n\tif ( style & UNDERLINE ) { esc += term.optimized.underline ; }\n\tif ( style & BLINK ) { esc += term.optimized.blink ; }\n\tif ( style & INVERSE ) { esc += term.optimized.inverse ; }\n\tif ( style & HIDDEN ) { esc += term.optimized.hidden ; }\n\tif ( style & STRIKE ) { esc += term.optimized.strike ; }\n\t\n\treturn esc ;\n} ;\n\n\n\n// Generate only the delta between the last and new attributes, may speed up things for the terminal process\n// as well as consume less bandwidth, at the cost of small CPU increase in the application process\nScreenBufferHD.prototype.generateDeltaEscapeSequence = function generateDeltaEscapeSequence( term , attr , lastAttr )\n{\n\t//console.log( 'generateDeltaEscapeSequence' , attr , lastAttr ) ;\n\t\n\tvar esc = '' ;\n\t\n\t// Color\n\tif (\n\t\tattr[ BPOS_R ] !== lastAttr[ BPOS_R ] ||\n\t\tattr[ BPOS_G ] !== lastAttr[ BPOS_G ] ||\n\t\tattr[ BPOS_B ] !== lastAttr[ BPOS_B ]\n\t)\n\t{\n\t\tesc += term.optimized.color24bits( attr[ BPOS_R ] , attr[ BPOS_G ] , attr[ BPOS_B ] ) ;\n\t}\n\t\n\t// Bg color\n\tif (\n\t\tattr[ BPOS_BG_R ] !== lastAttr[ BPOS_BG_R ] ||\n\t\tattr[ BPOS_BG_G ] !== lastAttr[ BPOS_BG_G ] ||\n\t\tattr[ BPOS_BG_B ] !== lastAttr[ BPOS_BG_B ]\n\t)\n\t{\n\t\tesc += term.optimized.bgColor24bits( attr[ BPOS_BG_R ] , attr[ BPOS_BG_G ] , attr[ BPOS_BG_B ] ) ;\n\t}\n\t\n\t\n\tvar style = attr[ BPOS_STYLE ] ;\n\tvar lastStyle = lastAttr[ BPOS_STYLE ] ;\n\t\n\tif ( style !== lastStyle )\n\t{\n\t\t// Bold and dim style are particular: all terminal has noBold = noDim\n\t\t\n\t\tif ( ( style & BOLD_DIM ) !== ( lastStyle & BOLD_DIM ) )\n\t\t{\n\t\t\tif ( ( ( lastStyle & BOLD ) && ! ( style & BOLD ) ) ||\n\t\t\t\t( ( lastStyle & DIM ) && ! ( style & DIM ) ) )\n\t\t\t{\n\t\t\t\tesc += term.optimized.noBold ;\n\t\t\t\tif ( style & BOLD ) { esc += term.optimized.bold ; }\n\t\t\t\tif ( style & DIM ) { esc += term.optimized.dim ; }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ( ( style & BOLD ) && ! ( lastStyle & BOLD ) ) { esc += term.optimized.bold ; }\n\t\t\t\tif ( ( style & DIM ) && ! ( lastStyle & DIM ) ) { esc += term.optimized.dim ; }\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ( ( style & ITALIC ) !== ( lastStyle & ITALIC ) )\n\t\t{\n\t\t\tesc += style & ITALIC ? term.optimized.italic : term.optimized.noItalic ;\n\t\t}\n\t\t\n\t\tif ( ( style & UNDERLINE ) !== ( lastStyle & UNDERLINE ) )\n\t\t{\n\t\t\tesc += style & UNDERLINE ? term.optimized.underline : term.optimized.noUnderline ;\n\t\t}\n\t\t\n\t\tif ( ( style & BLINK ) !== ( lastStyle & BLINK ) )\n\t\t{\n\t\t\tesc += style & BLINK ? term.optimized.blink : term.optimized.noBlink ;\n\t\t}\n\t\t\n\t\tif ( ( style & INVERSE ) !== ( lastStyle & INVERSE ) )\n\t\t{\n\t\t\tesc += style & INVERSE ? term.optimized.inverse : term.optimized.noInverse ;\n\t\t}\n\t\t\n\t\tif ( ( style & HIDDEN ) !== ( lastStyle & HIDDEN ) )\n\t\t{\n\t\t\tesc += style & HIDDEN ? term.optimized.hidden : term.optimized.noHidden ;\n\t\t}\n\t\t\n\t\tif ( ( style & STRIKE ) !== ( lastStyle & STRIKE ) )\n\t\t{\n\t\t\tesc += style & STRIKE ? term.optimized.strike : term.optimized.noStrike ;\n\t\t}\n\t}\n\t\n\treturn esc ;\n} ;\n\n\n\n\n\n\t\t\t/* \"static\" functions: they exist in both static and non-static for backward compatibility */\n\n\n\nScreenBufferHD.attr2object = function attr2object( attr )\n{\n\tvar object = {} ;\n\t\n\t// Color part\n\tobject.r = attr[ BPOS_R ] ;\n\tobject.g = attr[ BPOS_G ] ;\n\tobject.b = attr[ BPOS_B ] ;\n\tobject.a = attr[ BPOS_A ] ;\n\t\n\t// Background color part\n\tobject.bgR = attr[ BPOS_BG_R ] ;\n\tobject.bgG = attr[ BPOS_BG_G ] ;\n\tobject.bgB = attr[ BPOS_BG_B ] ;\n\tobject.bgA = attr[ BPOS_BG_A ] ;\n\t\n\t// Style part\n\tobject.bold = !! ( attr[ BPOS_STYLE ] & BOLD ) ;\n\tobject.dim = !! ( attr[ BPOS_STYLE ] & DIM ) ;\n\tobject.italic = !! ( attr[ BPOS_STYLE ] & ITALIC ) ;\n\tobject.underline = !! ( attr[ BPOS_STYLE ] & UNDERLINE ) ;\n\tobject.blink = !! ( attr[ BPOS_STYLE ] & BLINK ) ;\n\tobject.inverse = !! ( attr[ BPOS_STYLE ] & INVERSE ) ;\n\tobject.hidden = !! ( attr[ BPOS_STYLE ] & HIDDEN ) ;\n\tobject.strike = !! ( attr[ BPOS_STYLE ] & STRIKE ) ;\n\t\n\t// Blending part\n\tobject.styleTransparency = !! ( attr[ BPOS_BLENDING ] & STYLE_TRANSPARENCY ) ;\n\tobject.charTransparency = !! ( attr[ BPOS_BLENDING ] & CHAR_TRANSPARENCY ) ;\n\t\n\treturn object ;\n} ;\n\n\n\nScreenBufferHD.prototype.attr2object = function attr2object( attr )\n{\n\tvar object = {} ;\n\t\n\t// Color part\n\tobject.r = attr[ BPOS_R ] ;\n\tobject.g = attr[ BPOS_G ] ;\n\tobject.b = attr[ BPOS_B ] ;\n\tobject.a = attr[ BPOS_A ] ;\n\t\n\t// Background color part\n\tobject.bgR = attr[ BPOS_BG_R ] ;\n\tobject.bgG = attr[ BPOS_BG_G ] ;\n\tobject.bgB = attr[ BPOS_BG_B ] ;\n\tobject.bgA = attr[ BPOS_BG_A ] ;\n\t\n\t// Style part\n\tobject.bold = !! ( attr[ BPOS_STYLE ] & BOLD ) ;\n\tobject.dim = !! ( attr[ BPOS_STYLE ] & DIM ) ;\n\tobject.italic = !! ( attr[ BPOS_STYLE ] & ITALIC ) ;\n\tobject.underline = !! ( attr[ BPOS_STYLE ] & UNDERLINE ) ;\n\tobject.blink = !! ( attr[ BPOS_STYLE ] & BLINK ) ;\n\tobject.inverse = !! ( attr[ BPOS_STYLE ] & INVERSE ) ;\n\tobject.hidden = !! ( attr[ BPOS_STYLE ] & HIDDEN ) ;\n\tobject.strike = !! ( attr[ BPOS_STYLE ] & STRIKE ) ;\n\t\n\t// Blending part\n\tobject.styleTransparency = !! ( attr[ BPOS_BLENDING ] & STYLE_TRANSPARENCY ) ;\n\tobject.charTransparency = !! ( attr[ BPOS_BLENDING ] & CHAR_TRANSPARENCY ) ;\n\t\n\treturn object ;\n} ;\n\n\n\nScreenBufferHD.object2attr = function object2attr( object )\n{\n\tvar attr = Buffer.allocUnsafe( ScreenBufferHD.prototype.ATTR_SIZE ) ;\n\t\n\tif ( ! object || typeof object !== 'object' ) { object = {} ; }\n\t\n\t// Color part\n\tattr[ BPOS_R ] = + object.r || 0 ;\n\tattr[ BPOS_G ] = + object.g || 0 ;\n\tattr[ BPOS_B ] = + object.b || 0 ;\n\tattr[ BPOS_A ] = object.a !== undefined ? + object.a || 0 : 255 ;\n\t\n\t// Background color part\n\tattr[ BPOS_BG_R ] = + object.bgR || 0 ;\n\tattr[ BPOS_BG_G ] = + object.bgG || 0 ;\n\tattr[ BPOS_BG_B ] = + object.bgB || 0 ;\n\tattr[ BPOS_BG_A ] = object.bgA !== undefined ? + object.bgA || 0 : 255 ;\n\t\n\t// Style part\n\tattr[ BPOS_STYLE ] = 0 ;\n\t\n\tif ( object.bold ) { attr[ BPOS_STYLE ] |= BOLD ; }\n\tif ( object.dim ) { attr[ BPOS_STYLE ] |= DIM ; }\n\tif ( object.italic ) { attr[ BPOS_STYLE ] |= ITALIC ; }\n\tif ( object.underline ) { attr[ BPOS_STYLE ] |= UNDERLINE ; }\n\tif ( object.blink ) { attr[ BPOS_STYLE ] |= BLINK ; }\n\tif ( object.inverse ) { attr[ BPOS_STYLE ] |= INVERSE ; }\n\tif ( object.hidden ) { attr[ BPOS_STYLE ] |= HIDDEN ; }\n\tif ( object.strike ) { attr[ BPOS_STYLE ] |= STRIKE ; }\n\t\n\t// Blending part\n\tattr[ BPOS_BLENDING ] = 0 ;\n\tif ( object.styleTransparency ) { attr[ BPOS_BLENDING ] |= STYLE_TRANSPARENCY ; }\n\tif ( object.charTransparency ) { attr[ BPOS_BLENDING ] |= CHAR_TRANSPARENCY ; }\n\t\n\treturn attr ;\n} ;\n\n\n\nScreenBufferHD.prototype.object2attr = function object2attr( object )\n{\n\tvar attr = Buffer.allocUnsafe( ScreenBufferHD.prototype.ATTR_SIZE ) ;\n\t\n\tif ( ! object || typeof object !== 'object' ) { object = {} ; }\n\t\n\t// Color part\n\tattr[ BPOS_R ] = + object.r || 0 ;\n\tattr[ BPOS_G ] = + object.g || 0 ;\n\tattr[ BPOS_B ] = + object.b || 0 ;\n\tattr[ BPOS_A ] = object.a !== undefined ? + object.a || 0 : 255 ;\n\t\n\t// Background color part\n\tattr[ BPOS_BG_R ] = + object.bgR || 0 ;\n\tattr[ BPOS_BG_G ] = + object.bgG || 0 ;\n\tattr[ BPOS_BG_B ] = + object.bgB || 0 ;\n\tattr[ BPOS_BG_A ] = object.bgA !== undefined ? + object.bgA || 0 : 255 ;\n\t\n\t// Style part\n\tattr[ BPOS_STYLE ] = 0 ;\n\t\n\tif ( object.bold ) { attr[ BPOS_STYLE ] |= BOLD ; }\n\tif ( object.dim ) { attr[ BPOS_STYLE ] |= DIM ; }\n\tif ( object.italic ) { attr[ BPOS_STYLE ] |= ITALIC ; }\n\tif ( object.underline ) { attr[ BPOS_STYLE ] |= UNDERLINE ; }\n\tif ( object.blink ) { attr[ BPOS_STYLE ] |= BLINK ; }\n\tif ( object.inverse ) { attr[ BPOS_STYLE ] |= INVERSE ; }\n\tif ( object.hidden ) { attr[ BPOS_STYLE ] |= HIDDEN ; }\n\tif ( object.strike ) { attr[ BPOS_STYLE ] |= STRIKE ; }\n\t\n\t// Blending part\n\tattr[ BPOS_BLENDING ] = 0 ;\n\tif ( object.styleTransparency ) { attr[ BPOS_BLENDING ] |= STYLE_TRANSPARENCY ; }\n\tif ( object.charTransparency ) { attr[ BPOS_BLENDING ] |= CHAR_TRANSPARENCY ; }\n\t\n\treturn attr ;\n} ;\n\n\n\n\n\n\t\t\t/* Constants */\n\n\n\n// General purpose flags\nconst NONE = 0 ;\t// Nothing\n\n// Attr byte positions\nconst BPOS_R = 0 ;\nconst BPOS_G = 1 ;\nconst BPOS_B = 2 ;\nconst BPOS_A = 3 ;\nconst BPOS_BG_R = 4 ;\nconst BPOS_BG_G = 5 ;\nconst BPOS_BG_B = 6 ;\nconst BPOS_BG_A = 7 ;\nconst BPOS_STYLE = 8 ;\nconst BPOS_MISC = 9 ;\nconst BPOS_BLENDING = BPOS_MISC ;\n\n\n\n// Style flags\nconst BOLD = 1 ;\nconst DIM = 2 ;\nconst ITALIC = 4 ;\nconst UNDERLINE = 8 ;\nconst BLINK = 16 ;\nconst INVERSE = 32 ;\nconst HIDDEN = 64 ;\nconst STRIKE = 128 ;\n\nconst BOLD_DIM = BOLD | DIM ;\n\n// Misc flags\nconst STYLE_TRANSPARENCY = 4 ;\nconst CHAR_TRANSPARENCY = 8 ;\n\nconst LEADING_FULLWIDTH = 64 ;\nconst TRAILING_FULLWIDTH = 128 ;\n\n// Unused bits: 1, 2, 16 and 32\n\n\n\n// Tuning\nconst OUTPUT_THRESHOLD = 10000 ;\t// minimum amount of data to retain before sending them to the terminal\n\n\n\n/*\n\tCell structure:\n\t- 4 bytes: fg rgba\n\t- 4 bytes: bg rgba\n\t- 1 byte: style\n\t- 1 byte: blending flags\n*/\n\n// Data structure\nScreenBufferHD.prototype.ATTR_SIZE = 10 ;\nScreenBufferHD.prototype.CHAR_SIZE = 4 ;\nScreenBufferHD.prototype.ITEM_SIZE = ScreenBufferHD.prototype.ATTR_SIZE + ScreenBufferHD.prototype.CHAR_SIZE ;\n\nScreenBufferHD.prototype.DEFAULT_ATTR = ScreenBufferHD.object2attr( {\n\tr: 255 ,\n\tg: 255 ,\n\tb: 255 ,\n\ta: 255 ,\n\tbgR: 0 ,\n\tbgG: 0 ,\n\tbgB: 0 ,\n\tbgA: 255\n} ) ;\n\nScreenBufferHD.prototype.CLEAR_ATTR = ScreenBufferHD.object2attr( {\n\tr: 255 ,\n\tg: 255 ,\n\tb: 255 ,\n\ta: 0 ,\n\tbgR: 0 ,\n\tbgG: 0 ,\n\tbgB: 0 ,\n\tbgA: 0 ,\n\tcharTransparency: true ,\n\tstyleTransparency: true\n} ) ;\n\nScreenBufferHD.prototype.CLEAR_BUFFER = Buffer.allocUnsafe( ScreenBufferHD.prototype.ITEM_SIZE ) ;\nScreenBufferHD.prototype.DEFAULT_ATTR.copy( ScreenBufferHD.prototype.CLEAR_BUFFER ) ;\nScreenBufferHD.prototype.CLEAR_BUFFER.write( ' \\x00\\x00\\x00' , ScreenBufferHD.prototype.ATTR_SIZE ) ;\t// space\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/TextBuffer.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\n//var tree = require( 'tree-kit' ) ;\n//var async = require( 'async-kit' ) ;\n//var array = require( 'array-kit' ) ;\n//var punycode = require( 'punycode' ) ;\n\nvar fs = require( 'fs' ) ;\nvar string = require( 'string-kit' ) ;\n\n\n\n// A buffer suitable for text editor\n\n\n\nfunction TextBuffer() { throw new Error( 'Cannot create TextBuffer object directly.' ) ; }\nmodule.exports = TextBuffer ;\n\n\n\nvar termkit = require( './termkit.js' ) ;\nvar ScreenBuffer = termkit.ScreenBuffer ;\n\n\n\nTextBuffer.create = function create( options )\n{\n\t// Manage options\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tvar self = Object.create( TextBuffer.prototype , {\n\t\tScreenBuffer: { value: ScreenBuffer } ,\n\t\t\n\t\t// a screenBuffer\n\t\tdst: { value: options.dst , enumerable: true , writable: true } ,\n\t\t\n\t\t// virtually infinity by default\n\t\twidth: { value: options.width || Infinity , enumerable: true , writable: true } ,\n\t\theight: { value: options.height || Infinity , enumerable: true , writable: true } ,\n\t\t\n\t\tx: { writable: true , enumerable: true , value: options.x !== undefined ? options.x : 0 } ,\n\t\ty: { writable: true , enumerable: true , value: options.y !== undefined ? options.y : 0 } ,\n\t\tcx: { value: 0 , writable: true , enumerable: true } ,\n\t\tcy: { value: 0 , writable: true , enumerable: true } ,\n\t\t\n\t\temptyCellAttr: { value: ScreenBuffer.prototype.DEFAULT_ATTR , writable: true , enumerable: true } ,\n\t\thidden: { value: false , writable: true , enumerable: true } ,\n\t\t\n\t\ttabWidth: { value: options.tabWidth || 4 , writable: true , enumerable: true } ,\n\t\tforceInBound: { value: !! options.forceInBound , writable: true , enumerable: true } ,\n\t\t\n\t\twrap: { value: !! options.wrap , writable: true , enumerable: true }\n\t} ) ;\n\t\n\tObject.defineProperties( self , {\n\t\ttextBuffer: { enumerable: true , configurable: true , value: [] } ,\n\t\tattrBuffer: { enumerable: true , configurable: true , value: [[]] } ,\n\t\tmiscBuffer: { enumerable: true , configurable: true , value: [[]] }\n\t} ) ;\n\t\n\tif ( options.hidden ) { self.setHidden( options.hidden ) ; }\n\t\n\treturn self ;\n} ;\n\n\n\nTextBuffer.prototype.getText = function getText()\n{\n\treturn this.untab( this.textBuffer.join( '\\n' ) ) ;\n} ;\n\n\n\nTextBuffer.prototype.setText = function setText( text )\n{\n\tvar i , iMax ;\n\t//console.error( \"received:\" , text ) ;\n\t\n\ttext = text.split( '\\n' ) ;\n\t\n\tfor ( i = 0 , iMax = text.length ; i < iMax ; i ++ )\n\t{\n\t\tthis.textBuffer[ i ] = this.tab( text[ i ] ) ;\n\t\t//this.attrBuffer[ i ] = text.length  ?  array.fill( new Array( text[ i ].length ) , this.emptyCellAttr )  :  []  ;\n\t\tthis.attrBuffer[ i ] = text.length  ?  new Array( text[ i ].length ).fill( this.emptyCellAttr )  :  []  ;\n\t\tthis.miscBuffer[ i ] = [] ;\n\t}\n\t\n\tthis.textBuffer.splice( iMax , Infinity ) ;\n\tthis.attrBuffer.splice( iMax , Infinity ) ;\n\tthis.miscBuffer.splice( iMax , Infinity ) ;\n} ;\n\n\n\nTextBuffer.prototype.setHidden = function setHidden( value )\n{\n\tthis.hidden = typeof value === 'string' && value.length ? value[ 0 ] : ( value ? termkit.spChars.password : false ) ;\n} ;\n\nTextBuffer.prototype.getHidden = function getHidden() { return this.hidden ; } ;\n\n\n\nTextBuffer.prototype.getContentSize = function getContentSize()\n{\n\tvar i , iMax , width = 1 ;\n\t\n\tfor ( i = 0 , iMax = this.textBuffer.length ; i < iMax ; i ++ )\n\t{\n\t\twidth = Math.max( width , this.textBuffer[ i ].length ) ;\n\t}\n\t\n\treturn { width: width , height: iMax } ;\n} ;\n\n\n\n// Expand tab with filler chars\n// /!\\ str should be a line!!! /!\\\nTextBuffer.prototype.tab = function tab( str )\n{\n\tvar tabWidth = this.tabWidth , fillSize , nullCharsLength , shift = 0 ;\n\t\n\treturn str.replace( /\\t(\\x00)*/g , function( match , nullChars , index ) {\n\t\tnullCharsLength = nullChars ? nullChars.length : 0 ;\n\t\tindex += shift ;\t// we should shift the index depending on previous change on the string\n\t\tfillSize = tabWidth - ( index % tabWidth ) - 1 ;\t// Do not count the tab itself\n\t\tshift += fillSize - nullCharsLength ;\t// Adjust the shift\n\t\treturn '\\t' + string.repeat( '\\x00' , fillSize ) ;\n\t} ) ;\n} ;\n\n\n\n// /!\\ Use the 'startAt' parameter!!! /!\\\n\n// Same as tab() but work on both textBuffer and attrBuffer, at the current cursor position\nTextBuffer.prototype.tabLine = function tabLine( startAt )\n{\n\tvar self = this , shift = 0 , originalCx = this.cx ;\n\t\n\tif ( this.attrBuffer[ this.cy ] === undefined ) { this.attrBuffer[ this.cy ] = [] ; }\n\tif ( this.miscBuffer[ this.cy ] === undefined ) { this.miscBuffer[ this.cy ] = [] ; }\n\t\n\tthis.textBuffer[ this.cy ] = this.textBuffer[ this.cy ].replace( /(\\t|\\x00)(\\x00*)/g ,\n\t\t\n\t\tfunction( match , tabChar , nullChars , originalIndex ) {\n\t\t\t\n\t\t\tvar localShift , fillSize = 0 , pos , nullCharsLength , index ;\n\t\t\t\n\t\t\tnullCharsLength = nullChars ? nullChars.length : 0 ;\n\t\t\tindex = originalIndex + shift ;\t// we should shift the index depending on previous change on the string\n\t\t\t\n\t\t\ttabChar = tabChar === '\\t' ;\n\t\t\tif ( tabChar ) { fillSize = self.tabWidth - ( index % self.tabWidth ) - 1 ; }\t// Do not count the tab itself\n\t\t\telse { nullCharsLength ++ ; }\n\t\t\t\n\t\t\tlocalShift = fillSize - nullCharsLength ;\t// Adjust the shift\n\t\t\tshift += localShift ;\n\t\t\t\n\t\t\t/*\n\t\t\tconsole.error(\n\t\t\t\t\"originalIndex:\" , originalIndex , \"nullCharsLength:\" , nullCharsLength ,\n\t\t\t\t\"localShift:\" , localShift , \"self.cx:\" , self.cx , \"originalCx:\" , originalCx ,\n\t\t\t\t\"full-match:\" , string.escape.control( match ) ,\n\t\t\t\t\"full-line:\" , string.escape.control( self.textBuffer[ self.cy ] )\n\t\t\t) ;\n\t\t\t*/\n\t\t\t\n\t\t\tif ( originalIndex < originalCx ) { self.cx += localShift ; }\n\t\t\t\n\t\t\tif ( localShift > 0 )\n\t\t\t{\n\t\t\t\tpos = tabChar ? index + self.width - localShift : index ;\n\t\t\t\t\n\t\t\t\tself.attrBuffer[ self.cy ] =\n\t\t\t\t\tself.attrBuffer[ self.cy ].slice( 0 , pos ).concat( \n\t\t\t\t\t\t//array.fill( new Array( localShift ) , self.attrBuffer[ self.cy ][ index ] ) ,\n\t\t\t\t\t\tnew Array( localShift ).fill( self.attrBuffer[ self.cy ][ index ] ) ,\n\t\t\t\t\t\tself.attrBuffer[ self.cy ].slice( pos )\n\t\t\t\t\t) ;\n\t\t\t\t\n\t\t\t\tself.miscBuffer[ self.cy ] =\n\t\t\t\t\tself.miscBuffer[ self.cy ].slice( 0 , pos ).concat( \n\t\t\t\t\t\t//array.fill( new Array( localShift ) , null ) ,\n\t\t\t\t\t\tnew Array( localShift ).fill( null ) ,\n\t\t\t\t\t\tself.miscBuffer[ self.cy ].slice( pos )\n\t\t\t\t\t) ;\n\t\t\t}\n\t\t\telse if ( localShift < 0 )\n\t\t\t{\n\t\t\t\tpos = tabChar ? index + self.width + localShift : index ;\n\t\t\t\tself.attrBuffer[ self.cy ].splice( pos , -localShift ) ;\n\t\t\t\tself.miscBuffer[ self.cy ].splice( pos , -localShift ) ;\n\t\t\t}\n\t\t\t\n\t\t\treturn ( tabChar ? '\\t' : '' ) + string.repeat( '\\x00' , fillSize ) ;\n\t\t}\n\t) ;\n\t\n\t//console.error( \"fixed line:\" , string.escape.control( this.textBuffer[ this.cy ] ) ) ;\n} ;\n\n\n\n// Remove tab filler chars\nTextBuffer.prototype.untab = function untab( str ) { return str.replace( /\\x00*/g , '' ) ; } ;\n\n\n\nTextBuffer.prototype.setEmptyCellAttr = function setEmptyCellAttr( attr )\n{\n\tif ( attr && typeof attr === 'object' ) { attr = this.ScreenBuffer.object2attr( attr ) ; }\n\tif ( typeof attr !== 'number' ) { return ; }\n\t\n\tthis.emptyCellAttr = attr ;\n} ;\n\n\n\nTextBuffer.prototype.setAttrAt = function setAttrAt( attr , x , y )\n{\n\tif ( attr && typeof attr === 'object' ) { attr = this.ScreenBuffer.object2attr( attr ) ; }\n\tif ( typeof attr !== 'number' ) { return ; }\n\t\n\tthis.setAttrCodeAt( attr , x , y ) ;\n} ;\n\n\n\n// Faster than setAttrAt(), do no check attr, assume an attr code (number)\nTextBuffer.prototype.setAttrCodeAt = function setAttrCodeAt( attr , x , y )\n{\n\tif ( ! this.attrBuffer[ y ] ) { this.attrBuffer[ y ] = [] ; }\n\tthis.attrBuffer[ y ][ x ] = attr ;\n} ;\n\n\n\nvar wholeBufferRegion = { xmin: 0 , xmax: Infinity , ymin: 0 , ymax: Infinity } ;\n\n// Set a whole region\nTextBuffer.prototype.setAttrRegion = function setAttrRegion( attr , region )\n{\n\tif ( attr && typeof attr === 'object' ) { attr = this.ScreenBuffer.object2attr( attr ) ; }\n\tif ( typeof attr !== 'number' ) { return ; }\n\t\n\tthis.setAttrCodeRegion( attr , region ) ;\n} ;\n\n\n\n// Faster than setAttrRegion(), do no check attr, assume an attr code (number)\nTextBuffer.prototype.setAttrCodeRegion = function setAttrCodeRegion( attr , region )\n{\n\tvar x , y , xmin , xmax , ymax ;\n\t\n\tif ( ! region ) { region = wholeBufferRegion ; }\n\t\n\tymax = Math.min( region.ymax , this.textBuffer.length - 1 ) ;\n\t\n\tfor ( y = region.ymin ; y <= ymax ; y ++ )\n\t{\n\t\tif ( ! this.textBuffer[ y ] ) { this.textBuffer[ y ] = '' ; }\n\t\tif ( ! this.attrBuffer[ y ] ) { this.attrBuffer[ y ] = [] ; }\n\t\t\n\t\txmin = y === region.ymin ? region.xmin : 0 ;\n\t\txmax = y === region.ymax ? Math.min( region.xmax , this.textBuffer[ y ].length - 1 ) : this.textBuffer[ y ].length - 1 ;\n\t\t\n\t\tfor ( x = xmin ; x <= xmax ; x ++ )\n\t\t{\n\t\t\tthis.attrBuffer[ y ][ x ] = attr ;\n\t\t}\n\t}\n} ;\n\n\n\nTextBuffer.prototype.getMisc = function getMisc()\n{\n\tif ( ! this.miscBuffer[ this.cy ] ) { this.miscBuffer[ this.cy ] = [] ; }\n\tif ( ! this.miscBuffer[ this.cy ][ this.cx ] ) { this.miscBuffer[ this.cy ][ this.cx ] = {} ; }\n\treturn this.miscBuffer[ this.cy ][ this.cx ] ;\n} ;\n\n\n\nTextBuffer.prototype.getMiscAt = function getMiscAt( x , y )\n{\n\tif ( ! this.miscBuffer[ y ] ) { this.miscBuffer[ y ] = [] ; }\n\tif ( ! this.miscBuffer[ y ][ x ] ) { this.miscBuffer[ y ][ x ] = {} ; }\n\treturn this.miscBuffer[ y ][ x ] ;\n} ;\n\n\n\nTextBuffer.prototype.iterate = function iterate( options , callback )\n{\n\tvar x , y , offset , length ;\n\t\n\tif ( typeof options === 'function' ) { callback = options ; options = {} ; }\n\telse if ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tif ( ! this.textBuffer.length ) { return ; }\n\t\n\toffset = 0 ;\n\ty = 0 ;\n\t\n\twhile ( true )\n\t{\n\t\tif ( this.textBuffer[ y ] )\n\t\t{\n\t\t\tlength = this.textBuffer[ y ].length ;\n\t\t\t\n\t\t\tfor ( x = 0 ; x < length ; x ++ )\n\t\t\t{\n\t\t\t\tif ( this.textBuffer[ y ][ x ] === '\\x00' ) { continue ; }\n\t\t\t\t\n\t\t\t\tcallback( {\n\t\t\t\t\toffset: offset ,\n\t\t\t\t\tx: x ,\n\t\t\t\t\ty: y ,\n\t\t\t\t\ttext: this.textBuffer[ y ][ x ] ,\n\t\t\t\t\tattr: this.attrBuffer[ y ][ x ] ,\n\t\t\t\t\tmisc: this.miscBuffer[ y ][ x ]\n\t\t\t\t} ) ;\n\t\t\t\t\n\t\t\t\toffset ++ ;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Another iteration?\n\t\tif ( y + 1 >= this.textBuffer.length ) { break ; }\n\t\t\n\t\t// Send the \\n\n\t\toffset ++ ;\n\t\t\n\t\tcallback( {\n\t\t\toffset: offset ,\n\t\t\tx: null ,\n\t\t\ty: y ,\n\t\t\ttext: '\\n' ,\n\t\t\tattr: null\n\t\t} ) ;\n\t\t\n\t\ty ++ ;\n\t}\n\t\n\t\n\t// Call the callback one last time at the end of the buffer, with an empty string.\n\t// Useful for 'Ne' (Neon) state machine.\n\tif ( options.finalCall )\n\t{\n\t\tcallback( {\n\t\t\toffset: offset + 1 ,\n\t\t\tx: null ,\n\t\t\ty: y ,\n\t\t\ttext: '' ,\n\t\t\tattr: null\n\t\t} ) ;\n\t}\n} ;\n\n\n\nTextBuffer.prototype.moveTo = function moveTo( x , y )\n{\n\tthis.cx = x >= 0 ? x : 0 ;\n\tthis.cy = y >= 0 ? y : 0 ;\n} ;\n\n\n\nTextBuffer.prototype.move = function move( x , y ) { this.moveTo( this.cx + x , this.cy + y ) ; } ;\nTextBuffer.prototype.moveToColumn = function moveToColumn( x ) { this.moveTo( x , this.cy ) ; } ;\nTextBuffer.prototype.moveToLine = TextBuffer.prototype.moveToRow = function moveToLine( y ) { this.moveTo( this.cx , y ) ; } ;\n\n\n\nTextBuffer.prototype.moveUp = function moveUp()\n{\n\tthis.cy = this.cy > 0 ? this.cy - 1 : 0 ;\n\tif ( this.forceInBound ) { this.moveInBound( true ) ; }\n} ;\n\n\n\nTextBuffer.prototype.moveDown = function moveDown()\n{\n\tthis.cy ++ ;\n\tif ( this.forceInBound ) { this.moveInBound( true ) ; }\n} ;\n\n\n\nTextBuffer.prototype.moveLeft = function moveLeft()\n{\n\tthis.cx = this.cx > 0 ? this.cx - 1 : 0 ;\n\tif ( this.forceInBound ) { this.moveInBound( true ) ; }\n} ;\n\n\n\nTextBuffer.prototype.moveRight = function moveRight()\n{\n\tthis.cx ++ ;\n\tif ( this.forceInBound ) { this.moveInBound( true ) ; }\n} ;\n\n\n\nTextBuffer.prototype.moveForward = function moveForward( justSkipNull )\n{\n\tvar oldCx = this.cx ;\n\t\n\tif ( justSkipNull && ( ! this.textBuffer[ this.cy ] || this.textBuffer[ this.cy ][ this.cx ] !== '\\x00' ) ) { return ; }\n\t\n\twhile ( true )\n\t{\n\t\tthis.cx ++ ;\n\t\t\n\t\tif ( ! this.textBuffer[ this.cy ] || this.cx > this.textBuffer[ this.cy ].length )\n\t\t{\n\t\t\tif ( this.cy + 1 < this.textBuffer.length || ! this.forceInBound )\n\t\t\t{\n\t\t\t\tthis.cy ++ ;\n\t\t\t\tthis.cx = 0 ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.cx = oldCx ;\n\t\t\t}\n\t\t\t\n\t\t\tbreak ;\n\t\t}\n\t\t\n\t\tif ( ! this.textBuffer[ this.cy ] || this.textBuffer[ this.cy ][ this.cx ] !== '\\x00' ) { break ; }\n\t}\n\t\n\tif ( this.forceInBound ) { this.moveInBound() ; }\n} ;\n\n\n\nTextBuffer.prototype.moveBackward = function moveBackward( justSkipNull )\n{\n\tvar lineLength ;\n\t\n\tif ( justSkipNull && ( ! this.textBuffer[ this.cy ] || this.textBuffer[ this.cy ][ this.cx ] !== '\\x00' ) ) { return ; }\n\t\n\twhile ( true )\n\t{\n\t\tlineLength = this.textBuffer[ this.cy ] ? this.textBuffer[ this.cy ].length : 0 ;\n\t\t\n\t\tif ( this.cx > lineLength ) { this.cx = lineLength ; }\n\t\telse { this.cx -- ; }\n\t\t\n\t\tif ( this.cx < 0 )\n\t\t{\n\t\t\tthis.cy -- ;\n\t\t\t\n\t\t\tif ( this.cy < 0 ) { this.cy = 0 ; this.cx = 0 ; break ; }\n\t\t\t\n\t\t\tlineLength = this.textBuffer[ this.cy ] ? this.textBuffer[ this.cy ].length : 0 ;\n\t\t\tthis.cx = lineLength ;\n\t\t\tbreak ;\n\t\t}\n\t\t\n\t\tif ( ! this.textBuffer[ this.cy ] || this.textBuffer[ this.cy ][ this.cx ] !== '\\x00' ) { break ; }\n\t}\n\t\n\tif ( this.forceInBound ) { this.moveInBound() ; }\n} ;\n\n\n\nTextBuffer.prototype.moveToEndOfLine = function moveToEndOfLine()\n{\n\tthis.cx = this.textBuffer[ this.cy ] ? this.textBuffer[ this.cy ].length : 0 ;\n} ;\n\n\n\nTextBuffer.prototype.moveInBound = function moveInBound( ignoreCx )\n{\n\tif ( this.cy > this.textBuffer.length ) { this.cy = this.textBuffer.length ; }\n\t\n\tif ( ignoreCx ) { return ; }\n\t\n\tif ( ! this.textBuffer[ this.cy ] ) { this.cx = 0 ; }\n\telse if ( this.cx > this.textBuffer[ this.cy ].length ) { this.cx = this.textBuffer[ this.cy ].length ; }\n} ;\n\n\n\nTextBuffer.prototype.insert = function insert( text , attr )\n{\n\tvar lines , index , length ;\n\t\n\tif ( ! text ) { return ; }\n\t\n\tlines = text.split( '\\n' ) ;\n\tlength = lines.length ;\n\t\n\tif ( attr && typeof attr === 'object' ) { attr = this.ScreenBuffer.object2attr( attr ) ; }\n\tif ( typeof attr !== 'number' ) { attr = this.emptyCellAttr ; }\n\t\n\tif ( this.forceInBound ) { this.moveInBound() ; }\n\t\n\tthis.inlineInsert( lines[ 0 ] , attr ) ;\n\t\n\tfor ( index = 1 ; index < length ; index ++ )\n\t{\n\t\tthis.newLine( true ) ;\n\t\tthis.inlineInsert( lines[ index ] , attr ) ;\n\t}\n} ;\n\n\n\n// Internal API:\n// Insert inline chars (no control chars)\nTextBuffer.prototype.inlineInsert = function inlineInsert( text , attr )\n{\n\tvar currentLineLength , attrArray , miscArray , tabIndex ;\n\t\n\tthis.moveForward( true ) ;\t// just skip null char\n\t\n\tif ( this.textBuffer[ this.cy ] === undefined ) { this.textBuffer[ this.cy ] = '' ; }\n\tif ( this.attrBuffer[ this.cy ] === undefined ) { this.attrBuffer[ this.cy ] = [] ; }\n\tif ( this.miscBuffer[ this.cy ] === undefined ) { this.miscBuffer[ this.cy ] = [] ; }\n\t\n\tcurrentLineLength = this.textBuffer[ this.cy ].length ;\n\t\n\t\n\t// Check if attrBuffer is okey\n\tif ( currentLineLength !== this.attrBuffer[ this.cy ].length || currentLineLength !== this.miscBuffer[ this.cy ].length )\n\t{\n\t\tthis.fixBuffers( this.cy ) ;\n\t}\n\t\n\t\n\t// Create the attribute array to insert\n\t//attrArray = array.fill( new Array( text.length ) , attr ) ;\n\t//miscArray = array.fill( new Array( text.length ) , null ) ;\n\tattrArray = new Array( text.length ).fill( attr ) ;\n\tmiscArray = new Array( text.length ).fill( null ) ;\n\t\n\t\n\t// Apply\n\tif ( this.cx === currentLineLength )\n\t{\n\t\tthis.textBuffer[ this.cy ] += text ;\n\t\t\n\t\tthis.attrBuffer[ this.cy ] = this.attrBuffer[ this.cy ].concat( attrArray ) ;\n\t\tthis.miscBuffer[ this.cy ] = this.miscBuffer[ this.cy ].concat( miscArray ) ;\n\t}\n\telse if ( this.cx < currentLineLength )\n\t{\n\t\tthis.textBuffer[ this.cy ] =\n\t\t\tthis.textBuffer[ this.cy ].slice( 0 , this.cx ) +\n\t\t\ttext +\n\t\t\tthis.textBuffer[ this.cy ].slice( this.cx ) ;\n\t\t\n\t\tthis.attrBuffer[ this.cy ] =\n\t\t\tthis.attrBuffer[ this.cy ].slice( 0 , this.cx ).concat( \n\t\t\t\tattrArray ,\n\t\t\t\tthis.attrBuffer[ this.cy ].slice( this.cx )\n\t\t\t) ;\n\t\t\n\t\tthis.miscBuffer[ this.cy ] =\n\t\t\tthis.miscBuffer[ this.cy ].slice( 0 , this.cx ).concat( \n\t\t\t\tmiscArray ,\n\t\t\t\tthis.miscBuffer[ this.cy ].slice( this.cx )\n\t\t\t) ;\n\t}\n\telse // if ( this.cx > currentLineLength )\n\t{\n\t\tthis.textBuffer[ this.cy ] += string.repeat( ' ' , this.cx - currentLineLength ) + text ;\n\t\t\n\t\tthis.attrBuffer[ this.cy ] =\n\t\t\tthis.attrBuffer[ this.cy ].concat(\n\t\t\t\t//array.fill( new Array( this.cx - currentLineLength ) , this.emptyCellAttr ) ,\n\t\t\t\tnew Array( this.cx - currentLineLength ).fill( this.emptyCellAttr ) ,\n\t\t\t\tattrArray\n\t\t\t) ;\n\t\t\n\t\tthis.miscBuffer[ this.cy ] =\n\t\t\tthis.miscBuffer[ this.cy ].concat(\n\t\t\t\t//array.fill( new Array( this.cx - currentLineLength ) , null ) ,\n\t\t\t\tnew Array( this.cx - currentLineLength ).fill( null ) ,\n\t\t\t\tmiscArray\n\t\t\t) ;\n\t}\n\t\n\t// Patch tab if needed\n\ttabIndex = this.textBuffer[ this.cy ].indexOf( '\\t' , this.cx ) ;\n\tthis.cx += text.length ;\n\tif ( tabIndex !== -1 ) { this.tabLine( tabIndex ) ; }\n} ;\n\n\n\n// /!\\ Bug with tabs and count > 1 !!! /!\\\n\n// Delete chars\nTextBuffer.prototype.delete = function delete_( count )\n{\n\tvar inlineCount , tabIndex ;\n\t\n\tif ( count === undefined ) { count = 1 ; }\n\t\n\tif ( this.forceInBound ) { this.moveInBound() ; }\n\t\n\tif ( this.textBuffer[ this.cy ] && this.textBuffer[ this.cy ][ this.cx ] === '\\x00' )\n\t{\n\t\tthis.moveBackward( true ) ;\t// just skip null char\n\t\tcount -- ;\n\t}\n\t\n\twhile ( count > 0 )\n\t{\n\t\t// If we are already at the end of the buffer...\n\t\tif ( this.cy >= this.textBuffer.length ||\n\t\t\t( this.cy === this.textBuffer.length - 1 && this.cx >= this.textBuffer[ this.cy ].length ) )\n\t\t{\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tif ( this.textBuffer[ this.cy ] )\n\t\t{\n\t\t\tif ( this.attrBuffer[ this.cy ] === undefined ) { this.attrBuffer[ this.cy ] = [] ; }\n\t\t\tif ( this.miscBuffer[ this.cy ] === undefined ) { this.miscBuffer[ this.cy ] = [] ; }\n\t\t\t\n\t\t\t// Check if attrBuffer is okey\n\t\t\tif ( this.textBuffer[ this.cy ].length !== this.attrBuffer[ this.cy ].length ||\n\t\t\t\tthis.textBuffer[ this.cy ].length !== this.miscBuffer[ this.cy ].length )\n\t\t\t{\n\t\t\t\tthis.fixBuffers( this.cy ) ;\n\t\t\t}\n\t\t\t\n\t\t\t// If the cursor is to far away, move it at the end of the line\n\t\t\tif ( this.cx > this.textBuffer[ this.cy ].length ) { this.cx = this.textBuffer[ this.cy ].length ; }\n\t\t\t\n\t\t\t// Compute inline delete\n\t\t\t//inlineCount = Math.min( count , this.textBuffer[ this.cy ].length - this.cx ) ;\n\t\t\tinlineCount = this.countInlineForward( count ) ;\n\t\t\t\n\t\t\t// Apply inline delete\n\t\t\tif ( inlineCount > 0 )\n\t\t\t{\n\t\t\t\tthis.textBuffer[ this.cy ] =\n\t\t\t\t\tthis.textBuffer[ this.cy ].slice( 0 , this.cx ) +\n\t\t\t\t\tthis.textBuffer[ this.cy ].slice( this.cx + inlineCount ) ;\n\t\t\t\t\n\t\t\t\tthis.attrBuffer[ this.cy ] =\n\t\t\t\t\tthis.attrBuffer[ this.cy ].slice( 0 , this.cx ).concat( \n\t\t\t\t\t\tthis.attrBuffer[ this.cy ].slice( this.cx + inlineCount )\n\t\t\t\t\t) ;\n\t\t\t\t\n\t\t\t\tthis.miscBuffer[ this.cy ] =\n\t\t\t\t\tthis.miscBuffer[ this.cy ].slice( 0 , this.cx ).concat( \n\t\t\t\t\t\tthis.miscBuffer[ this.cy ].slice( this.cx + inlineCount )\n\t\t\t\t\t) ;\n\t\t\t}\n\t\t\t\n\t\t\tcount -= inlineCount ;\n\t\t}\n\t\t\n\t\tif ( count > 0 )\n\t\t{\n\t\t\tthis.joinLine( true ) ;\n\t\t\tcount -- ;\n\t\t}\n\t}\n\t\n\t// Patch tab if needed\n\t//tabIndex = this.textBuffer[ this.cy ].indexOf( '\\t' , this.cx ) ;\n\t//if ( tabIndex !== -1 ) { this.tabLine( tabIndex ) ; }\n\tthis.tabLine( tabIndex ) ;\t// Do it every time, before finding a better way to do it\n} ;\n\n\n\n// /!\\ Bug with tabs and count > 1 !!! /!\\\n\n// Delete backward chars\nTextBuffer.prototype.backDelete = function backDelete( count )\n{\n\tvar inlineCount , tabIndex ;\n\t\n\tif ( count === undefined ) { count = 1 ; }\n\t\n\tif ( this.forceInBound ) { this.moveInBound() ; }\n\t\n\tif ( this.textBuffer[ this.cy ] && this.cx && this.textBuffer[ this.cy ][ this.cx - 1 ] === '\\x00' )\n\t{\n\t\tthis.moveBackward( true ) ;\t// just skip null char\n\t\t//count -- ;\t// do not downcount: the cursor is always on a \\x00 before deleting a \\t\n\t}\n\t\n\twhile ( count > 0 )\n\t{\n\t\t// If we are already at the begining of the buffer...\n\t\tif ( this.cy === 0 && this.cx === 0 ) { return ; }\n\t\t\n\t\tif ( this.textBuffer[ this.cy ] )\n\t\t{\n\t\t\tif ( this.attrBuffer[ this.cy ] === undefined ) { this.attrBuffer[ this.cy ] = [] ; }\n\t\t\tif ( this.miscBuffer[ this.cy ] === undefined ) { this.miscBuffer[ this.cy ] = [] ; }\n\t\t\t\n\t\t\t// Check if attrBuffer is okey\n\t\t\tif ( this.textBuffer[ this.cy ].length !== this.attrBuffer[ this.cy ].length ||\n\t\t\t\tthis.textBuffer[ this.cy ].length !== this.miscBuffer[ this.cy ].length )\n\t\t\t{\n\t\t\t\tthis.fixBuffers( this.cy ) ;\n\t\t\t}\n\t\t\t\n\t\t\t// If the cursor is to far away, move it at the end of the line, it will cost one 'count'\n\t\t\tif ( this.cx > this.textBuffer[ this.cy ].length )\n\t\t\t{\n\t\t\t\tthis.cx = this.textBuffer[ this.cy ].length ;\n\t\t\t\tcount -- ;\n\t\t\t}\n\t\t\t\n\t\t\t// Compute inline delete\n\t\t\tinlineCount = this.countInlineBackward( count ) ;\n\t\t\t\n\t\t\t// Apply inline delete\n\t\t\tif ( inlineCount > 0 )\n\t\t\t{\n\t\t\t\tthis.textBuffer[ this.cy ] =\n\t\t\t\t\tthis.textBuffer[ this.cy ].slice( 0 , this.cx - inlineCount ) +\n\t\t\t\t\tthis.textBuffer[ this.cy ].slice( this.cx ) ;\n\t\t\t\t\n\t\t\t\tthis.attrBuffer[ this.cy ] =\n\t\t\t\t\tthis.attrBuffer[ this.cy ].slice( 0 , this.cx - inlineCount ).concat( \n\t\t\t\t\t\tthis.attrBuffer[ this.cy ].slice( this.cx )\n\t\t\t\t\t) ;\n\t\t\t\t\n\t\t\t\tthis.miscBuffer[ this.cy ] =\n\t\t\t\t\tthis.miscBuffer[ this.cy ].slice( 0 , this.cx - inlineCount ).concat( \n\t\t\t\t\t\tthis.miscBuffer[ this.cy ].slice( this.cx )\n\t\t\t\t\t) ;\n\t\t\t\t\n\t\t\t\tthis.cx -= inlineCount ;\n\t\t\t}\n\t\t\t\n\t\t\tcount -= inlineCount ;\n\t\t}\n\t\t\n\t\tif ( count > 0 )\n\t\t{\n\t\t\tthis.cy -- ;\n\t\t\tthis.cx = this.textBuffer[ this.cy ] ? this.textBuffer[ this.cy ].length : 0 ;\n\t\t\tthis.joinLine( true ) ;\n\t\t\tcount -- ;\n\t\t}\n\t}\n\t\n\t// Patch tab if needed\n\t//tabIndex = this.textBuffer[ this.cy ].indexOf( '\\t' , this.cx ) ;\n\t//if ( tabIndex !== -1 ) { this.tabLine( tabIndex ) ; }\n\tthis.tabLine( tabIndex ) ;\t// Do it every time, before finding a better way to do it\n} ;\n\n\n\n// Fix a backward counter, get an additional count for each null char encountered\nTextBuffer.prototype.countInlineBackward = function countInlineBackward( count )\n{\n\tvar c , x ;\n\t\n\tfor ( x = this.cx - 1 , c = 0 ; x >= 0 && c < count ; x -- , c ++ )\n\t{\n\t\tif ( this.textBuffer[ this.cy ][ x ] === '\\x00' ) { count ++ ; }\n\t}\n\t\n\treturn c ;\n} ;\n\n\n\n// Fix a forward counter, get an additional count for each null char encountered\nTextBuffer.prototype.countInlineForward = function countInlineForward( count )\n{\n\tvar c , x , xMax = this.textBuffer[ this.cy ].length ;\n\t\n\tfor ( x = this.cx , c = 0 ; x < xMax && c < count ; x ++ , c ++ )\n\t{\n\t\tif ( this.textBuffer[ this.cy ][ x ] === '\\x00' ) { count ++ ; }\n\t}\n\t\n\treturn c ;\n} ;\n\n\n\nTextBuffer.prototype.newLine = function newLine( internalCall )\n{\n\tvar currentLineLength , nextTextLine = '' , nextAttrLine = [] , nextMiscLine = [] , tabIndex ;\n\t\n\tif ( ! internalCall && this.forceInBound ) { this.moveInBound() ; }\n\t\n\tif ( this.textBuffer[ this.cy ] === undefined ) { this.textBuffer[ this.cy ] = '' ; }\n\tif ( this.attrBuffer[ this.cy ] === undefined ) { this.attrBuffer[ this.cy ] = [] ; }\n\tif ( this.miscBuffer[ this.cy ] === undefined ) { this.miscBuffer[ this.cy ] = [] ; }\n\t\n\tcurrentLineLength = this.textBuffer[ this.cy ].length ;\n\t\n\t\n\t// Check if attrBuffer is okey\n\tif ( currentLineLength !== this.attrBuffer[ this.cy ].length || currentLineLength !== this.miscBuffer[ this.cy ].length )\n\t{\n\t\tthis.fixBuffers( this.cy ) ;\n\t}\n\t\n\t\n\t// Apply\n\tif ( this.cx < currentLineLength )\n\t{\n\t\tnextTextLine = this.textBuffer[ this.cy ].slice( this.cx ) ;\n\t\tthis.textBuffer[ this.cy ] = this.textBuffer[ this.cy ].slice( 0 , this.cx ) ;\n\t\t\n\t\tnextAttrLine = this.attrBuffer[ this.cy ].slice( this.cx ) ;\n\t\tthis.attrBuffer[ this.cy ] = this.attrBuffer[ this.cy ].slice( 0 , this.cx ) ;\n\t\t\n\t\tnextMiscLine = this.miscBuffer[ this.cy ].slice( this.cx ) ;\n\t\tthis.miscBuffer[ this.cy ] = this.miscBuffer[ this.cy ].slice( 0 , this.cx ) ;\n\t}\n\t\n\tthis.textBuffer.splice( this.cy + 1 , 0 , nextTextLine ) ;\n\tthis.attrBuffer.splice( this.cy + 1 , 0 , nextAttrLine ) ;\n\tthis.miscBuffer.splice( this.cy + 1 , 0 , nextMiscLine ) ;\n\t\n\tthis.cx = 0 ;\n\tthis.cy ++ ;\n\t\n\t// Patch tab if needed\n\tif ( ! internalCall )\n\t{\n\t\ttabIndex = this.textBuffer[ this.cy ].indexOf( '\\t' , this.cx ) ;\n\t\tif ( tabIndex !== -1 ) { this.tabLine( tabIndex ) ; }\n\t}\n} ;\n\n\n\nTextBuffer.prototype.joinLine = function joinLine( internalCall )\n{\n\tvar tabIndex ;\n\t\n\tif ( ! internalCall && this.forceInBound ) { this.moveInBound() ; }\n\t\n\tif ( this.textBuffer[ this.cy ] === undefined ) { this.textBuffer[ this.cy ] = '' ; }\n\tif ( this.textBuffer[ this.cy + 1 ] === undefined ) { this.textBuffer[ this.cy + 1 ] = '' ; }\n\tif ( this.attrBuffer[ this.cy ] === undefined ) { this.attrBuffer[ this.cy ] = [] ; }\n\tif ( this.attrBuffer[ this.cy + 1 ] === undefined ) { this.attrBuffer[ this.cy + 1 ] = [] ; }\n\tif ( this.miscBuffer[ this.cy ] === undefined ) { this.miscBuffer[ this.cy ] = [] ; }\n\tif ( this.miscBuffer[ this.cy + 1 ] === undefined ) { this.miscBuffer[ this.cy + 1 ] = [] ; }\n\t\n\t\n\t// Check if attrBuffer is okey\n\tif ( this.textBuffer[ this.cy ].length !== this.attrBuffer[ this.cy ].length ||\n\t\tthis.textBuffer[ this.cy ].length !== this.miscBuffer[ this.cy ].length )\n\t{\n\t\tthis.fixBuffers( this.cy ) ;\n\t}\n\t\n\tif ( this.textBuffer[ this.cy + 1 ].length !== this.attrBuffer[ this.cy + 1 ].length ||\n\t\tthis.textBuffer[ this.cy + 1 ].length !== this.miscBuffer[ this.cy + 1 ].length )\n\t{\n\t\tthis.fixBuffers( this.cy + 1 ) ;\n\t}\n\t\n\tthis.cx = this.textBuffer[ this.cy ].length ;\n\t\n\tthis.textBuffer[ this.cy ] += this.textBuffer[ this.cy + 1 ] ;\n\tthis.attrBuffer[ this.cy ] = this.attrBuffer[ this.cy ].concat( this.attrBuffer[ this.cy + 1 ] ) ;\n\tthis.miscBuffer[ this.cy ] = this.miscBuffer[ this.cy ].concat( this.miscBuffer[ this.cy + 1 ] ) ;\n\t\n\tthis.textBuffer.splice( this.cy + 1 , 1 ) ;\n\tthis.attrBuffer.splice( this.cy + 1 , 1 ) ;\n\tthis.miscBuffer.splice( this.cy + 1 , 1 ) ;\n\t\n\t// Patch tab if needed\n\tif ( ! internalCall )\n\t{\n\t\ttabIndex = this.textBuffer[ this.cy ].indexOf( '\\t' , this.cx ) ;\n\t\tif ( tabIndex !== -1 ) { this.tabLine( tabIndex ) ; }\n\t}\n} ;\n\n\n\nTextBuffer.prototype.fixBuffers = function fixBuffers( y )\n{\n\t// Something was wrong, try to fix that now\n\t//console.error( \"attrBuffer and/or miscBuffer is fucked up at line \" + y + \", fixing it now...\" ) ;\n\t\n\tvar currentLineTextLength = this.textBuffer[ y ].length ;\n\tvar currentLineAttrLength = this.attrBuffer[ y ].length ;\n\tvar currentLineMiscLength = this.miscBuffer[ y ].length ;\n\t\n\tif ( currentLineTextLength > currentLineAttrLength )\n\t{\n\t\tthis.attrBuffer[ y ] = this.attrBuffer[ y ].concat(\n\t\t\t//array.fill( new Array( currentLineTextLength - currentLineAttrLength ) , this.emptyCellAttr )\n\t\t\tnew Array( currentLineTextLength - currentLineAttrLength ).fill( this.emptyCellAttr )\n\t\t) ;\n\t}\n\telse\n\t{\n\t\tthis.attrBuffer[ y ] = this.attrBuffer[ y ].slice( 0 , currentLineTextLength ) ;\n\t}\n\t\n\tif ( currentLineTextLength > currentLineMiscLength )\n\t{\n\t\tthis.miscBuffer[ y ] = this.miscBuffer[ y ].concat(\n\t\t\t//array.fill( new Array( currentLineTextLength - currentLineMiscLength ) , null )\n\t\t\tnew Array( currentLineTextLength - currentLineMiscLength ).fill( null )\n\t\t) ;\n\t}\n\telse\n\t{\n\t\tthis.miscBuffer[ y ] = this.miscBuffer[ y ].slice( 0 , currentLineTextLength ) ;\n\t}\n} ;\n\n\n\n\n\n\n/*\n\tA TextBuffer can only draw to a ScreenBuffer.\n\tTo display it, you need to:\n\t\t- draw the TextBuffer to a ScreenBuffer\n\t\t- then draw that ScreenBuffer to the terminal\n*/\nTextBuffer.prototype.draw = function draw( options )\n{\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\t// Transmitted options (do not edit the user provided options, clone them)\n\tvar tr = {\n\t\tdst: options.dst || this.dst ,\n\t\toffsetX: options.x !== undefined ? Math.floor( options.x ) : Math.floor( this.x ) ,\n\t\toffsetY: options.y !== undefined ? Math.floor( options.y ) : Math.floor( this.y ) ,\n\t\tdstClipRect: options.dstClipRect ? termkit.Rect.create( options.dstClipRect ) : undefined ,\n\t\tsrcClipRect: options.srcClipRect ? termkit.Rect.create( options.srcClipRect ) : undefined ,\n\t\tblending: options.blending ,\n\t\twrap: options.wrap ,\n\t\ttile: options.tile\n\t} ;\n\t\n\tif ( tr.dst instanceof ScreenBuffer )\n\t{\n\t\tthis.blitter( tr ) ;\n\t\t\n\t\tif ( options.cursor )\n\t\t{\n\t\t\ttr.dst.cx = this.cx + tr.offsetX ;\n\t\t\ttr.dst.cy = this.cy + tr.offsetY ;\n\t\t}\n\t}\n} ;\n\n\n\nTextBuffer.prototype.drawCursor = function drawCursor( options )\n{\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tvar dst = options.dst || this.dst ;\n\t\n\tif ( dst instanceof ScreenBuffer )\n\t{\n\t\tdst.cx = Math.min( this.cx + this.x , dst.width - 1 ) ;\n\t\tdst.cy = Math.min( this.cy + this.y , dst.height - 1 ) ;\n\t}\n} ;\n\n\n\nTextBuffer.prototype.blitter = function blitter( p )\n{\n\tvar tr , iterator , iteratorCallback ;\n\t\n\t// Default options & iterator\n\ttr = {\n\t\ttype: 'line' ,\n\t\tcontext: {\n\t\t\tsrcTextBuffer: this.textBuffer ,\n\t\t\tsrcAttrBuffer: this.attrBuffer ,\n\t\t\tdstBuffer: p.dst.buffer ,\n\t\t\temptyCellAttr: this.emptyCellAttr\n\t\t} ,\n\t\tdstRect: termkit.Rect.create( p.dst ) ,\n\t\tsrcRect: termkit.Rect.create( this ) ,\n\t\tdstClipRect: p.dstClipRect || termkit.Rect.create( p.dst ) ,\n\t\tsrcClipRect: p.srcClipRect || termkit.Rect.create( this ) ,\n\t\toffsetX: p.offsetX ,\n\t\toffsetY: p.offsetY ,\n\t\twrap: p.wrap ,\n\t\ttile: p.tile ,\n\t\tmultiply: this.ScreenBuffer.prototype.ITEM_SIZE\n\t} ;\n\t\n\titerator = 'regionIterator' ;\n\t\n\tif ( this.hidden )\n\t{\n\t\ttr.context.char = this.hidden ;\n\t\titeratorCallback = this.blitterHiddenLineIterator.bind( this ) ;\n\t}\n\telse\n\t{\n\t\titeratorCallback = this.blitterLineIterator.bind( this ) ;\n\t}\n\t\n\t/*\n\t// If blending is on, switch to the cell iterator\n\tif ( p.blending )\n\t{\n\t\ttr.type = 'cell' ;\n\t\titeratorCallback = blitterCellBlendingIterator ;\n\t}\n\t//*/\n\t\n\tif ( p.wrap ) { iterator = 'wrapIterator' ; }\n\telse if ( p.tile ) { iterator = 'tileIterator' ; }\n\telse { iterator = 'regionIterator' ; }\n\t\n\ttermkit.Rect[ iterator ]( tr , iteratorCallback ) ;\n} ;\n\n\n\nTextBuffer.prototype.blitterLineIterator = function blitterLineIterator( p )\n{\n\tvar srcX , srcExistingXmax , dstOffset , attrs , attr , str , charCode ;\n\t\n\t//if ( ! global.deb ) { global.deb = [] ; }\n\t//global.deb.push( p ) ;\n\t\n\tstr = p.context.srcTextBuffer[ p.srcY ] || '' ;\n\tattrs = p.context.srcAttrBuffer[ p.srcY ] || [] ;\n\t\n\tsrcExistingXmax = p.srcXmax ;\n\t\n\tif ( srcExistingXmax >= str.length ) { srcExistingXmax = str.length - 1 ; }\n\t\n\tsrcX = p.srcXmin ;\n\tdstOffset = p.dstStart ;\n\t\n\t// Write existing chars\n\tfor ( ; srcX <= srcExistingXmax ; srcX ++ , dstOffset += this.ScreenBuffer.prototype.ITEM_SIZE )\n\t{\n\t\tattr = attrs[ srcX ] ;\n\t\t\n\t\t// Write the attributes\n\t\tp.context.dstBuffer.writeInt32BE( attr , dstOffset ) ;\n\t\t\n\t\tcharCode = str.charCodeAt( srcX ) ;\n\t\t\n\t\tif ( charCode < 0x20 || charCode === 0x7f )\n\t\t{\n\t\t\t// Replace the control char by a white space\n\t\t\tp.context.dstBuffer.write( ' ' , dstOffset + this.ScreenBuffer.prototype.ATTR_SIZE , this.ScreenBuffer.prototype.CHAR_SIZE ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Write the character\n\t\t\tp.context.dstBuffer.write( str[ srcX ] , dstOffset + this.ScreenBuffer.prototype.ATTR_SIZE , this.ScreenBuffer.prototype.CHAR_SIZE ) ;\n\t\t}\n\t}\n\t\n\t// Write blank\n\t// Temp?\n\tattr = p.context.emptyCellAttr ;\n\tfor ( ; srcX <= p.srcXmax ; srcX ++ , dstOffset += this.ScreenBuffer.prototype.ITEM_SIZE )\n\t{\n\t\t// Write the attributes\n\t\tp.context.dstBuffer.writeInt32BE( attr , dstOffset ) ;\n\t\t\n\t\t// Write the character\n\t\tp.context.dstBuffer.write( ' ' , dstOffset + this.ScreenBuffer.prototype.ATTR_SIZE , this.ScreenBuffer.prototype.CHAR_SIZE ) ;\n\t}\n} ;\n\n\n\nTextBuffer.prototype.blitterHiddenLineIterator = function blitterHiddenLineIterator( p )\n{\n\tvar srcX , srcExistingXmax , dstOffset , attrs , attr , str , char , charCode ;\n\t\n\t//if ( ! global.deb ) { global.deb = [] ; }\n\t//global.deb.push( p ) ;\n\t\n\tchar = p.context.char ;\n\tstr = p.context.srcTextBuffer[ p.srcY ] || '' ;\n\tattrs = p.context.srcAttrBuffer[ p.srcY ] || [] ;\n\t\n\tsrcExistingXmax = p.srcXmax ;\n\t\n\tif ( srcExistingXmax >= str.length ) { srcExistingXmax = str.length - 1 ; }\n\t\n\tsrcX = p.srcXmin ;\n\tdstOffset = p.dstStart ;\n\t\n\t// Write existing chars, turn them into the hidden char\n\tfor ( ; srcX <= srcExistingXmax ; srcX ++ , dstOffset += this.ScreenBuffer.prototype.ITEM_SIZE )\n\t{\n\t\tattr = attrs[ srcX ] ;\n\t\t\n\t\t// Write the attributes\n\t\tp.context.dstBuffer.writeInt32BE( attr , dstOffset ) ;\n\t\t\n\t\t// Write the character\n\t\tp.context.dstBuffer.write( char , dstOffset + this.ScreenBuffer.prototype.ATTR_SIZE , this.ScreenBuffer.prototype.CHAR_SIZE ) ;\n\t}\n\t\n\t// Write blank\n\t// Temp?\n\tattr = p.context.emptyCellAttr ;\n\tfor ( ; srcX <= p.srcXmax ; srcX ++ , dstOffset += this.ScreenBuffer.prototype.ITEM_SIZE )\n\t{\n\t\t// Write the attributes\n\t\tp.context.dstBuffer.writeInt32BE( attr , dstOffset ) ;\n\t\t\n\t\t// Write the character\n\t\tp.context.dstBuffer.write( ' ' , dstOffset + this.ScreenBuffer.prototype.ATTR_SIZE , this.ScreenBuffer.prototype.CHAR_SIZE ) ;\n\t}\n} ;\n\n\n\n// Naive loading\nTextBuffer.prototype.load = function load( path , callback )\n{\n\tvar self = this ;\n\t\n\t/*\n\tthis.textBuffer = [] ;\n\tthis.attrBuffer = [[]] ;\n\tthis.miscBuffer = [[]] ;\n\t*/\n\t\n\tthis.textBuffer.length = 0 ;\n\t\n\tthis.attrBuffer[ 0 ] = [] ;\n\tthis.attrBuffer.length = 0 ;\n\t\n\tthis.miscBuffer[ 0 ] = [] ;\n\tthis.miscBuffer.length = 0 ;\n\t\n\t// Naive file loading, optimization are for later\n\tfs.readFile( path , function( error , data ) {\n\t\tif ( error ) { callback( error ) ; return ; }\n\t\tself.setText( data.toString() ) ;\n\t\tcallback() ;\n\t} ) ;\n} ;\n\n\n\n// Naive saving\nTextBuffer.prototype.save = function save( path , callback )\n{\n\t// Naive file saving, optimization are for later\n\tfs.writeFile( path , this.getText() , function( error ) {\n\t\tif ( error ) { callback( error ) ; return ; }\n\t\tcallback() ;\n\t} ) ;\n} ;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/autoComplete.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n/*\n\tIdeally, this should be done using a graph algorithm, but we will just brute-force it for instance...\n*/\n\nmodule.exports = function autoComplete( array , startString , returnAlternatives , prefix , postfix )\n{\n\tvar i , j , exitLoop , candidate = [] , completed = startString , hasCompleted = false ;\n\t\n\tif ( ! prefix ) { prefix = '' ; }\n\tif ( ! postfix ) { postfix = '' ; }\n\t\n\tfor ( i = 0 ; i < array.length ; i ++ )\n\t{\n\t\tif ( array[ i ].slice( 0 , startString.length ) === startString ) { candidate.push( array[ i ] ) ; }\n\t}\n\t\n\tif ( ! candidate.length ) { return prefix + completed + postfix ; }\n\t\n\tif ( candidate.length === 1 ) { return prefix + candidate[ 0 ] + postfix ; }\n\t\n\t\n\t// Multiple candidate, complete only the part they have in common\n\t\n\tj = startString.length ;\n\t\n\texitLoop = false ;\n\t\n\tfor ( j = startString.length ; j < candidate[ 0 ].length ; j ++ )\n\t{\n\t\tfor ( i = 1 ; i < candidate.length ; i ++ )\n\t\t{\n\t\t\tif ( candidate[ i ][ j ] !== candidate[ 0 ][ j ] ) { exitLoop = true ; break ; }\n\t\t}\n\t\t\n\t\tif ( exitLoop ) { break ; }\n\t\t\n\t\tcompleted += candidate[ 0 ][ j ] ;\n\t\thasCompleted = true ;\n\t}\n\t\n\tif ( returnAlternatives && ! hasCompleted )\n\t{\n\t\tcandidate.prefix = prefix ;\n\t\tcandidate.postfix = postfix ;\n\t\treturn candidate ;\n\t}\n\t\n\treturn prefix + completed + postfix ;\n} ;\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/spChars.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Characters that are hard to type\n\n\n\n// Comments explain how to type it on a linux platform, using a fr layout keyboard\n\nmodule.exports = {\n\tpassword: '●' ,\t\t// Currently: the same as blackCircle\n\t\n\tforwardSingleQuote: '´' ,\t// Altgr + ,\n\toverscore: '¯' ,\t// Altgr + Shift + $\n\tmultiply: '×' ,\t\t// Altgr + Shift + ;\n\tdivide: '÷' ,\t\t// Altgr + Shift + :\n\t\n\t// Arrows\n\tup: '↑' ,\t\t\t// Altgr + Shift + u\n\tdown: '↓' ,\t\t\t// Altgr + u\n\tleft: '←' ,\t\t\t// Altgr + y\n\tright: '→' ,\t\t// Altgr + i\n\tleftAndRight: '↔' ,\n\tupAndDown: '↕' ,\n\tupLeft: '↖' ,\n\tupRight: '↗' ,\n\tdownRight: '↘' ,\n\tdownLeft: '↙' ,\n\tupLeftAndDownRight: '⤡' ,\n\tupRightAndDownLeft: '⤢' ,\n\t\n\t// Those names are most common in the UTF-8 parlance\n\tnorthWest: '↖' ,\n\tnorthEast: '↗' ,\n\tsouthEast: '↘' ,\n\tsouthWest: '↙' ,\n\tnorthWestAndSouthEast: '⤡' ,\n\tnorthEastAndSouthWest: '⤢' ,\n\t\n\tfullBlock: '█' ,\n\tupperHalfBlock: '▀' ,\n\tlowerHalfBlock: '▄' ,\n\t\n\t// Array of 8 growing/enlarging blocks\n\tgrowingBlock: [ '▁' , '▂' , '▃' , '▄' , '▅' , '▆' , '▇' , '█' ] ,\n\tenlargingBlock: [ '▏' , '▎' , '▍' , '▌' , '▋' , '▊' , '▉' , '█' ] ,\n\t\n\tbox: {\n\t\tlight: {\n\t\t\tvertical: '│' ,\n\t\t\thorizontal: '─' ,\n\t\t\ttopLeft: '┌' ,\n\t\t\ttopRight: '┐' ,\n\t\t\tbottomLeft: '└' ,\n\t\t\tbottomRight: '┘' ,\n\t\t\ttopTee: '┬' ,\n\t\t\tbottomTee: '┴' ,\n\t\t\tleftTee: '├' ,\n\t\t\trightTee: '┤' ,\n\t\t\tcross: '┼'\n\t\t} ,\n\t\theavy: {\n\t\t\tvertical: '┃' ,\n\t\t\thorizontal: '━' ,\n\t\t\ttopLeft: '┏' ,\n\t\t\ttopRight: '┓' ,\n\t\t\tbottomLeft: '┗' ,\n\t\t\tbottomRight: '┛' ,\n\t\t\ttopTee: '┳' ,\n\t\t\tbottomTee: '┻' ,\n\t\t\tleftTee: '┣' ,\n\t\t\trightTee: '┫' ,\n\t\t\tcross: '╋'\n\t\t} ,\n\t\tdouble: {\n\t\t\tvertical: '║' ,\n\t\t\thorizontal: '═' ,\n\t\t\ttopLeft: '╔' ,\n\t\t\ttopRight: '╗' ,\n\t\t\tbottomLeft: '╚' ,\n\t\t\tbottomRight: '╝' ,\n\t\t\ttopTee: '╦' ,\n\t\t\tbottomTee: '╩' ,\n\t\t\tleftTee: '╠' ,\n\t\t\trightTee: '╣' ,\n\t\t\tcross: '╬'\n\t\t} ,\n\t\tdotted: {\n\t\t\tvertical: '┊' ,\n\t\t\thorizontal: '┄' ,\n\t\t\ttopLeft: '┌' ,\n\t\t\ttopRight: '┐' ,\n\t\t\tbottomLeft: '└' ,\n\t\t\tbottomRight: '┘' ,\n\t\t\ttopTee: '┬' ,\n\t\t\tbottomTee: '┴' ,\n\t\t\tleftTee: '├' ,\n\t\t\trightTee: '┤' ,\n\t\t\tcross: '┼'\n\t\t} ,\n\t} ,\n\t\n\tblackSquare: '■' ,\n\twhiteSquare: '□' ,\n\tblackCircle: '●' ,\n\twhiteCircle: '○' ,\n\tblackUpTriangle: '▲' ,\n\twhiteUpTriangle: '△' ,\n\tblackDownTriangle: '▼' ,\n\twhiteDownTriangle: '▽' ,\n\tblackLeftTriangle: '◀' ,\n\twhiteLeftTriangle: '◁' ,\n\tblackRightTriangle: '▶' ,\n\twhiteRightTriangle: '▷' ,\n\tblackDiamond: '◆' ,\n\twhiteDiamond: '◇' ,\n\tblackStar: '★' ,\n\twhiteStar: '☆' ,\n\tspadeSuit: '♠' ,\n\theartSuit: '♥' ,\n\tdiamondSuit: '♦' ,\n\tclubSuit: '♣' ,\n\t\n\t// Powerline specific characters (https://powerline.readthedocs.io)\n\t// It is displayed only with the appropriate font\n\tpowerline: {\n\t\tbranch: '' ,\n\t\tline: '' ,\n\t\treadOnly: '' ,\n\t\trightTriangleSeparator: '' ,\n\t\trightArrowSeparator: '',\n\t\tleftTriangleSeparator: '' ,\n\t\tleftArrowSeparator: '' ,\n\t}\n} ;\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/Terminal.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\nvar tree = require( 'tree-kit' ) ;\nvar async = require( 'async-kit' ) ;\nvar string = require( 'string-kit' ) ;\nvar punycode = require( 'punycode' ) ;\nvar NextGenEvents = require( 'nextgen-events' ) ;\n\nvar termkit = require( './termkit.js' ) ;\nvar hslConverter = require( './hslConverter.js' ) ;\n\n\n\n// This is used for adjustement of floating point value, before applying Math.floor()\nvar adjustFloor = 0.0000001 ;\n\n\n\nfunction Terminal() { throw new Error( '[terminal] Cannot create a Terminal instance directly, use termkit.createTerminal() instead.' ) ; }\nTerminal.prototype = Object.create( NextGenEvents.prototype ) ;\nTerminal.prototype.constructor = Terminal ;\nmodule.exports = Terminal ;\n\n\n\nTerminal.create = function createTerminal( createOptions )\n{\n\t// Default options...\n\tif ( ! createOptions || typeof createOptions !== 'object' ) { createOptions = {} ; }\n\tif ( ! createOptions.stdin ) { createOptions.stdin = process.stdin ; }\n\tif ( ! createOptions.stdout ) { createOptions.stdout = process.stdout ; }\n\tif ( ! createOptions.stderr ) { createOptions.stderr = process.stderr ; }\n\tif ( typeof createOptions.generic !== 'string' ) { createOptions.generic = 'xterm' ; }\n\t\n\tvar k ;\n\t\n\tvar termconfig ;\n\tvar chainable = Object.create( notChainable ) ;\n\tvar options = { on: '', off: '', params: 0, out: createOptions.stdout } ;\n\t\n\tvar term = applyEscape.bind( undefined , options ) ;\n\t\n\t// Yay, this is a nasty hack...\n\t//term.__proto__ = chainable ;\t// jshint ignore:line\n\tObject.setPrototypeOf( term , chainable ) ;\t\t// jshint ignore:line\n\tterm.apply = Function.prototype.apply ;\n\tterm.call = Function.prototype.call ;\n\t\n\t// Fix the root\n\toptions.root = term ;\n\tterm.root = term ;\n\t\n\tterm.options = options ;\n\tterm.stdin = createOptions.stdin ;\n\tterm.stdout = createOptions.stdout ;\n\tterm.stderr = createOptions.stderr ;\n\tterm.generic = createOptions.generic ;\n\tterm.appId = createOptions.appId ;\n\tterm.appName = createOptions.appName ;\n\tterm.pid = createOptions.pid ;\n\tterm.grabbing = false ;\n\tterm.timeout = 200 ;\t// 200ms timeout by default, so ssh can work without trouble\n\tterm.shutdown = false ;\n\t\n\tterm.lock = {} ;\n\t\n\t// Screen size\n\tterm.width = undefined ;\n\tterm.height = undefined ;\n\tonResize.call( term ) ;\n\tif ( term.stdout.isTTY ) { term.stdout.on( 'resize' , onResize.bind( term ) ) ; }\n\telse if ( createOptions.processSigwinch ) { process.on( 'SIGWINCH' , onResize.bind( term ) ) ; }\n\t\n\t// States\n\tterm.state = {\n\t\tfullscreen: false ,\n\t\tbutton: {\n\t\t\tleft: false,\n\t\t\tmiddle: false,\n\t\t\tright: false,\n\t\t\tother: false\n\t\t}\n\t} ;\n\t\n\t//term.couldTTY = true ;\n\t\n\tif ( term.appId )\n\t{\n\t\t// We have got the real terminal app\n\t\ttry {\n\t\t\tterm.termconfigFile = term.appId + '.js' ;\n\t\t\ttermconfig = require( './termconfig/' + term.termconfigFile ) ;\n\t\t}\n\t\tcatch ( error ) {} // Do nothing, let the next if block handle the case\n\t}\n\t\n\tif ( ! termconfig )\n\t{\n\t\t// The real terminal app is not known, or we fail to load it...\n\t\t// Fallback to the terminal generic (most of time, got from the $TERM env variable).\n\t\ttry {\n\t\t\t// If a .generic.js file exists, this is a widely used terminal generic, 'xterm' for example.\n\t\t\t// We should use this generic files because despite advertising them as 'xterm',\n\t\t\t// most terminal sucks at being truly 'xterm' compatible (only 33% to 50% of xterm capabilities\n\t\t\t// are supported, even gnome-terminal and Konsole are bad).\n\t\t\t// So we will try to maintain a fail-safe xterm generic config.\n\t\t\tterm.termconfigFile = term.generic + '.generic.js' ;\n\t\t\ttermconfig = require( './termconfig/' + term.termconfigFile ) ;\n\t\t}\n\t\tcatch ( error ) {\n\t\t\ttry {\n\t\t\t\t// No generic config exists, try a specific config\n\t\t\t\tterm.termconfigFile = term.generic + '.js' ;\n\t\t\t\ttermconfig = require( './termconfig/' + term.termconfigFile ) ;\n\t\t\t}\n\t\t\tcatch ( error ) {\n\t\t\t\t// Nothing found, fallback to the most common terminal generic\n\t\t\t\tterm.termconfigFile = 'xterm.generic.js' ;\n\t\t\t\ttermconfig = require( './termconfig/' + term.termconfigFile ) ;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//console.log( term.termconfigFile ) ;\n\t\n\t// if needed, this should be replaced by some tput commands?\n\t\n\tterm.esc = tree.extend( { deep: true } , {} , termconfig.esc ) ;\n\tterm.support = tree.extend( { deep: true } , {} , termconfig.support ) ;\n\t\n\ttree.extend(\n\t\tnull ,\t\t// Do not use deep:true here\n\t\tterm.esc ,\n\t\tpseudoEsc ,\n\t\t{\n\t\t\t// Aliases\n\t\t\tgray: term.esc.brightBlack ,\n\t\t\tbgGray: term.esc.bgBrightBlack\n\t\t}\n\t) ;\n\t\n\tterm.handler = tree.extend( null , {} , termconfig.handler ) ;\n\tterm.keymap = tree.extend( { deep: true } , {} , termconfig.keymap ) ;\n\tterm.colorRegister = tree.extend( { deep: true } , [] , defaultColorRegister , termconfig.colorRegister ) ;\n\t\n\tterm.escHandler = { root: term } ;\n\tterm.escOffHandler = { root: term } ;\n\t\n\t// reverse keymap\n\tterm.rKeymap = [] ;\n\tterm.rKeymapMaxSize = -1 ;\n\tterm.rKeymapStarter = [] ;\n\tterm.rKeymapStarterMaxSize = -1 ;\n\t\n\tObject.keys( term.keymap ).forEach( function( key ) {\n\t\t\n\t\tvar i , j , keymapObject , code , codeList = term.keymap[ key ] ;\n\t\t\n\t\tif ( ! Array.isArray( codeList ) ) { codeList = [ codeList ] ; term.keymap[ key ] = codeList ; }\n\t\t\n\t\tfor ( j = 0 ; j < codeList.length ; j ++ )\n\t\t{\n\t\t\tcode = codeList[ j ] ;\n\t\t\t\n\t\t\tif ( typeof code === 'object' )\n\t\t\t{\n\t\t\t\tkeymapObject = code ;\n\t\t\t\tkeymapObject.name = key ;\n\t\t\t\tcode = keymapObject.code ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tkeymapObject = {\n\t\t\t\t\tcode: code ,\n\t\t\t\t\tname: key ,\n\t\t\t\t\tmatches: [ key ]\n\t\t\t\t} ;\n\t\t\t\t\n\t\t\t\tterm.keymap[ key ][ j ] = { code: code } ;\n\t\t\t}\n\t\t\t\n\t\t\t// keymap handler\n\t\t\tif ( keymapObject.handler && typeof keymapObject.handler !== 'function' )\n\t\t\t{\n\t\t\t\tterm.keymap[ key ][ j ].handler = term.handler[ keymapObject.handler ] ;\n\t\t\t}\n\t\t\t\n\t\t\tif ( code )\n\t\t\t{\n\t\t\t\tif ( code.length > term.rKeymapMaxSize )\n\t\t\t\t{\n\t\t\t\t\tfor ( i = term.rKeymapMaxSize + 1 ; i <= code.length ; i ++ ) { term.rKeymap[ i ] = {} ; }\n\t\t\t\t\tterm.rKeymapMaxSize = code.length ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( term.rKeymap[ code.length ][ code ] )\n\t\t\t\t{\n\t\t\t\t\tterm.rKeymap[ code.length ][ code ].matches.push( key ) ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tterm.rKeymap[ code.length ][ code ] = keymapObject ;\n\t\t\t\t\tterm.rKeymap[ code.length ][ code ].matches = [ key ] ;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ( ! keymapObject.starter || ! keymapObject.ender || ! keymapObject.handler ) { continue ; }\n\t\t\t\t\n\t\t\t\tif ( keymapObject.starter.length > term.rKeymapStarterMaxSize )\n\t\t\t\t{\n\t\t\t\t\tfor ( i = term.rKeymapStarterMaxSize + 1 ; i <= keymapObject.starter.length ; i ++ ) { term.rKeymapStarter[ i ] = {} ; }\n\t\t\t\t\tterm.rKeymapStarterMaxSize = keymapObject.starter.length ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( term.rKeymapStarter[ keymapObject.starter.length ][ keymapObject.starter ] )\n\t\t\t\t{\n\t\t\t\t\tterm.rKeymapStarter[ keymapObject.starter.length ][ keymapObject.starter ].push( key ) ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tterm.rKeymapStarter[ keymapObject.starter.length ][ keymapObject.starter ] = [ keymapObject ] ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} ) ;\n\t\n\t\n\t// Create methods for the 'chainable' prototype\n\t\n\tObject.keys( term.esc ).forEach( function( key ) {\n\t\t\n\t\t// build-time resolution\n\t\tif ( typeof term.esc[ key ].on === 'function' ) { term.esc[ key ].on = term.esc[ key ].on.call( term ) ; }\n\t\tif ( typeof term.esc[ key ].off === 'function' ) { term.esc[ key ].off = term.esc[ key ].off.call( term ) ; }\n\t\t\n\t\t// dynamic handler\n\t\tif ( term.esc[ key ].handler )\n\t\t{\n\t\t\tif ( typeof term.esc[ key ].handler === 'function' ) { term.escHandler[ key ] = term.esc[ key ].handler.bind( term ) ; }\n\t\t\telse { term.escHandler[ key ] = term.handler[ term.esc[ key ].handler ] ; }\n\t\t}\n\t\t\n\t\t// dynamic off handler\n\t\tif ( term.esc[ key ].offHandler )\n\t\t{\n\t\t\tif ( typeof term.esc[ key ].offHandler === 'function' ) { term.escOffHandler[ key ] = term.esc[ key ].offHandler.bind( term ) ; }\n\t\t\telse { term.escOffHandler[ key ] = term.handler[ term.esc[ key ].offHandler ] ; }\n\t\t}\n\t\t\n\t\tObject.defineProperty( chainable , key , {\n\t\t\tconfigurable: true ,\n\t\t\tget: function () {\n\t\t\t\tvar fn , options = {} ;\n\t\t\t\t\n\t\t\t\toptions = tree.extend( null , {} , this.options ) ;\n\t\t\t\t\n\t\t\t\toptions.on += this.root.esc[ key ].on || '' ;\n\t\t\t\toptions.off = ( this.root.esc[ key ].off || '' ) + options.off ;\n\t\t\t\toptions.params += string.format.count( this.root.esc[ key ].on ) ;\n\t\t\t\t\n\t\t\t\tif ( ! options.onHasFormatting &&\n\t\t\t\t\t( options.params ||\n\t\t\t\t\t\t( typeof this.root.esc[ key ].on === 'string' &&\n\t\t\t\t\t\t\tstring.format.hasFormatting( this.root.esc[ key ].on ) ) ) )\n\t\t\t\t{\n\t\t\t\t\toptions.onHasFormatting = true ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( ! options.offHasFormatting &&\n\t\t\t\t\t( typeof this.root.esc[ key ].off === 'string' &&\n\t\t\t\t\t\tstring.format.hasFormatting( this.root.esc[ key ].off ) ) )\n\t\t\t\t{\n\t\t\t\t\toptions.offHasFormatting = true ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( this.root.esc[ key ].err ) { options.err = true ; options.out = this.root.stderr ; }\n\t\t\t\tif ( this.root.esc[ key ].str ) { options.str = true ; }\n\t\t\t\tif ( this.root.esc[ key ].noFormat ) { options.noFormat = true ; }\n\t\t\t\tif ( this.root.esc[ key ].markupOnly ) { options.markupOnly = true ; }\n\t\t\t\t\n\t\t\t\tfn = applyEscape.bind( undefined , options ) ;\n\t\t\t\t\n\t\t\t\t// Yay, this is a nasty hack...\n\t\t\t\t//fn.__proto__ = chainable ;\t// jshint ignore:line\n\t\t\t\tObject.setPrototypeOf( fn , chainable ) ;\t// jshint ignore:line\n\t\t\t\tfn.apply = Function.prototype.apply ;\n\t\t\t\t\n\t\t\t\tfn.root = this.root || this ;\n\t\t\t\tfn.options = options ;\n\t\t\t\t\n\t\t\t\t// Replace the getter by the newly created function, to speed up further call\n\t\t\t\tObject.defineProperty( this , key , { value: fn } ) ;\n\t\t\t\t\n\t\t\t\t//console.log( 'Create function:' , key ) ;\n\t\t\t\t\n\t\t\t\treturn fn ;\n\t\t\t}\n\t\t} ) ;\n\t} ) ;\n\t\n\tcreateOptimized( term ) ;\n\t\n\t// Format and markup config\n\tterm.resetString = '' ;\n\tterm.setResetString = function( str ) {\n\t\tterm.resetString = string.markupMethod.call( term.formatConfig.rawMarkupConfig , str ) ;\n\t} ;\n\t\n\tvar resetFn = ( extra ) => term.str.styleReset() + term.resetString + extra ;\n\t\n\tterm.formatConfig = {\n\t\tfn: {} ,\n\t\tendingMarkupReset: true ,\n\t\tmarkupReset: resetFn.bind( undefined , '' ) ,\n\t\t//markupReset: term.str.styleReset() ,\n\t\tshiftMarkup: {\n\t\t\t'#': 'background'\n\t\t} ,\n\t\tmarkup: {\n\t\t\t\":\": resetFn.bind( undefined , '' ) ,\n\t\t\t\" \": resetFn.bind( undefined , ' ' ) ,\n\t\t\t//\":\": term.str.styleReset() ,\n\t\t\t//\" \": term.str.styleReset() + ' ' ,\n\t\t\t\n\t\t\t\"-\": term.str.dim() ,\n\t\t\t\"+\": term.str.bold() ,\n\t\t\t\"_\": term.str.underline() ,\n\t\t\t\"/\": term.str.italic() ,\n\t\t\t\"!\": term.str.inverse() ,\n\t\t\t\n\t\t\t\"b\": term.str.blue() ,\n\t\t\t\"B\": term.str.brightBlue() ,\n\t\t\t\"c\": term.str.cyan() ,\n\t\t\t\"C\": term.str.brightCyan() ,\n\t\t\t\"g\": term.str.green() ,\n\t\t\t\"G\": term.str.brightGreen() ,\n\t\t\t\"k\": term.str.black() ,\n\t\t\t\"K\": term.str.brightBlack() ,\n\t\t\t\"m\": term.str.magenta() ,\n\t\t\t\"M\": term.str.brightMagenta() ,\n\t\t\t\"r\": term.str.red() ,\n\t\t\t\"R\": term.str.brightRed() ,\n\t\t\t\"w\": term.str.white() ,\n\t\t\t\"W\": term.str.brightWhite() ,\n\t\t\t\"y\": term.str.yellow() ,\n\t\t\t\"Y\": term.str.brightYellow()\n\t\t} ,\n\t\tshiftedMarkup: {\n\t\t\tbackground: {\n\t\t\t\t\":\": resetFn.bind( undefined , '' ) ,\n\t\t\t\t\" \": resetFn.bind( undefined , ' ' ) ,\n\t\t\t\t//\":\": term.str.styleReset() ,\n\t\t\t\t//\" \": term.str.styleReset() + ' ' ,\n\t\t\t\t\n\t\t\t\t\"b\": term.str.bgBlue() ,\n\t\t\t\t\"B\": term.str.bgBrightBlue() ,\n\t\t\t\t\"c\": term.str.bgCyan() ,\n\t\t\t\t\"C\": term.str.bgBrightCyan() ,\n\t\t\t\t\"g\": term.str.bgGreen() ,\n\t\t\t\t\"G\": term.str.bgBrightGreen() ,\n\t\t\t\t\"k\": term.str.bgBlack() ,\n\t\t\t\t\"K\": term.str.bgBrightBlack() ,\n\t\t\t\t\"m\": term.str.bgMagenta() ,\n\t\t\t\t\"M\": term.str.bgBrightMagenta() ,\n\t\t\t\t\"r\": term.str.bgRed() ,\n\t\t\t\t\"R\": term.str.bgBrightRed() ,\n\t\t\t\t\"w\": term.str.bgWhite() ,\n\t\t\t\t\"W\": term.str.bgBrightWhite() ,\n\t\t\t\t\"y\": term.str.bgYellow() ,\n\t\t\t\t\"Y\": term.str.bgBrightYellow()\n\t\t\t}\n\t\t}\n\t} ;\n\t\n\tterm.formatConfig.rawMarkupConfig = Object.create( term.formatConfig ) ;\n\tterm.formatConfig.rawMarkupConfig.startingMarkupReset = false ;\n\tterm.formatConfig.rawMarkupConfig.endingMarkupReset = false ;\n\t\n\tfor ( k in term.escHandler ) { term.formatConfig.fn[ k ] = term.escHandler[ k ] ; }\n\tfor ( k in term.escOffHandler ) { term.formatConfig.fn[ k + '_off' ] = term.escOffHandler[ k ] ; }\n\t\n\tterm.format = string.formatMethod.bind( term.formatConfig ) ;\n\tterm.markup = string.markupMethod.bind( term.formatConfig ) ;\n\tterm.options = options ;\n\t\n\t\n\t// Register various exit handler\n\t// Fix the issue #3, turn grabInput off on exit\n\t// Disable input grabbing at exit.\n\t// Note: the terminal can still send some garbage if it was about to do it when exit kickin.\n\t\n\tprocess.on( 'exit' , function() {\n\t\t//console.log( '>>> exit' ) ;\n\t\tterm.shutdown = true ;\n\t\tterm.styleReset() ;\n\t\tterm.grabInput( false ) ;\n\t} ) ;\n\t\n\t// async.exit() produce this:\n\tprocess.on( 'asyncExit' , function( code , timeout , done ) {\n\t\t//console.log( '>>> exit' ) ;\n\t\tterm.asyncCleanup( done ) ;\n\t} ) ;\n\t\n\t// The event loop is empty, we have more time to clean up things:\n\t// We keep the process running for a little bit of time, to prevent the terminal from displaying garbage.\n\tprocess.once( 'beforeExit' , function() {\n\t\t//console.log( '>>> beforeExit' ) ;\n\t\tterm.asyncCleanup( function(){} ) ;\n\t} ) ;\n\t\n\treturn term ;\n} ;\n\n\n\n\n\n\t\t\t/* Optimized */\n\n\n\nfunction createOptimized( term )\n{\n\t// This is a subset of the terminal capability, mainly used to speed up ScreenBuffer\n\tvar i ;\n\t\n\tterm.optimized = {} ;\n\t\n\t// reset\n\ttree.defineLazyProperty( term.optimized , 'styleReset' , function() { return term.str.styleReset() ; } ) ;\n\t\n\t// Styles\n\ttree.defineLazyProperty( term.optimized , 'bold' , function() { return term.str.bold() ; } ) ;\n\ttree.defineLazyProperty( term.optimized , 'dim' , function() { return term.str.dim() ; } ) ;\n\ttree.defineLazyProperty( term.optimized , 'italic' , function() { return term.str.italic() ; } ) ;\n\ttree.defineLazyProperty( term.optimized , 'underline' , function() { return term.str.underline() ; } ) ;\n\ttree.defineLazyProperty( term.optimized , 'blink' , function() { return term.str.blink() ; } ) ;\n\ttree.defineLazyProperty( term.optimized , 'inverse' , function() { return term.str.inverse() ; } ) ;\n\ttree.defineLazyProperty( term.optimized , 'hidden' , function() { return term.str.hidden() ; } ) ;\n\ttree.defineLazyProperty( term.optimized , 'strike' , function() { return term.str.strike() ; } ) ;\n\t\n\ttree.defineLazyProperty( term.optimized , 'noBold' , function() { return term.str.bold( false ) ; } ) ;\n\ttree.defineLazyProperty( term.optimized , 'noDim' , function() { return term.str.dim( false ) ; } ) ;\n\ttree.defineLazyProperty( term.optimized , 'noItalic' , function() { return term.str.italic( false ) ; } ) ;\n\ttree.defineLazyProperty( term.optimized , 'noUnderline' , function() { return term.str.underline( false ) ; } ) ;\n\ttree.defineLazyProperty( term.optimized , 'noBlink' , function() { return term.str.blink( false ) ; } ) ;\n\ttree.defineLazyProperty( term.optimized , 'noInverse' , function() { return term.str.inverse( false ) ; } ) ;\n\ttree.defineLazyProperty( term.optimized , 'noHidden' , function() { return term.str.hidden( false ) ; } ) ;\n\ttree.defineLazyProperty( term.optimized , 'noStrike' , function() { return term.str.strike( false ) ; } ) ;\n\t\n\t\n\t// Colors\n\tterm.optimized.color256 = {} ;\n\tterm.optimized.bgColor256 = {} ;\n\t\n\tfunction createColor256( index )\n\t{\n\t\ttree.defineLazyProperty( term.optimized.color256 , index , function() { return term.str.color256( index ) ; } ) ;\n\t}\n\t\n\tfunction createBgColor256( index )\n\t{\n\t\ttree.defineLazyProperty( term.optimized.bgColor256 , index , function() { return term.str.bgColor256( index ) ; } ) ;\n\t}\n\t\n\tfor ( i = 0 ; i <= 255 ; i ++ )\n\t{\n\t\tcreateColor256( i ) ;\n\t\tcreateBgColor256( i ) ;\n\t}\n\t\n\t\n\t// Move To\n\tterm.optimized.moveTo = term.esc.moveTo.optimized || term.str.moveTo ;\n\t\n\t// 24 bits colors\n\tterm.optimized.color24bits = term.esc.color24bits.optimized || term.str.color24bits ;\n\tterm.optimized.bgColor24bits = term.esc.bgColor24bits.optimized || term.str.bgColor24bits ;\n}\n\n\n\n\n\n\t\t\t/* Apply */\n\n\n\n// CAUTION: 'options' MUST NOT BE OVERWRITTEN!\n// It is binded at the function creation and contains function specificities!\nfunction applyEscape( options )\n{\n\tif ( options.root.shutdown && ! options.str ) { return options.root ; }\n\t\n\tvar onFormat = [ options.on ] , output , on , off ;\n\t\n\tvar action = arguments[ 1 + options.params ] ;\n\t\n\t// If not enough arguments, return right now\n\t// Well... what about term.up(), term.previousLine(), and so on?\n\t//if ( arguments.length < 1 + options.params && ( action === null || action === false ) ) { return options.root ; }\n\t\n\tif ( options.params )\n\t{\n\t\tonFormat = onFormat.concat( Array.prototype.slice.call( arguments , 1 , 1 + options.params ) ) ;\n\t}\n\t\n\t//console.log( '\\n>>> Action:' , action , '<<<\\n' ) ;\n\t//console.log( 'Attributes:' , attributes ) ;\n\tif ( action === undefined || action === true )\n\t{\n\t\ton = options.onHasFormatting ? options.root.format.apply( undefined , onFormat ) : options.on ;\n\t\tif ( options.str ) { return on ; }\n\t\toptions.out.write( on ) ;\n\t\treturn options.root ;\n\t}\n\t\n\tif ( action === null || action === false )\n\t{\n\t\toff = options.offHasFormatting ? options.root.format( options.off ) : options.off ;\n\t\tif ( options.str ) { return off ; }\n\t\toptions.out.write( off ) ;\n\t\treturn options.root ;\n\t}\n\t\n\tif ( typeof action !== 'string' )\n\t{\n\t\tif ( typeof action.toString === 'function' ) { action = action.toString() ; }\n\t\telse { action = '' ; }\n\t}\n\t\n\t// So we have got a string\n\t\n\ton = options.onHasFormatting ? options.root.format.apply( undefined , onFormat ) : options.on ;\n\t\n\tif ( options.markupOnly )\n\t{\n\t\taction = options.root.markup.apply( undefined , Array.prototype.slice.call( arguments , 1 + options.params ) ) ;\n\t}\n\telse if ( ! options.noFormat )\n\t{\n\t\taction = options.root.format.apply( undefined , Array.prototype.slice.call( arguments , 1 + options.params ) ) ;\n\t}\n\t\n\toff = options.offHasFormatting ? options.root.format( options.off ) : options.off ;\n\t\n\tif ( options.root.resetString )\n\t{\n\t\toutput = options.root.resetString + on + action + off + options.root.resetString ;\n\t}\n\telse\n\t{\n\t\toutput = on + action + off ;\n\t}\n\t\n\t// tmp hack?\n\tif ( options.crlf ) { output = output.replace( /\\n/g , '\\r\\n' ) ; }\n\t\n\tif ( options.str ) { return output ; }\n\t\n\toptions.out.write( output ) ;\n\t\n\treturn options.root ;\n}\n\n\n\n\n\n\t\t\t/* Pseudo esc */\n\n\n\nvar pseudoEsc = {\n\t// It just set error:true so it will write to STDERR instead of STDOUT\n\terror: { err: true } ,\n\t\n\t// It just set str:true so it will not write anything, but return the value in a string\n\tstr: { str: true } ,\n\t\n\t// It just set attr:true so it will not write anything, but return an attribute object\n\tattr: { attr: true } ,\n\t\n\t// It just set noFormat:true so it will not call string.format() on user input,\n\t// only useful for ScreenBuffer, so blit-like redraw() can perform slightly faster\n\tnoFormat: { noFormat: true } ,\n\tmarkupOnly: { markupOnly: true } ,\n\t\n\tmove: {\n\t\ton: '%[move:%a%a]F' ,\n\t\thandler: function move( x , y ) {\n\t\t\t\n\t\t\tvar sequence = '' ;\n\t\t\t\n\t\t\tif ( x )\n\t\t\t{\n\t\t\t\tif ( x > 0 ) { sequence += this.root.format( this.root.esc.right.on , x ) ; }\n\t\t\t\telse { sequence += this.root.format( this.root.esc.left.on , -x ) ; }\n\t\t\t}\n\t\t\t\n\t\t\tif ( y )\n\t\t\t{\n\t\t\t\tif ( y > 0 ) { sequence += this.root.format( this.root.esc.down.on , y ) ; }\n\t\t\t\telse { sequence += this.root.format( this.root.esc.up.on , -y ) ; }\n\t\t\t}\n\t\t\t\n\t\t\treturn sequence ;\n\t\t}\n\t} ,\n\t\n\tcolor: {\n\t\ton: '%[color:%a]F' ,\n\t\toff: function() { return this.root.esc.defaultColor.on ; } ,\n\t\thandler: function color( c )\n\t\t{\n\t\t\tif ( typeof c !== 'number' ) { return '' ; }\n\t\t\t\n\t\t\tc = Math.floor( c ) ;\n\t\t\t\n\t\t\tif ( c < 0 || c > 15 ) { return '' ; }\n\t\t\t\n\t\t\tif ( c <= 7 ) { return this.root.format( this.root.esc.darkColor.on , c ) ; }\n\t\t\telse { return this.root.format( this.root.esc.brightColor.on , c - 8 ) ; }\n\t\t}\n\t} ,\n\t\n\tbgColor: {\n\t\ton: '%[bgColor:%a]F' ,\n\t\toff: function() { return this.root.esc.bgDefaultColor.on ; } ,\n\t\thandler: function bgColor( c )\n\t\t{\n\t\t\tif ( typeof c !== 'number' ) { return '' ; }\n\t\t\t\n\t\t\tc = Math.floor( c ) ;\n\t\t\t\n\t\t\tif ( c < 0 || c > 15 ) { return '' ; }\n\t\t\t\n\t\t\tif ( c <= 7 ) { return this.root.format( this.root.esc.bgDarkColor.on , c ) ; }\n\t\t\telse { return this.root.format( this.root.esc.bgBrightColor.on , c - 8 ) ; }\n\t\t}\n\t} ,\n\t\n\tcolorRgb: {\n\t\ton: '%[colorRgb:%a%a%a]F' ,\n\t\toff: function() { return this.root.esc.defaultColor.on ; } ,\n\t\thandler: colorRgbHandler\n\t\t\n\t} ,\n\t\n\tbgColorRgb: {\n\t\ton: '%[bgColorRgb:%a%a%a]F' ,\n\t\toff: function() { return this.root.esc.bgDefaultColor.on ; } ,\n\t\thandler: bgColorRgbHandler\n\t} ,\n\t\n\tcolorRgbHex: {\n\t\ton: '%[colorRgbHex:%a]F' ,\n\t\toff: function() { return this.root.esc.defaultColor.on ; } ,\n\t\thandler: colorRgbHandler\n\t\t\n\t} ,\n\t\n\tbgColorRgbHex: {\n\t\ton: '%[bgColorRgbHex:%a]F' ,\n\t\toff: function() { return this.root.esc.bgDefaultColor.on ; } ,\n\t\thandler: bgColorRgbHandler\n\t} ,\n\t\n\tcolorGrayscale: {\n\t\ton: '%[colorGrayscale:%a]F' ,\n\t\toff: function() { return this.root.esc.defaultColor.on ; } ,\n\t\thandler: function colorGrayscale( g )\n\t\t{\n\t\t\tvar c ;\n\t\t\t\n\t\t\tif ( typeof g !== 'number' ) { return '' ; }\n\t\t\tif ( g < 0 || g > 255 ) { return '' ; }\n\t\t\t\n\t\t\tif ( ! this.root.esc.color24bits.na && ! this.root.esc.color24bits.fb )\n\t\t\t{\n\t\t\t\t// The terminal supports 24bits! Yeah!\n\t\t\t\treturn this.root.format( this.root.esc.color24bits.on , g , g , g ) ;\n\t\t\t}\n\t\t\t\n\t\t\tif ( ! this.root.esc.color256.na && ! this.root.esc.color256.fb )\n\t\t\t{\n\t\t\t\t// The terminal supports 256 colors\n\t\t\t\t\n\t\t\t\t// Convert to 0..25 range\n\t\t\t\tg = Math.floor( g * 26 / 256 + adjustFloor ) ;\n\t\t\t\t\n\t\t\t\tif ( g < 0 || g > 25 ) { return '' ; }\n\t\t\t\t\n\t\t\t\tif ( g === 0 ) { c = 16 ; }\n\t\t\t\telse if ( g === 25 ) { c = 231 ; }\n\t\t\t\telse { c = g + 231 ; }\n\t\t\t\t\n\t\t\t\treturn this.root.format( this.root.esc.color256.on , c ) ;\n\t\t\t}\n\t\t\t\n\t\t\t// The terminal does not support 256 colors, fallback\n\t\t\tc = this.root.registerForRgb( g , g , g , 0 , 15 ) ;\n\t\t\treturn this.root.format( this.root.esc.color.on , c ) ;\n\t\t}\n\t} ,\n\t\n\tbgColorGrayscale: {\n\t\ton: '%[bgColorGrayscale:%a]F' ,\n\t\toff: function() { return this.root.esc.bgDefaultColor.on ; } ,\n\t\thandler: function bgColorGrayscale( g )\n\t\t{\n\t\t\tvar c ;\n\t\t\t\n\t\t\tif ( typeof g !== 'number' ) { return '' ; }\n\t\t\tif ( g < 0 || g > 255 ) { return '' ; }\n\t\t\t\n\t\t\tif ( ! this.root.esc.bgColor24bits.na && ! this.root.esc.bgColor24bits.fb )\n\t\t\t{\n\t\t\t\t// The terminal supports 24bits! Yeah!\n\t\t\t\treturn this.root.format( this.root.esc.bgColor24bits.on , g , g , g ) ;\n\t\t\t}\n\t\t\t\n\t\t\tif ( ! this.root.esc.bgColor256.na && ! this.root.esc.bgColor256.fb )\n\t\t\t{\n\t\t\t\t// Convert to 0..25 range\n\t\t\t\t//console.log( '-- ' , g , g * 26 / 256 , Math.floor( g * 26 / 256 ) , Math.floor( g * 26 / 256 + adjustFloor ) ) ;\n\t\t\t\tg = Math.floor( g * 26 / 256 + adjustFloor ) ;\n\t\t\t\t\n\t\t\t\tif ( g < 0 || g > 25 ) { return '' ; }\n\t\t\t\t\n\t\t\t\tif ( g === 0 ) { c = 16 ; }\n\t\t\t\telse if ( g === 25 ) { c = 231 ; }\n\t\t\t\telse { c = g + 231 ; }\n\t\t\t\t\n\t\t\t\treturn this.root.format( this.root.esc.bgColor256.on , c ) ;\n\t\t\t}\n\t\t\t\n\t\t\t// The terminal does not support 256 colors, fallback\n\t\t\tc = this.root.registerForRgb( g , g , g , 0 , 15 ) ;\n\t\t\treturn this.root.format( this.root.esc.bgColor.on , c ) ;\n\t\t}\n\t}\n\t\n} ;\n\n\n\n\n\n\t\t\t/* Internal/private functions */\n\n\n\nfunction colorRgbHandler( r , g , b )\n{\n\tvar c , rgb ;\n\t\n\tif ( typeof r === 'string' )\n\t{\n\t\trgb = termkit.hexToColor( r ) ;\n\t\tr = rgb.r ; g = rgb.g ; b = rgb.b ;\n\t}\n\t\n\tif ( \n\t\ttypeof r !== 'number' || isNaN( r ) ||\n\t\ttypeof g !== 'number' || isNaN( g ) ||\n\t\ttypeof b !== 'number' || isNaN( b ) ||\n\t\tr < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255\n\t)\n\t{\n\t\treturn '' ;\n\t}\n\t\n\tif ( ! this.root.esc.color24bits.na && ! this.root.esc.color24bits.fb )\n\t{\n\t\t// The terminal supports 24bits! Yeah!\n\t\treturn this.root.format( this.root.esc.color24bits.on , r , g , b ) ;\n\t}\n\t\n\tif ( ! this.root.esc.color256.na && ! this.root.esc.color256.fb )\n\t{\n\t\t// The terminal supports 256 colors\n\t\t\n\t\t// Convert to 0..5 range\n\t\tr = Math.floor( r * 6 / 256 + adjustFloor ) ;\n\t\tg = Math.floor( g * 6 / 256 + adjustFloor ) ;\n\t\tb = Math.floor( b * 6 / 256 + adjustFloor ) ;\n\t\t\n\t\tc = Math.floor( 16 + r * 36 + g * 6 + b ) ;\n\t\t\n\t\t// min:16 max:231\n\t\t//if ( c < 16 || c > 231 ) { return '' ; }\n\t\t\n\t\treturn this.root.format( this.root.esc.color256.on , c ) ;\n\t}\n\t\n\t// The terminal does not support 256 colors, fallback\n\tc = this.root.registerForRgb( r , g , b , 0 , 15 ) ;\n\treturn this.root.format( this.root.esc.color.on , c ) ;\n}\n\n\n\nfunction bgColorRgbHandler( r , g , b )\n{\n\tvar c , rgb ;\n\t\n\tif ( typeof r === 'string' )\n\t{\n\t\trgb = termkit.hexToColor( r ) ;\n\t\tr = rgb.r ; g = rgb.g ; b = rgb.b ;\n\t}\n\t\n\tif ( \n\t\ttypeof r !== 'number' || isNaN( r ) ||\n\t\ttypeof g !== 'number' || isNaN( g ) ||\n\t\ttypeof b !== 'number' || isNaN( b ) ||\n\t\tr < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255\n\t)\n\t{\n\t\treturn '' ;\n\t}\n\t\n\tif ( ! this.root.esc.bgColor24bits.na && ! this.root.esc.bgColor24bits.fb )\n\t{\n\t\t// The terminal supports 24bits! Yeah!\n\t\treturn this.root.format( this.root.esc.bgColor24bits.on , r , g , b ) ;\n\t}\n\t\n\tif ( ! this.root.esc.bgColor256.na && ! this.root.esc.bgColor256.fb )\n\t{\n\t\t// The terminal supports 256 colors\n\t\t\n\t\t// Convert to 0..5 range\n\t\tr = Math.floor( r * 6 / 256 + adjustFloor ) ;\n\t\tg = Math.floor( g * 6 / 256 + adjustFloor ) ;\n\t\tb = Math.floor( b * 6 / 256 + adjustFloor ) ;\n\t\t\n\t\tc = Math.floor( 16 + r * 36 + g * 6 + b ) ;\n\t\t\n\t\t// min:16 max:231\n\t\t//if ( c < 16 || c > 231 ) { return '' ; }\n\t\t\n\t\treturn this.root.format( this.root.esc.bgColor256.on , c ) ;\n\t}\n\t\n\t// The terminal does not support 256 colors, fallback\n\tc = this.root.registerForRgb( r , g , b , 0 , 15 ) ;\n\treturn this.root.format( this.root.esc.bgColor.on , c ) ;\n}\n\n\n\n// Called by either SIGWINCH signal or stdout's 'resize' event.\n// It is not meant to be used by end-user.\nfunction onResize()\n{\n\tif ( this.stdout.getWindowSize )\n\t{\n\t\tvar windowSize = this.stdout.getWindowSize() ;\n\t\tthis.width = windowSize[ 0 ] ;\n\t\tthis.height = windowSize[ 1 ] ;\n\t}\n\t\n\tthis.emit( 'resize' , this.width , this.height ) ;\n}\n\n\n\n\n\n\t\t\t/* Advanced methods */\n\n\n\n// Complexes functions that cannot be chained.\n// It is the ancestors of the terminal object, so it should inherit from async.EventEmitter.\nvar notChainable = Object.create( Terminal.prototype ) ;\n\n\n\n// Complexes high-level features have their own file\nnotChainable.yesOrNo = require( './yesOrNo.js' ) ;\nnotChainable.inputField = require( './inputField.js' ) ;\nnotChainable.fileInput = require( './fileInput.js' ) ;\nnotChainable.singleLineMenu = require( './singleLineMenu.js' ) ;\nnotChainable.progressBar = require( './progressBar.js' ) ;\nnotChainable.slowTyping = require( './slowTyping.js' ) ;\n\n\n\nnotChainable.createDocument = function createDocument( options ) {\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\toptions.outputDst = this ;\n\toptions.eventSource = this ;\n\treturn termkit.Document.create( options ) ;\n} ;\n\n\n\n// Fail-safe alternate screen buffer\nnotChainable.fullscreen = function fullscreen( options )\n{\n\tif ( options === false )\n\t{\n\t\tif ( ! this.state.fullscreen ) { return this ; }\n\t\t\n\t\t// Disable fullscreen mode\n\t\tthis.state.fullscreen = false ;\n\t\tthis.moveTo( 1 , this.height , '\\n' ) ;\n\t\tthis.alternateScreenBuffer( false ) ;\n\t\treturn this ;\n\t}\n\t\n\tif ( ! options ) { options = {} ; }\n\t\n\tthis.state.fullscreen = true ;\n\tif ( ! options.noAlternate ) { this.alternateScreenBuffer( true ) ; }\n\tthis.clear() ;\n} ;\n\n\n\n\n\n\t\t\t/* Input management */\n\n\n\nfunction onStdin( chunk )\n{\n\tvar i , j , buffer , startBuffer , char , codepoint ,\n\t\tkeymapCode , keymapStartCode , keymap , keymapList ,\n\t\tregexp , matches , bytes , found , handlerResult ,\n\t\tindex = 0 , length = chunk.length ;\n\t\n\tif ( this.shutdown ) { return ; }\n\t\n\twhile ( index < length )\n\t{\n\t\tfound = false ;\n\t\tbytes = 1 ;\n\t\t\n\t\tif ( chunk[ index ] <= 0x1f || chunk[ index ] === 0x7f )\n\t\t{\n\t\t\t// Those are ASCII control character and DEL key\n\t\t\t\n\t\t\tfor ( i = Math.min( length , Math.max( this.rKeymapMaxSize , this.rKeymapStarterMaxSize ) ) ; i > 0 ; i -- )\n\t\t\t{\n\t\t\t\tbuffer = chunk.slice( index ) ;\n\t\t\t\tkeymapCode = buffer.toString() ;\n\t\t\t\tstartBuffer = chunk.slice( index , index + i ) ;\n\t\t\t\tkeymapStartCode = startBuffer.toString() ;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif ( this.rKeymap[ i ] && this.rKeymap[ i ][ keymapStartCode ] )\n\t\t\t\t{\n\t\t\t\t\t// First test fixed sequences\n\t\t\t\t\t\n\t\t\t\t\tkeymap = this.rKeymap[ i ][ keymapStartCode ] ;\n\t\t\t\t\tfound = true ;\n\t\t\t\t\t\n\t\t\t\t\tif ( keymap.handler )\n\t\t\t\t\t{\n\t\t\t\t\t\thandlerResult = keymap.handler.call( this , keymap.name , chunk.slice( index + i ) ) ;\n\t\t\t\t\t\tbytes = i + handlerResult.eaten ;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( ! handlerResult.disable )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.emit( keymap.event , handlerResult.name , handlerResult.data ) ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( keymap.event )\n\t\t\t\t\t{\n\t\t\t\t\t\tbytes = i ;\n\t\t\t\t\t\tthis.emit( keymap.event , keymap.name , keymap.data , { code: startBuffer } ) ;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbytes = i ;\n\t\t\t\t\t\tthis.emit( 'key' , keymap.name , keymap.matches , { isCharacter: false , code: startBuffer } ) ;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbreak ;\n\t\t\t\t}\n\t\t\t\telse if ( this.rKeymapStarter[ i ] && this.rKeymapStarter[ i ][ keymapStartCode ] )\n\t\t\t\t{\n\t\t\t\t\t// Then test pattern sequences\n\t\t\t\t\t\n\t\t\t\t\tkeymapList = this.rKeymapStarter[ i ][ keymapStartCode ] ;\n\t\t\t\t\t\n\t\t\t\t\t//console.log( 'for i:' , keymapList ) ;\n\t\t\t\t\t\n\t\t\t\t\tfor ( j = 0 ; j < keymapList.length ; j ++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tkeymap = keymapList[ j ] ;\n\t\t\t\t\t\t\n\t\t\t\t\t\tregexp = '^' +\n\t\t\t\t\t\t\tstring.escape.regExp( keymap.starter ) +\n\t\t\t\t\t\t\t'([ -~]*)' +\t// [ -~] match only all ASCII non-control character\n\t\t\t\t\t\t\tstring.escape.regExp( keymap.ender ) ;\n\t\t\t\t\t\t\n\t\t\t\t\t\tmatches = keymapCode.match( new RegExp( regexp ) , 'g' ) ;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//console.log( 'for j:' , keymap , regexp , matches ) ;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( matches )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfound = true ;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\thandlerResult = keymap.handler.call( this , keymap.name , matches[ 1 ] ) ;\n\t\t\t\t\t\t\tbytes = matches[ 0 ].length ;\n\t\t\t\t\t\t\tthis.emit( keymap.event , handlerResult.name , handlerResult.data ) ;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ( found ) { break ; }\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Nothing was found, so to not emit trash, we just abort the current buffer processing\n\t\t\tif ( ! found ) { this.emit( 'unknown' , chunk ) ; return ; }\n\t\t}\n\t\telse if ( chunk[ index ] >= 0x80 )\n\t\t{\n\t\t\t// Unicode bytes per char guessing\n\t\t\tif ( chunk[ index ] < 0xc0 ) { continue ; }\t// We are in a middle of an unicode multibyte sequence... Something fails somewhere, we will just continue for now...\n\t\t\telse if ( chunk[ index ] < 0xe0 ) { bytes = 2 ; }\n\t\t\telse if ( chunk[ index ] < 0xf0 ) { bytes = 3 ; }\n\t\t\telse if ( chunk[ index ] < 0xf8 ) { bytes = 4 ; }\n\t\t\telse if ( chunk[ index ] < 0xfc ) { bytes = 5 ; }\n\t\t\telse { bytes = 6 ; }\n\t\t\t\n\t\t\tbuffer = chunk.slice( index , index + bytes ) ;\n\t\t\tchar = buffer.toString( 'utf8' ) ;\n\t\t\t\n\t\t\tif ( bytes > 2 ) { codepoint = punycode.ucs2.decode( char )[ 0 ] ; }\n\t\t\telse { codepoint = char.charCodeAt( 0 ) ; }\n\t\t\t\n\t\t\tthis.emit( 'key' , char , [ char ] , { isCharacter: true , codepoint: codepoint , code: buffer } ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Standard ASCII\n\t\t\tchar = String.fromCharCode( chunk[ index ] ) ;\n\t\t\tthis.emit( 'key' , char , [ char ] , { isCharacter: true , codepoint: chunk[ index ] , code: chunk[ index ] } ) ;\n\t\t}\n\t\t\n\t\tindex += bytes ;\n\t}\n}\n\n\n\nnotChainable.grabInput = function grabInput( options )\n{\n\tif ( ! this.onStdin ) { this.onStdin = onStdin.bind( this ) ; }\n\t\n\t// RESET\n\tthis.mouseButton.mouseDrag.mouseMotion.mouseSGR.focusEvent( false ) ;\n\tthis.stdin.removeListener( 'data' , this.onStdin ) ;\n\t\n\tif ( options === false )\n\t{\n\t\t// Disable grabInput mode\n\t\t\n\t\t// Very important: removing all listeners don't switch back to pause mode.\n\t\t// This is some nasty Node.js quirks (the documentation pleads for backward compatibility).\n\t\tthis.stdin.pause() ;\n\t\t\n\t\ttry {\n\t\t\tthis.stdin.setRawMode( false ) ;\n\t\t}\n\t\tcatch ( error ) {\n\t\t\t// That's not critical in any way and thus can be ignored: we are probably reading from a non-TTY\n\t\t}\n\t\t\n\t\tthis.grabbing = false ;\n\t\treturn this ;\n\t}\n\t\n\t// Should not be moved before, because shutdown typically needs .grabInput( false )\n\tif ( this.shutdown ) { return ; }\n\t\n\tthis.grabbing = true ;\n\t\n\tif ( ! options ) { options = {} ; }\n\t\n\t// SET\n\ttry {\n\t\tthis.stdin.setRawMode( true ) ;\n\t}\n\tcatch ( error ) {\n\t\t// Same here, that's not critical in any way and thus can be ignored: we are probably reading from a non-TTY\n\t}\n\t\n\tthis.stdin.on( 'data' , this.onStdin ) ;\n\t\n\t// Very important: after the first this.stdin.pause(), listening for data seems to not switch back to flowing mode.\n\t// Again, a nasty Node.js quirk.\n\tthis.stdin.resume() ;\n\t\n\tif ( options.mouse )\n\t{\n\t\tswitch ( options.mouse )\n\t\t{\n\t\t\tcase 'button' : this.mouseButton.mouseSGR() ; break ;\n\t\t\tcase 'drag' : this.mouseDrag.mouseSGR() ; break ;\n\t\t\tcase 'motion' : this.mouseMotion.mouseSGR() ; break ;\n\t\t}\n\t}\n\t\n\tif ( options.focus ) { this.focusEvent() ; }\n\t\n\treturn this ;\n} ;\n\n\n\n// Like process.exit(), but perform cleanup of the terminal first.\n// It is asynchronous, so it should be followed by a 'return' if needed.\n// A better way to handle that is to use async.exit(), that is detected by the Terminal instance.\nnotChainable.processExit = function processExit( code )\n{\n\tthis( '\\n' ) ;\n\tthis.asyncCleanup( () => process.exit( code ) ) ;\n} ;\n\n\n\nnotChainable.asyncCleanup = function asyncCleanup( callback )\n{\n\tif ( this.shutdown ) { return ; }\n\t\n\tthis.shutdown = true ;\n\tthis.styleReset() ;\n\t\n\tvar wasGrabbing = this.grabbing ;\n\t\n\tthis.waitStreamDone( this.stdout , () => {\n\t\t\n\t\tif ( wasGrabbing )\n\t\t{\n\t\t\tthis.grabInput( false ) ;\n\t\t\tasync.setSafeTimeout( callback , this.timeout / 2 ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcallback() ;\n\t\t}\n\t} ) ;\n} ;\n\n\n\nnotChainable.waitStreamDone = function waitStreamDone( stream , callback )\n{\n\tif ( ! stream._writableState.needDrain ) { callback() ; return ; }\n\tstream.once( 'drain' , callback ) ;\n} ;\n\n\n\n// A facility for those who don't want to deal with requestCursorLocation() and events...\nnotChainable.getCursorLocation = function getCursorLocation( callback )\n{\n\tvar self = this , wasGrabbing = this.grabbing , alreadyCleanedUp = false ;\n\t\n\tif ( this.shutdown ) { return ; }\n\t\n\t// Now .getCursorLocation() cannot run in concurrency anymore\n\tif ( this.lock.getCursorLocation )\n\t{\n\t\tthis.once( 'unlock_getCursorLocation' , getCursorLocation.bind( this , callback ) ) ;\n\t\treturn ;\n\t}\n\t\n\tthis.lock.getCursorLocation = true ;\n\t\n\tvar cleanup = function( error , x , y ) {\n\t\t\n\t\tif ( alreadyCleanedUp ) { return ; }\n\t\talreadyCleanedUp = true ;\n\t\t\n\t\tself.removeListener( 'terminal' , onTerminal ) ;\n\t\tif ( ! wasGrabbing ) { self.grabInput( false ) ; }\n\t\t\n\t\tif ( error ) { callback( error ) ; }\n\t\telse { callback( undefined , x , y ) ; }\n\t} ;\n\t\n\tvar onTerminal = function onTerminal( name , data ) {\n\t\t\n\t\tif ( name !== 'CURSOR_LOCATION' ) { return ; }\n\t\tself.lock.getCursorLocation = false ;\n\t\tself.emit( 'unlock_getCursorLocation' ) ;\n\t\tcleanup( undefined , data.x , data.y ) ;\n\t} ;\n\t\n\tif ( ! wasGrabbing ) { this.grabInput() ; }\n\t\n\tthis.requestCursorLocation() ;\n\tthis.on( 'terminal' , onTerminal ) ;\n\t\n\tasync.setSafeTimeout( cleanup.bind( undefined , new Error( '.getCursorLocation() timed out' ) ) , this.timeout ) ;\n} ;\n\n\n\nnotChainable.object2attr = function object2attr( object )\n{\n\tvar attr = this.esc.styleReset.on ;\n\t\n\tif ( ! object || typeof object !== 'object' ) { object = {} ; }\n\t\n\t// Color part\n\tif ( typeof object.color === 'string' ) { object.color = termkit.color2index( object.color ) ; }\n\tif ( typeof object.color !== 'number' || object.color < 0 || object.color > 255 ) { object.color = 7 ; }\n\telse { object.color = Math.floor( object.color ) ; }\n\t\n\tattr += this.str.color( object.color ) ;\n\t\n\t// Background color part\n\tif ( typeof object.bgColor === 'string' ) { object.bgColor = termkit.color2index( object.bgColor ) ; }\n\tif ( typeof object.bgColor !== 'number' || object.bgColor < 0 || object.bgColor > 255 ) { object.bgColor = 0 ; }\n\telse { object.bgColor = Math.floor( object.bgColor ) ; }\n\t\n\tattr += this.str.bgColor( object.bgColor ) ;\n\t\n\t// Style part\n\tif ( object.bold ) { attr += this.esc.bold.on ; }\n\tif ( object.dim ) { attr += this.esc.dim.on ; }\n\tif ( object.italic ) { attr += this.esc.italic.on ; }\n\tif ( object.underline ) { attr += this.esc.underline.on ; }\n\tif ( object.blink ) { attr += this.esc.blink.on ; }\n\tif ( object.inverse ) { attr += this.esc.inverse.on ; }\n\tif ( object.hidden ) { attr += this.esc.hidden.on ; }\n\tif ( object.strike ) { attr += this.esc.strike.on ; }\n\t\n\treturn attr ;\n} ;\n\n\n\n// Get the RGB value for a color register\nnotChainable.getColor = function getColor( register , callback )\n{\n\tvar self = this , wasGrabbing = this.grabbing , alreadyCleanedUp = false ;\n\t\n\tif ( this.shutdown ) { return ; }\n\t\n\t// First, check capabilities:\n\tif ( this.esc.requestColor.na ) { callback( new Error( 'Terminal is not capable' ) ) ; return ; }\n\t\n\tvar cleanup = function( error , data ) {\n\t\t\n\t\tif ( alreadyCleanedUp ) { return ; }\n\t\talreadyCleanedUp = true ;\n\t\t\n\t\tself.removeListener( 'terminal' , onTerminal ) ;\n\t\tif ( ! wasGrabbing ) { self.grabInput( false ) ; }\n\t\t\n\t\tif ( error ) { callback( error ) ; }\n\t\telse { callback( undefined , data ) ; }\t//data.r , data.g , data.b ) ;\n\t} ;\n\t\n\tvar onTerminal = function onTerminal( name , data ) {\n\t\t\n\t\tif ( name !== 'COLOR_REGISTER' ) { return ; }\n\t\t\n\t\t// We have got a color definition, but this is not for our register, so this is not our response\n\t\tif ( data.register !== register ) { return ; }\n\t\t\n\t\t// This is a good opportunity to update the color register\n\t\tif ( register < 16 ) { self.colorRegister[ register ] = { r: data.r , g: data.g , b: data.b } ; }\n\t\t\n\t\t// Everything is fine...\n\t\tcleanup( undefined , data ) ;\n\t} ;\n\t\n\tif ( ! wasGrabbing ) { self.grabInput() ; }\n\t\n\tself.requestColor( register ) ;\n\tself.on( 'terminal' , onTerminal ) ;\n\t\n\tasync.setSafeTimeout( cleanup.bind( undefined , new Error( '.getColor() timed out.' ) ) , this.timeout ) ;\n} ;\n\n\n\n// Get the current 16 colors palette of the terminal, if possible\nnotChainable.getPalette = function getPalette( callback )\n{\n\tvar self = this , wasGrabbing = this.grabbing ;\n\t\n\tif ( this.shutdown ) { return ; }\n\t\n\tif ( ! wasGrabbing ) { this.grabInput() ; }\n\t\n\t// First, check capabilities, if not capable, return the default palette\n\tif ( this.esc.requestColor.na ) { callback( undefined , this.colorRegister.slice( 0 , 16 ) ) ; return ; }\n\t\n\tasync.map(\n\t\t[ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 ] ,\n\t\tself.getColor.bind( self )\n\t)\n\t.exec( function( error , palette ) {\n\t\tif ( ! wasGrabbing ) { self.grabInput( false ) ; }\n\t\tif ( error ) { callback( error ) ; return ; }\n\t\tcallback( undefined , palette ) ;\n\t} ) ;\n} ;\n\n\n\n// Set the color for a register\nnotChainable.setColor = function setColor( register , r , g , b , names )\n{\n\tif ( r && typeof r === 'object' )\n\t{\n\t\tb = r.b ;\n\t\tg = r.g ;\n\t\tr = r.r ;\n\t\tnames = g ;\n\t}\n\t\n\t// Allow modification of register > 15 ?\n\tif ( typeof register !== 'number' || register < 0 || register > 15 ) { throw new Error( 'Bad register value' ) ; }\n\t\n\tif ( ! Array.isArray( names ) ) { names = [] ; }\n\t\n\tif (\n\t\ttypeof r !== 'number' || r < 0 || r > 255 ||\n\t\ttypeof g !== 'number' || g < 0 || g > 255 ||\n\t\ttypeof b !== 'number' || b < 0 || b > 255\n\t)\n\t{\n\t\tthrow new Error( 'Bad RGB value' ) ;\n\t}\n\t\n\t// Issue an error, or not?\n\tif ( this.setColorLL.na ) { return ; }\n\t\n\t// This is a good opportunity to update the color register\n\tthis.colorRegister[ register ] = { r: r , g: g , b: b , names: names } ;\n\t\n\t// Call the Low Level set color\n\tthis.setColorLL( register , r , g , b ) ;\n} ;\n\n\n\n// Set the current 16 colors palette of the terminal, if possible\nnotChainable.setPalette = function setPalette( palette )\n{\n\tvar i ;\n\t\n\tif ( typeof palette === 'string' )\n\t{\n\t\ttry {\n\t\t\tpalette = require( './colorScheme/' + palette + '.json' ) ;\n\t\t}\n\t\tcatch( error ) {\n\t\t\tthrow new Error( '[terminal] .setPalette(): color scheme not found: ' + palette ) ;\n\t\t}\n\t}\n\t\n\tif ( ! Array.isArray( palette ) ) { throw new Error( '[terminal] .setPalette(): argument #0 should be an Array of RGB Object or a built-in color scheme' ) ; }\n\t\n\t// Issue an error, or not?\n\tif ( this.setColorLL.na ) { return ; }\n\t\n\tfor ( i = 0 ; i <= 15 ; i ++ )\n\t{\n\t\tif ( ! palette[ i ] || typeof palette[ i ] !== 'object' ) { continue ; }\n\t\tthis.setColor( i , palette[ i ] ) ;\n\t}\n} ;\n\n\n\n\n\n\t\t\t/* Utilities */\n\n\n\n// Default colors, used for guessing\nvar defaultColorRegister = require( './colorScheme/default.json' ) ;\n\n( function buildDefaultColorRegister()\n{\n\tvar register , offset , factor , l ;\n\t\n\tfor ( register = 16 ; register < 232 ; register ++ )\n\t{\n\t\t// RGB 6x6x6\n\t\toffset = register - 16 ;\n\t\tfactor = 255 / 5 ;\n\t\tdefaultColorRegister[ register ] = {\n\t\t\tr: Math.floor( ( Math.floor( offset / 36 + adjustFloor ) % 6 ) * factor + adjustFloor ) ,\n\t\t\tg: Math.floor( ( Math.floor( offset / 6 + adjustFloor ) % 6 ) * factor + adjustFloor ) ,\n\t\t\tb: Math.floor( ( offset % 6 ) * factor + adjustFloor ) ,\n\t\t\tnames: []\n\t\t} ;\n\t}\n\t\n\tfor ( register = 232 ; register <= 255 ; register ++ )\n\t{\n\t\t// Grayscale 0..23\n\t\toffset = register - 231 ;\t// not 232, because the first of them is not a #000000 black\n\t\tfactor = 255 / 25 ;\t// not 23, because the last is not a #ffffff white\n\t\tl = Math.floor( offset * factor + adjustFloor ) ;\n\t\tdefaultColorRegister[ register ] = { r: l , g: l , b: l , names: [] } ;\n\t}\n} )() ;\n\n\n\n// If register hasn't changed, this is used to get the RGB value for them\nnotChainable.rgbForRegister = function rgbForRegister( register )\n{\n\tif ( register < 0 || register > 255 ) { throw new Error( 'Bad register value' ) ; }\n\t\n\t// Simply clone it\n\treturn {\n\t\tr: this.colorRegister[ register ].r ,\n\t\tg: this.colorRegister[ register ].g ,\n\t\tb: this.colorRegister[ register ].b\n\t} ;\n} ;\n\n\n\n// If register hasn't changed, this is used to get it for an RGB\n// .registerForRgb( r , g , b , [minRegister] , [maxRegister] )\n// .registerForRgb( rgbObject , [minRegister] , [maxRegister] )\n\n// HSL cylinder coordinate distance\nnotChainable.registerForRgb = function registerForRgb( r , g , b , minRegister , maxRegister , lFactor )\n{\n\t// Manage function arguments\n\t\n\tif ( r && typeof r === 'object' )\n\t{\n\t\t// Manage the .registerForRgb( rgbObject , [minRegister] , [maxRegister] ) variante\n\t\tmaxRegister = b ;\n\t\tminRegister = g ;\n\t\tb = r.b ;\n\t\tg = r.g ;\n\t\tr = r.r ;\n\t}\n\t\n\tif (\n\t\ttypeof r !== 'number' || r < 0 || r > 255 ||\n\t\ttypeof g !== 'number' || g < 0 || g > 255 ||\n\t\ttypeof b !== 'number' || b < 0 || b > 255\n\t)\n\t{\n\t\tthrow new Error( 'Bad RGB value' ) ;\n\t}\n\t\n\tif ( typeof maxRegister !== 'number' || maxRegister < 0 || maxRegister > 255 ) { maxRegister = 15 ; }\n\tif ( typeof minRegister !== 'number' || minRegister < 0 || minRegister > 255 ) { minRegister = 0 ; }\n\tif ( typeof lFactor !== 'number' ) { lFactor = 1 ; }\n\t\n\tif ( minRegister > maxRegister )\n\t{\n\t\tvar tmp ;\n\t\ttmp = maxRegister ;\n\t\tmaxRegister = minRegister ;\n\t\tminRegister = tmp ;\n\t}\n\t\n\t\n\t// Search for the best match\n\t\n\t// Transform HSL to cylender\n\t\n\tvar x , y , z , xR , yR , zR , dx , dy , dz ,\n\t\tregisterHsl , register , diff ,\n\t\tminDiff = Infinity , hsl = hslConverter.rgb2hsl( r , g , b ) ;\n\t\n\tx = hsl.s * Math.cos( hsl.h * 2 * Math.PI ) ;\n\ty = hsl.s * Math.sin( hsl.h * 2 * Math.PI ) ;\n\tz = hsl.l * lFactor ;\n\t\n\t//console.log( 'HSL:' , hsl ) ;\n\t\n\tfor ( register = minRegister ; register <= maxRegister ; register ++ )\n\t{\n\t\tregisterHsl = hslConverter.rgb2hsl( this.colorRegister[ register ] ) ;\n\t\t\n\t\txR = registerHsl.s * Math.cos( registerHsl.h * 2 * Math.PI ) ;\n\t\tyR = registerHsl.s * Math.sin( registerHsl.h * 2 * Math.PI ) ;\n\t\tzR = registerHsl.l ;\n\t\t\n\t\t//console.log( 'Register HSL:' , registerHsl ) ;\n\t\t\n\t\tdx = Math.abs( x - xR ) ;\n\t\tdy = Math.abs( y - yR ) ;\n\t\tdz = Math.abs( z - zR ) ;\n\t\t\n\t\tdiff = dx * dx + dy * dy + dz * dz ;\n\t\t\n\t\t//console.log( 'delta:' , dh , ds , dl , diff ) ;\n\t\t\n\t\tif ( diff < minDiff )\n\t\t{\n\t\t\tminDiff = diff ;\n\t\t\tminRegister = register ;\n\t\t}\n\t}\n\t\n\treturn minRegister ;\n} ;\n\n\n\n\n\n\t\t\t/* ScreenBuffer compatible methods */\n\n\n\n// Cursor is always drawn so there is nothing to do here\nnotChainable.drawCursor = function drawCursor() {} ;\n\nnotChainable.put = function put( options , str )\n{\n\tvar i , x , y , dx , dy , attr , wrap , characters , len , moveToNeeded , inline ;\n\t\n\t// Manage options\n\tif ( ! options ) { options = {} ; }\n\t\n\twrap = options.wrap === undefined ? true : options.wrap ;\n\t\n\tx = options.x || 0 ;\n\ty = options.y || 0 ;\n\t\n\tif ( typeof x !== 'number' || x < 1 ) { x = 1 ; }\n\telse if ( x > this.width ) { x = this.width ; }\n\telse { x = Math.floor( x ) ; }\n\t\n\tif ( typeof y !== 'number' || y < 1 ) { y = 1 ; }\n\telse if ( y > this.height ) { y = this.height ; }\n\telse { y = Math.floor( y ) ; }\n\t\n\t\n\t// Process directions/increments\n\tdx = 1 ;\n\tdy = 0 ;\n\t\n\tswitch ( options.direction )\n\t{\n\t\t//case 'right' : // not needed, use the default dx & dy\n\t\tcase 'left' :\n\t\t\tdx = -1 ;\n\t\t\tbreak ;\n\t\tcase 'up' :\n\t\t\tdx = 0 ;\n\t\t\tdy = -1 ;\n\t\t\tbreak ;\n\t\tcase 'down' :\n\t\t\tdx = 0 ;\n\t\t\tdy = 1 ;\n\t\t\tbreak ;\n\t\tcase null :\n\t\tcase 'none' :\n\t\t\tdx = 0 ;\n\t\t\tdy = 0 ;\n\t\t\tbreak ;\n\t}\n\t\n\tif ( typeof options.dx === 'number' ) { dx = options.dx ; }\n\tif ( typeof options.dy === 'number' ) { dy = options.dy ; }\n\t\n\tinline = ( dx === 1 && dy === 0 ) ;\n\t\n\t\n\t// Process attributes\n\tattr = options.attr || this.esc.styleReset.on ;\n\t\n\tif ( attr && typeof attr === 'object' ) { attr = this.object2attr( attr ) ; }\n\tif ( typeof attr !== 'string' ) { attr = this.esc.styleReset.on ; }\n\t\n\t\n\t// Process the input string\n\tif ( typeof str !== 'string' )\n\t{\n\t\tif ( str.toString ) { str = str.toString() ; }\n\t\telse { return ; }\n\t}\n\t\n\tif ( arguments.length > 2 ) { str = string.format.apply( undefined , Array.prototype.slice.call( arguments , 1 ) ) ; }\n\tstr = termkit.stripControlChars( str ) ;\n\t\n\t// /!\\ Fix that punycode thing, and don't forget to fix ScreenBuffer#put() too... /!\\\n\tcharacters = punycode.ucs2.decode( str ) ;\n\tlen = characters.length ;\n\t\n\tmoveToNeeded = true ;\n\tthis.stdout.write( attr ) ;\n\t\n\tfor ( i = 0 ; i < len ; i ++ )\n\t{\n\t\tif ( moveToNeeded ) { this.moveTo( x , y ) ; }\n\t\tthis( punycode.ucs2.encode( [ characters[ i ] ] ) ) ;\n\t\t\n\t\tx += dx ;\n\t\ty += dy ;\n\t\t\n\t\tmoveToNeeded = ! inline ;\n\t\t\n\t\tif ( x < 0 )\n\t\t{\n\t\t\tif ( ! wrap ) { break ; }\n\t\t\tx = this.width - 1 ;\n\t\t\ty -- ;\n\t\t\tmoveToNeeded = true ;\n\t\t}\n\t\telse if ( x >= this.width )\n\t\t{\n\t\t\tif ( ! wrap ) { break ; }\n\t\t\tx = 0 ;\n\t\t\ty ++ ;\n\t\t\tmoveToNeeded = true ;\n\t\t}\n\t\t\n\t\tif ( y < 0 ) { break ; }\n\t\telse if ( y >= this.height ) { break ; }\n\t}\n} ;\n\n\n\nnotChainable.drawNdarrayImage = function drawNdarrayImage( pixels , options )\n{\n\tvar x , xMax = Math.min( pixels.shape[ 0 ] , this.width ) ,\n\t\ty , yMax = Math.ceil( pixels.shape[ 1 ] / 2 ) ,\n\t\thasAlpha = pixels.shape[ 2 ] === 4 ,\n\t\tmaxRegister = this.support['256colors'] ? 255 : 15 ,\n\t\tfgColor , bgColor , fgAlpha , bgAlpha ;\n\t\n\t\n\tfor ( y = 0 ; y < yMax ; y ++ )\n\t{\n\t\tfor ( x = 0 ; x < xMax ; x ++ )\n\t\t{\n\t\t\tif ( this.support['24bitsColors'] )\n\t\t\t{\n\t\t\t\tfgAlpha = hasAlpha ? pixels.get( x , y * 2 , 3 ) / 255 : 1 ;\n\t\t\t\t\n\t\t\t\tif ( y * 2 + 1 < pixels.shape[ 1 ] )\n\t\t\t\t{\n\t\t\t\t\tbgAlpha = hasAlpha ? pixels.get( x , y * 2 + 1 , 3 ) / 255 : 1 ;\n\t\t\t\t\t\n\t\t\t\t\tthis.noFormat(\n\t\t\t\t\t\tthis.optimized.color24bits(\n\t\t\t\t\t\t\tMath.round( fgAlpha * pixels.get( x , y * 2 , 0 ) ) ,\n\t\t\t\t\t\t\tMath.round( fgAlpha * pixels.get( x , y * 2 , 1 ) ) ,\n\t\t\t\t\t\t\tMath.round( fgAlpha * pixels.get( x , y * 2 , 2 ) )\n\t\t\t\t\t\t) +\n\t\t\t\t\t\tthis.optimized.bgColor24bits(\n\t\t\t\t\t\t\tMath.round( bgAlpha * pixels.get( x , y * 2 + 1 , 0 ) ) ,\n\t\t\t\t\t\t\tMath.round( bgAlpha * pixels.get( x , y * 2 + 1 , 1 ) ) ,\n\t\t\t\t\t\t\tMath.round( bgAlpha * pixels.get( x , y * 2 + 1 , 2 ) )\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t'▀'\n\t\t\t\t\t) ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.noFormat(\n\t\t\t\t\t\tthis.optimized.color24bits(\n\t\t\t\t\t\t\tMath.round( fgAlpha * pixels.get( x , y * 2 , 0 ) ) ,\n\t\t\t\t\t\t\tMath.round( fgAlpha * pixels.get( x , y * 2 , 1 ) ) ,\n\t\t\t\t\t\t\tMath.round( fgAlpha * pixels.get( x , y * 2 , 2 ) )\n\t\t\t\t\t\t) +\n\t\t\t\t\t\tthis.optimized.bgColor24bits( 0 , 0 , 0 ) +\n\t\t\t\t\t\t'▀'\n\t\t\t\t\t) ;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfgColor = hasAlpha && pixels.get( x , y * 2 , 3 ) < 127 ?\n\t\t\t\t\t0 :\n\t\t\t\t\tthis.registerForRgb(\n\t\t\t\t\t\tpixels.get( x , y * 2 , 0 ) ,\n\t\t\t\t\t\tpixels.get( x , y * 2 , 1 ) ,\n\t\t\t\t\t\tpixels.get( x , y * 2 , 2 ) ,\n\t\t\t\t\t\t0 , maxRegister\n\t\t\t\t\t) ;\n\t\t\t\t\n\t\t\t\tif ( y * 2 + 1 < pixels.shape[ 1 ] )\n\t\t\t\t{\n\t\t\t\t\tbgColor = hasAlpha && pixels.get( x , y * 2 + 1 , 3 ) < 127 ?\n\t\t\t\t\t\t0 :\n\t\t\t\t\t\tthis.registerForRgb(\n\t\t\t\t\t\t\tpixels.get( x , y * 2 + 1 , 0 ) ,\n\t\t\t\t\t\t\tpixels.get( x , y * 2 + 1 , 1 ) ,\n\t\t\t\t\t\t\tpixels.get( x , y * 2 + 1 , 2 ) ,\n\t\t\t\t\t\t\t0 , maxRegister\n\t\t\t\t\t\t) ;\n\t\t\t\t\t\n\t\t\t\t\tthis.noFormat( this.optimized.color256[ fgColor ] + this.optimized.bgColor256[ bgColor ] + '▀' ) ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.noFormat( this.optimized.color256[ fgColor ] + this.optimized.bgColor256[ 0 ] + '▀' ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.styleReset()( '\\n' ) ;\n\t}\n} ;\n\n\n\nnotChainable.drawImage = function drawImage( filepath , options , callback )\n{\n\treturn termkit.image.load.call( this , notChainable.drawNdarrayImage.bind( this ) , filepath , options , callback ) ;\n} ;\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/hslConverter.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n/*\n\tRGB <-> HSL convertor, adaptated from Garry Tan code, found here:\n\thttp://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c\n*/\n\n\"use strict\" ;\n\n\n\n/*\n\tConverts an RGB color value to HSL.\n\tConversion formula adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n\tAssumes r, g, and b are contained in the set [0, 255] and returns h, s, and l in the set [0, 1].\n\t\n\trgb2hsl( r , g , b )\n\trgb2hsl( rgb )\n*/\nexports.rgb2hsl = function rgb2hsl( r , g , b )\n{\n\tif ( typeof r === 'object' )\n\t{\n\t\tb = r.b ;\n\t\tg = r.g ;\n\t\tr = r.r ;\n\t}\n\t\n\tr /= 255 ;\n\tg /= 255 ;\n\tb /= 255 ;\n\t\n\tvar max = Math.max( r , g , b ) ;\n\tvar min = Math.min( r , g , b ) ;\n\tvar hsl = {} ;\n\t\n\thsl.l = ( max + min ) / 2 ;\n\t\n\tif ( max === min )\n\t{\n\t\thsl.h = hsl.s = 0 ; // achromatic\n\t}\n\telse\n\t{\n\t\tvar diff = max - min ;\n\t\thsl.s = hsl.l > 0.5 ? diff / ( 2 - max - min ) : diff / ( max + min ) ;\n\t\t\n\t\tswitch( max )\n\t\t{\n\t\t\tcase r :\n\t\t\t\thsl.h = ( g - b ) / diff + ( g < b ? 6 : 0 ) ;\n\t\t\t\tbreak ;\n\t\t\tcase g :\n\t\t\t\thsl.h = ( b - r ) / diff + 2 ;\n\t\t\t\tbreak ;\n\t\t\tcase b :\n\t\t\t\thsl.h = ( r - g ) / diff + 4 ;\n\t\t\t\tbreak ;\n\t\t}\n\t\t\n\t\thsl.h /= 6 ;\n\t}\n\t\n\treturn hsl ;\n} ;\n\n\n\n/*\n\tConverts an RGB color value to HSL.\n\tConversion formula adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n\tAssumes r, g, and b are contained in the set [0, 255] and returns h, s, and l in the set [0, 1].\n\t\n\thsl2rgb( h , s , l)\n\thsl2rgb( hsl )\n*/\nexports.hsl2rgb = function hsl2rgb( h , s , l )\n{\n\tif ( typeof h === 'object' )\n\t{\n\t\tl = h.l ;\n\t\ts = h.s ;\n\t\th = h.h ;\n\t}\n\t\n\tvar r , g , b ;\n\t\n\tif( s === 0 )\n\t{\n\t\tr = g = b = l ; // achromatic\n\t}\n\telse\n\t{\n\t\t\n\t\tvar q = l < 0.5 ? l * ( 1 + s ) : l + s - l * s ;\n\t\tvar p = 2 * l - q ;\n\t\tr = hue2rgb( p , q , h + 1 / 3 ) ;\n\t\tg = hue2rgb( p , q , h ) ;\n\t\tb = hue2rgb( p , q , h - 1 / 3 ) ;\n\t}\n\t\n\treturn {\n\t\tr: r * 255 ,\n\t\tg: g * 255 ,\n\t\tb: b * 255\n\t} ;\n} ;\n\n\n\nfunction hue2rgb( p , q , t )\n{\n\tif ( t < 0 ) { t += 1 ; }\n\tif ( t > 1 ) { t -= 1 ; }\n\tif ( t < 1 / 6 ) { return p + ( q - p ) * 6 * t ; }\n\tif ( t < 1 / 2 ) { return q ; }\n\tif ( t < 2 / 3 ) { return p + ( q - p ) * ( 2 / 3 - t ) * 6 ; }\n\t\n\treturn p ;\n}\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/yesOrNo.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n/*\n\tyesOrNo( [yes] , [no] , callback )\n\t\t* options `Object`\n\t\t\t* yes `string` or `Array` contains a key code or an array of key code that will trigger the yes\n\t\t\t* no `string` or `Array` contains a key code or an array of key code that will trigger the no\n\t\t\t* echoYes `string` if defined this will be what will be outputed in case of yes\n\t\t\t* echoNo `string` if defined this will be what will be outputed in case of no\n\t\t* callback( error , result )\n\t\t\t* result: true for 'yes' or false for 'no'\n*/\nmodule.exports = function yesOrNo( options , callback )\n{\n\tif ( arguments.length <= 0 ) { throw new Error( '[terminal] yesOrNo(): should at least provide one callback as argument' ) ; }\n\tif ( arguments.length === 1 ) { callback = options ; options = undefined ; }\n\t\n\tif ( ! options || typeof options !== 'object' )\n\t{\n\t\toptions = {\n\t\t\tyes: [ 'y' , 'Y' ] ,\n\t\t\tno: [ 'n' , 'N' ] ,\n\t\t\techoYes: 'yes' ,\n\t\t\techoNo: 'no'\n\t\t} ;\n\t}\n\t\n\tif ( typeof options.yes === 'string' ) { options.yes = [ options.yes ] ; }\n\tif ( ! Array.isArray( options.yes ) ) { options.yes = [ 'y' , 'Y' ] ; }\n\t\n\tif ( typeof options.no === 'string' ) { options.no = [ options.no ] ; }\n\tif ( ! Array.isArray( options.no ) ) { options.no = [ 'n' , 'N' ] ; }\n\t\n\tif ( ! this.grabbing ) { this.grabInput() ; }\n\t\n\tvar self = this ;\n\t\n\tvar onKey = function( key ) {\n\t\t\n\t\tif ( options.yes.indexOf( key ) !== -1 )\n\t\t{\n\t\t\tif ( options.echoYes ) { self( options.echoYes ) ; }\n\t\t\tself.removeListener( 'key' , onKey ) ;\n\t\t\tcallback( undefined , true ) ;\n\t\t}\n\t\telse if ( options.no.indexOf( key ) !== -1 )\n\t\t{\n\t\t\tif ( options.echoNo ) { self( options.echoNo ) ; }\n\t\t\tself.removeListener( 'key' , onKey ) ;\n\t\t\tcallback( undefined , false ) ;\n\t\t}\n\t} ;\n\t\n\tthis.on( 'key' , onKey ) ;\n\t\n\tvar controller = {} ; //Object.create( NextGenEvents.prototype ) ;\n\t\n\t// Stop everything and do not even call the callback\n\tcontroller.abort = function abort() {\n\t\tself.removeListener( 'key' , onKey ) ;\n\t} ;\n\t\n\treturn controller ;\n} ;\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/inputField.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\n//var events = require( 'events' ) ;\nvar NextGenEvents = require( 'nextgen-events' ) ;\nvar string = require( 'string-kit' ) ;\nvar autoComplete = require( './autoComplete.js' ) ;\nvar ScreenBuffer = require( './ScreenBuffer.js' ) ;\nvar TextBuffer = require( './TextBuffer.js' ) ;\n\n\n\nvar defaultInlineKeyBindings = {\n\tENTER: 'submit' ,\n\tKP_ENTER: 'submit' ,\n\tESCAPE: 'cancel' ,\n\tBACKSPACE: 'backDelete' ,\n\tDELETE: 'delete' ,\n\tLEFT: 'backward' ,\n\tRIGHT: 'forward' ,\n\tUP: 'historyPrevious' ,\n\tDOWN: 'historyNext' ,\n\tHOME: 'startOfInput' ,\n\tEND: 'endOfInput' ,\n\tTAB: 'autoComplete' ,\n\tCTRL_LEFT: 'previousWord' ,\n\tCTRL_RIGHT: 'nextWord' ,\n\tCTRL_U: 'deleteAllBefore' ,\n\tCTRL_K: 'deleteAllAfter'\n} ;\n\n\n\nvar defaultAreaKeyBindings = {\n\tENTER: 'submit' ,\n\tKP_ENTER: 'submit' ,\n\tESCAPE: 'cancel' ,\n\tBACKSPACE: 'backDelete' ,\n\tDELETE: 'delete' ,\n\tLEFT: 'backward' ,\n\tRIGHT: 'forward' ,\n\tUP: 'up' ,\n\tDOWN: 'down' ,\n\tHOME: 'startOfLine' ,\n\tEND: 'endOfLine' ,\n\tTAB: 'autoComplete'\n} ;\n\n\n\nvar defaultTokenRegExp = /\\S+/g ;\n\n\n\n/*\n\tinputField( [options] , callback )\n\t\t* options `Object` where:\n\t\t\t* echo `boolean` if true (the default), input are displayed on the terminal\n\t\t\t* default `string` default input/placeholder\n\t\t\t* cancelable `boolean` if true (default: false), it is cancelable by user using the cancel key (default: ESC),\n\t\t\t  thus will return null\n\t\t\t* style `Function` style used, default to the terminal instance (no style)\n\t\t\t* hintStyle `Function` style used for hint (auto-completion preview), default to `terminal.brightBlack` (gray)\n\t\t\t* maxLength `number` maximum length of the input\n\t\t\t* minLength `number` minimum length of the input\n\t\t\t* history `Array` (optional) an history array, so UP and DOWN keys move up and down in the history\n\t\t\t* autoComplete `Array` or `Function( inputString , [callback] )` (optional) an array of possible completion,\n\t\t\t  so the TAB key will auto-complete the input field. If it is a function, it should accept an input `string`\n\t\t\t  and return the completed `string` (if no completion can be done, it should return the input string,\n\t\t\t  if multiple candidate are possible, it should return an array of string), if **the function accepts 2 arguments**\n\t\t\t  (checked using *function*.length), then **the auto-completer will be asynchronous**!\n\t\t\t\t/!\\ Also, if autoCompleteMenu is set and the array contains a special property 'prefix', it will be prepended\n\t\t\t\tafter autoCompleteMenu()!\n\t\t\t* autoCompleteMenu `boolean` or `Object` of options, used in conjunction with the 'autoComplete' options, if *truthy*\n\t\t\t  any auto-complete attempt having many completion candidates will display a menu to let the user choose between each\n\t\t\t  possibilities. If an object is given, it should contain options for the [.singleLineMenu()](#ref.singleLineMenu)\n\t\t\t  that is used for the completion (notice: some options are overwritten: 'y' and 'exitOnUnexpectedKey')\n\t\t\t* autoCompleteHint `boolean` if true (default: false) use the hintStyle to write the auto-completion preview\n\t\t\t  at the right of the input\n\t\t\t* keyBindings `Object` overide default key bindings\n\t\t\t* area `Object` define a rectangular area for the inputField, where\n\t\t\t\t* x `number` x coordinate of the top-left corner\n\t\t\t\t* y `number` y coordinate of the top-left corner\n\t\t\t\t* width `number` width of the area\n\t\t\t\t* height `number`  height of the area\n\t\t\t\t* textAttr `Object` an attr object for text cells\n\t\t\t\t* emptyAttr `Object` an attr object for empty cells\n\t\t\t* tokenHook `Function( token , isEndOfInput , previousTokens , term , config )` this is a hook called for each\n\t\t\t  token of the input, where:\n\t\t\t\t* token `String` is the current token\n\t\t\t\t* isEndOfInput `boolean` true if this is the **last token and if it ends the input string**\n\t\t\t\t  (e.g. it is possible for the last token to be followed by some blank char, in that case *isEndOfInput*\n\t\t\t\t  would be false)\n\t\t\t\t* previousTokens `Array` of `String` is a array containing all tokens before the current one\n\t\t\t\t* term is a Terminal instance\n\t\t\t\t* config `Object` is an object containing dynamic settings that can be altered by the hook, where:\n\t\t\t\t\t* style `Function` style in use (see the *style* option)\n\t\t\t\t\t* hintStyle `Function` style in use for hint (see the *hintStyle* option)\n\t\t\t\t\t* tokenRegExp `RegExp` the regexp in use for tokenization (see the *tokenRegExp* option)\n\t\t\t\t\t* autoComplete `Array` or `Function( inputString , [callback] )` (see the *autoComplete* option)\n\t\t\t\t\t* autoCompleteMenu `boolean` or `Object` (see the *autoCompleteMenu* option)\n\t\t\t\t\t* autoCompleteHint `boolean` enable/disable the auto-completion preview (see the *autoCompleteHint* option)\n\t\t\t  The config settings are always reset on new input, on new tokenization pass.\n\t\t\t  The hook can return a *style* (`Function`, like the *style* option) that will be used to print that token.\n\t\t\t  Used together, this can achieve syntax hilighting, as well as dynamic behavior suitable for a shell.\n\t\t\t  Finally, it can return a string, styled or not, that will be displayed in place of that token,\n\t\t\t  useful if the token should have multiple styles (but that string **MUST** contains the same number of\n\t\t\t  printable character, or it would lead hazardous behavior).\n\t\t\t* tokenResetHook `Function( term , config )` this is a hook called before the first token\n\t\t\t* tokenRegExp `RegExp` this is the regex used to tokenize the input, by default a token is space-delimited,\n\t\t\t  so \"one two three\" would be tokenized as [ \"one\" , \"two\" , \"three\" ].\n\t\t* callback( error , input )\n\t\t\t* error `mixed` truthy if an underlying error occurs\n\t\t\t* input `string` the user input\n*/\nmodule.exports = function inputField( options , callback )\n{\n\tif ( arguments.length <= 0 ) { throw new Error( '[terminal] .inputField(): should at least provide one callback as argument' ) ; }\n\tif ( arguments.length === 1 ) { callback = options ; options = {} ; }\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tif ( options.echo === undefined ) { options.echo = true ; }\n\t\n\tif ( typeof options.maxLength !== 'number' ) { options.maxLength = Infinity ; }\n\tif ( typeof options.minLength !== 'number' ) { options.minLength = 0 ; }\n\t\n\tif ( options.autoCompleteMenu )\n\t{\n\t\tif ( typeof options.autoCompleteMenu !== 'object' ) { options.autoCompleteMenu = {} ; }\n\t\toptions.autoCompleteMenu.exitOnUnexpectedKey = true ;\n\t\tdelete options.autoCompleteMenu.y ;\n\t}\n\t\n\tif ( ! this.grabbing ) { this.grabInput() ; }\n\t\n\t\n\t\n\tvar self = this , controller , finished = false , pause = false , alreadyCleanedUp = false ,\n\t\toffset = 0 , echo = !! options.echo ,\n\t\tkeyBindings ,\n\t\tstart = {} , end = {} , cursor = {} , endHint = {} ,\n\t\tinputs = [] , inputIndex ,\n\t\tinlineMode , screenBuffer , textBuffer , textAttr ,\n\t\talwaysRedraw = options.tokenHook || options.autoCompleteHint ,\n\t\thint = [] ;\n\t\n\tvar dynamic = {\n\t\tstyle: options.style || self ,\n\t\thintStyle: options.hintStyle || self.brightBlack ,\n\t\ttokenRegExp: options.tokenRegExp || defaultTokenRegExp ,\n\t\tautoComplete: options.autoComplete ,\n\t\tautoCompleteMenu: options.autoCompleteMenu ,\n\t\tautoCompleteHint: !! options.autoCompleteHint\n\t} ;\n\t\n\t\n\t\n\t// Now inputs is an array of input, input being an array of char (thanks to JS using UCS-2 instead of UTF-8)\n\t\n\tif ( Array.isArray( options.history ) )\n\t{\n\t\tinputs = options.history.map( function( str ) {\n\t\t\treturn string.unicode.toArray( str ).slice( 0 , options.maxLength ) ;\n\t\t} ) ;\n\t}\n\t\n\t\n\tif ( options.default && typeof options.default === 'string' )\n\t{\n\t\tinputs.push( string.unicode.toArray( options.default ).slice( 0 , options.maxLength ) ) ;\n\t}\n\telse\n\t{\n\t\tinputs.push( [] ) ;\n\t}\n\t\n\t\n\tinputIndex = inputs.length - 1 ;\n\toffset = inputs[ inputIndex ].length ;\n\t\n\t\n\t\n\tvar init = function init()\n\t{\n\t\tif ( options.area )\n\t\t{\n\t\t\tinlineMode = false ;\n\t\t\t\n\t\t\tkeyBindings = options.keyBindings || defaultAreaKeyBindings ;\n\t\t\t\n\t\t\tscreenBuffer = ScreenBuffer.create( {\n\t\t\t\tdst: options.dst || self ,\n\t\t\t\tx: options.area.x ,\n\t\t\t\ty: options.area.y ,\n\t\t\t\twidth: options.area.width ,\n\t\t\t\theight: options.area.height\n\t\t\t} ) ;\n\t\t\t\n\t\t\ttextBuffer = TextBuffer.create( {\n\t\t\t\tdst: screenBuffer ,\n\t\t\t\tforceInBound: true\n\t\t\t} ) ;\n\t\t\t\n\t\t\tif ( options.area.emptyAttr ) { textBuffer.setEmptyCellAttr( options.area.emptyAttr ) ; }\n\t\t\tif ( options.area.textAttr ) { textAttr = ScreenBuffer.object2attr( options.area.textAttr ) ; }\n\t\t\t\n\t\t\tfinishInit() ;\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tinlineMode = true ;\n\t\t\n\t\tkeyBindings = options.keyBindings || defaultInlineKeyBindings ;\n\t\t\n\t\t// Get the cursor location before getting started\n\t\tself.getCursorLocation( function( error , x , y ) {\n\t\t\tif ( error ) { cleanup( error ) ; return ; }\n\t\t\tfinishInit( x , y ) ;\n\t\t} ) ;\n\t} ;\n\t\n\t\n\t\n\tvar finishInit = function finishInit( x , y )\n\t{\n\t\tif ( inlineMode )\n\t\t{\n\t\t\tstart.x = end.x = cursor.x = x ;\n\t\t\tstart.y = end.y = cursor.y = y ;\n\t\t\t\n\t\t\tif ( inputs[ inputIndex ].length )\n\t\t\t{\n\t\t\t\t// There is already something (placeholder, ...), so redraw now!\n\t\t\t\tif ( inlineMode ) { computeAllCoordinate() ; }\n\t\t\t\tredraw() ;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tareaDraw() ;\n\t\t}\n\t\t\n\t\tself.on( 'key' , onKey ) ;\n\t\t//controller.ready = true ;\n\t\tcontroller.emit( 'ready' ) ;\n\t} ;\n\t\n\t\n\t\n\tvar cleanup = function cleanup( error , input )\n\t{\n\t\tif ( alreadyCleanedUp ) { return ; }\n\t\talreadyCleanedUp = true ;\n\t\t\n\t\tfinished = true ;\n\t\tself.removeListener( 'key' , onKey ) ;\n\t\t\n\t\tif ( error === 'abort' ) { return ; }\n\t\t\n\t\tself.styleReset() ;\n\t\t\n\t\tif ( error ) { callback( error ) ; }\n\t\telse if ( typeof input === 'string' ) { callback( undefined , input ) ; }\n\t\telse if ( input ) { callback( undefined , input.join( '' ) ) ; }\n\t\telse { callback() ; }\n\t} ;\n\t\n\t\n\t\n\t// Compute the coordinate of the cursor and end of a string, given a start coordinate\n\tvar computeAllCoordinate = function computeAllCoordinate()\n\t{\n\t\tvar scroll ;\n\t\t\n\t\tend = offsetCoordinate( inputs[ inputIndex ].length ) ;\n\t\tendHint = offsetCoordinate( inputs[ inputIndex ].length + hint.length ) ;\n\t\t\n\t\tif ( endHint.y > self.height )\n\t\t{\n\t\t\t// We have gone out of the screen, scroll!\n\t\t\tscroll = endHint.y - self.height ;\n\t\t\t\n\t\t\tdynamic.style.noFormat( '\\n'.repeat( scroll ) ) ;\n\t\t\t\n\t\t\tstart.y -= scroll ;\n\t\t\tend.y -= scroll ;\n\t\t\tendHint.y -= scroll ;\n\t\t}\n\t\t\n\t\tcursor = offsetCoordinate( offset ) ;\n\t} ;\n\t\n\t\n\t\n\t// Compute the coordinate of an offset, given a start coordinate\n\tvar offsetCoordinate = function offsetCoordinate( offset )\n\t{\n\t\treturn {\n\t\t\tx: 1 + ( start.x + offset - 1 ) % self.width ,\n\t\t\ty: start.y + Math.floor( ( start.x + offset - 1 ) / self.width )\n\t\t} ;\n\t} ;\n\t\n\t\n\t\n\t// Compute the coordinate of the end of a string, given a start coordinate\n\tvar redraw = function redraw( extraLines )\n\t{\n\t\tvar i ;\n\t\t\n\t\tif ( ! inlineMode )\n\t\t{\n\t\t\ttextBuffer.draw() ;\n\t\t\tscreenBuffer.draw() ;\n\t\t\ttextBuffer.drawCursor() ;\n\t\t\tscreenBuffer.drawCursor() ;\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\textraLines = extraLines || 0 ;\n\t\t\n\t\tself.moveTo( start.x , start.y ) ;\n\t\t\n\t\tif ( options.tokenHook ) { writeTokens( inputs[ inputIndex ].join( '' ) ) ; }\n\t\telse { dynamic.style.noFormat( inputs[ inputIndex ].join( '' ) ) ; }\n\t\t\n\t\tclearHint() ;\n\t\t\n\t\tif ( extraLines > 0 )\n\t\t{\n\t\t\t// If the previous input was using more lines, erase them now\n\t\t\tfor ( i = 1 ; i <= extraLines ; i ++ )\n\t\t\t{\n\t\t\t\tself.moveTo( 1 , end.y + i ) ;\n\t\t\t\tdynamic.style.noFormat.eraseLineAfter( '' ) ;\n\t\t\t}\n\t\t\t\n\t\t\tself.moveTo( cursor.x , cursor.y ) ;\n\t\t}\n\t} ;\n\t\n\t\n\t\n\tvar clearHint = function clearHint()\n\t{\t\n\t\t// First, check if there are some hints to be cleared\n\t\tif ( ! dynamic.autoCompleteHint ) { return ; }\n\t\t\n\t\tvar y = end.y ;\n\t\t\n\t\tself.moveTo( end.x , end.y ) ;\n\t\tdynamic.style.noFormat.eraseLineAfter( '' ) ;\n\t\t\n\t\t// If the previous input was using more lines, erase them now\n\t\twhile ( y < endHint.y )\n\t\t{\n\t\t\ty ++ ;\n\t\t\tself.moveTo( 1 , y ) ;\n\t\t\tdynamic.style.noFormat.eraseLineAfter( '' ) ;\n\t\t}\n\t\t\n\t\tself.moveTo( cursor.x , cursor.y ) ;\n\t} ;\n\t\n\t\n\t\n\tvar areaDraw = function areaDraw()\n\t{\n\t\ttextBuffer.draw() ;\n\t\tscreenBuffer.draw() ;\n\t\ttextBuffer.drawCursor() ;\n\t\tscreenBuffer.drawCursor() ;\n\t} ;\n\t\n\t\n\t\n\tvar areaDrawCursor = function areaDrawCursor()\n\t{\n\t\ttextBuffer.drawCursor() ;\n\t\tscreenBuffer.drawCursor() ;\n\t} ;\n\t\n\t\n\t\n\t// Compute the coordinate of the end of a string, given a start coordinate\n\tvar autoCompleteMenu = function autoCompleteMenu( menu )\n\t{\n\t\tpause = true ;\n\t\t\n\t\tself.singleLineMenu( menu , dynamic.autoCompleteMenu , function( error , response ) {\n\t\t\t// Unpause unconditionnally\n\t\t\tpause = false ;\n\t\t\tif ( error ) { return ; }\n\t\t\t\n\t\t\tif ( response.selectedText )\n\t\t\t{\n\t\t\t\t// Prepend something before the text\n\t\t\t\tif ( menu.prefix ) { response.selectedText = menu.prefix + response.selectedText ; }\n\t\t\t\t\n\t\t\t\t// Append something after the text\n\t\t\t\tif ( menu.postfix ) { response.selectedText += menu.postfix ; }\n\t\t\t\t\n\t\t\t\tresponse.selectedText = string.unicode.toArray( response.selectedText ).slice( 0 , options.maxLength ) ;\n\t\t\t\t\n\t\t\t\tinputs[ inputIndex ] = response.selectedText.concat(\n\t\t\t\t\tinputs[ inputIndex ].slice( offset , options.maxLength + offset - response.selectedText.length )\n\t\t\t\t) ;\n\t\t\t\t\n\t\t\t\toffset = response.selectedText.length ;\n\t\t\t}\n\t\t\t\n\t\t\tif ( echo )\n\t\t\t{\n\t\t\t\t// Erase the menu\n\t\t\t\tself.column.eraseLineAfter( 1 ) ;\n\t\t\t\t\n\t\t\t\t// If the input field was ending on the last line, we need to move it one line up\n\t\t\t\tif ( end.y >= self.height && start.y > 1 ) { start.y -- ; }\n\t\t\t\t\n\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\tredraw() ;\n\t\t\t\tself.moveTo( cursor.x , cursor.y ) ;\n\t\t\t}\n\t\t\t\n\t\t\tif ( response.unexpectedKey && response.unexpectedKey !== 'TAB' )\n\t\t\t{\n\t\t\t\t// Forward the key to the event handler\n\t\t\t\tonKey( response.unexpectedKey , undefined , response.unexpectedKeyData ) ;\n\t\t\t}\n\t\t} ) ;\n\t} ;\n\t\n\t\n\t\n\tvar writeTokens = function writeTokens( text )\n\t{\n\t\tvar match , lastIndex , lastEndIndex = 0 , tokens = [] , tokenStyle , extra , isEndOfInput ;\n\t\t\n\t\t// Reset dynamic stuffs\n\t\tdynamic.style = options.style || self ;\n\t\tdynamic.hintStyle = options.hintStyle || self.brightBlack ;\n\t\tdynamic.tokenRegExp = options.tokenRegExp || defaultTokenRegExp ;\n\t\tdynamic.autoComplete = options.autoComplete ;\n\t\tdynamic.autoCompleteMenu = options.autoCompleteMenu ;\n\t\tdynamic.autoCompleteHint = !! options.autoCompleteHint ;\n\t\t\n\t\tdynamic.tokenRegExp.lastIndex = 0 ;\n\t\t\n\t\tif ( options.tokenResetHook ) { options.tokenResetHook( self , dynamic ) ; }\n\t\t\n\t\twhile ( ( match = dynamic.tokenRegExp.exec( text ) ) !== null )\n\t\t{\n\t\t\t// Back-up that now, since it can be modified by the hook\n\t\t\tlastIndex = dynamic.tokenRegExp.lastIndex ;\n\t\t\t\n\t\t\tif ( match.index > lastEndIndex ) { dynamic.style.noFormat( text.slice( lastEndIndex , match.index ) ) ; }\n\t\t\t\n\t\t\tisEndOfInput = match.index + match[ 0 ].length === text.length ;\n\t\t\t\n\t\t\ttokenStyle = options.tokenHook( match[ 0 ] , isEndOfInput , tokens , self , dynamic ) ;\n\t\t\t\n\t\t\tif ( typeof tokenStyle === 'function' ) { tokenStyle.noFormat( match[ 0 ] ) ; }\n\t\t\telse if ( typeof tokenStyle === 'string' ) { self.noFormat( tokenStyle ) ; }\n\t\t\telse { dynamic.style.noFormat( match[ 0 ] ) ; }\n\t\t\t\n\t\t\ttokens.push( match[ 0 ] ) ;\n\t\t\t\n\t\t\tlastEndIndex = match.index + match[ 0 ].length ;\n\t\t\t\n\t\t\t// Restore it, if it was modified\n\t\t\tdynamic.tokenRegExp.lastIndex = lastIndex ;\n\t\t}\n\t\t\n\t\tif ( lastEndIndex < text.length ) { dynamic.style.noFormat( text.slice( lastEndIndex ) ) ; }\n\t} ;\n\t\n\t\n\t\n\tvar autoCompleteHint = function autoCompleteHint()\n\t{\n\t\t// The cursor should be at the end ATM\n\t\tif ( ! dynamic.autoComplete || ! dynamic.autoCompleteHint || offset < inputs[ inputIndex ].length )\n\t\t{\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tvar autoCompleted , inputText = inputs[ inputIndex ].join( '' ) ;\n\t\t\n\t\tvar finishCompletion = function finishCompletion()\n\t\t{\n\t\t\tif ( Array.isArray( autoCompleted ) ) { return ; }\n\t\t\t\n\t\t\thint = string.unicode.toArray( autoCompleted.slice( inputText.length ) )\n\t\t\t\t.slice( 0 , options.maxLength - inputs[ inputIndex ].length ) ;\n\t\t\t\n\t\t\tcomputeAllCoordinate() ;\n\t\t\tself.moveTo( end.x , end.y ) ;\t// computeAllCoordinate() can add some newline\n\t\t\tdynamic.hintStyle.noFormat( hint.join( '' ) ) ;\n\t\t\tself.moveTo( cursor.x , cursor.y ) ;\n\t\t} ;\n\t\t\n\t\tif ( Array.isArray( dynamic.autoComplete ) )\n\t\t{\n\t\t\tautoCompleted = autoComplete( dynamic.autoComplete , inputText , dynamic.autoCompleteMenu ) ;\n\t\t}\n\t\telse if ( typeof dynamic.autoComplete === 'function' )\n\t\t{\n\t\t\tif ( dynamic.autoComplete.length === 2 )\n\t\t\t{\n\t\t\t\tdynamic.autoComplete( inputText , function( error , autoCompleted_ ) {\n\t\t\t\t\t\n\t\t\t\t\tif ( error ) { cleanup( error ) ; return ; }\n\t\t\t\t\t\n\t\t\t\t\tautoCompleted = autoCompleted_ ;\n\t\t\t\t\tfinishCompletion() ;\n\t\t\t\t} ) ;\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tautoCompleted = dynamic.autoComplete( inputText ) ;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinishCompletion() ;\n\t} ;\n\t\n\t\n\t\n\tvar onKey = function onKey( key , trash , data ) {\n\t\tif ( finished || pause ) { return ; }\n\t\t\n\t\tif ( inlineMode ) { onInlineKey( key , trash , data ) ; }\n\t\telse { onAreaKey( key , trash , data ) ; }\n\t} ;\n\t\n\t\n\t\n\t// The main method: the key event handler for the inline mode\n\tvar onInlineKey = function onInlineKey( key , trash , data ) {\n\t\t\n\t\tvar leftPart , autoCompleted , extraLines , lastOffset = offset ;\n\t\t\n\t\tif ( data && data.isCharacter )\n\t\t{\n\t\t\t// if data.isCharacter, this is a regular UTF-8 character, not a special key\n\t\t\t\n\t\t\tif ( inputs[ inputIndex ].length >= options.maxLength ) { return ; }\n\t\t\t\n\t\t\t// Insert version\n\t\t\t//inputs[ inputIndex ] = inputs[ inputIndex ].slice( 0 , offset ) + key + inputs[ inputIndex ].slice( offset ) ;\n\t\t\tinputs[ inputIndex ].splice( offset , 0 , key ) ;\n\t\t\toffset ++ ;\n\t\t\t\n\t\t\tif ( echo )\n\t\t\t{\n\t\t\t\tif ( offset === inputs[ inputIndex ].length && ! alwaysRedraw )\n\t\t\t\t{\n\t\t\t\t\tdynamic.style.noFormat( key ) ;\n\t\t\t\t\t// Now it's done by computeAllCoordinate()\n\t\t\t\t\t//if ( cursor.x >= self.width ) { dynamic.style.noFormat( '\\n' ) ; }\n\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// redraw() is mandatory in insert mode\n\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\tredraw() ;\n\t\t\t\t\tif ( dynamic.autoCompleteHint ) { autoCompleteHint() ; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Here we have a special key\n\t\t\t\n\t\t\tswitch( keyBindings[ key ] )\n\t\t\t{\n\t\t\t\tcase 'submit' :\n\t\t\t\t\tif ( inputs[ inputIndex ].length < options.minLength ) { break ; }\n\t\t\t\t\tclearHint() ;\n\t\t\t\t\tcleanup( undefined , inputs[ inputIndex ] ) ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'cancel' :\n\t\t\t\t\tif ( options.cancelable ) { cleanup() ; }\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'backDelete' :\n\t\t\t\t\tif ( inputs[ inputIndex ].length && offset > 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\t//inputs[ inputIndex ] = inputs[ inputIndex ].slice( 0 , offset - 1 ) + inputs[ inputIndex ].slice( offset ) ;\n\t\t\t\t\t\tinputs[ inputIndex ].splice( offset - 1 , 1 ) ;\n\t\t\t\t\t\toffset -- ;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( echo )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The cursor position check should happen BEFORE we modify it with computeAllCoordinate()\n\t\t\t\t\t\t\tif ( cursor.y < end.y || cursor.x === 1 || alwaysRedraw )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\t\t\t\tredraw() ;\n\t\t\t\t\t\t\t\tif ( dynamic.autoCompleteHint ) { autoCompleteHint() ; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\t\t\t\tself.backDelete() ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'delete' :\n\t\t\t\t\tif ( inputs[ inputIndex ].length && offset < inputs[ inputIndex ].length )\n\t\t\t\t\t{\n\t\t\t\t\t\t//inputs[ inputIndex ] = inputs[ inputIndex ].slice( 0 , offset ) + inputs[ inputIndex ].slice( offset + 1 ) ;\n\t\t\t\t\t\tinputs[ inputIndex ].splice( offset , 1 ) ;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( echo )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The cursor position check should happen BEFORE we modify it with computeAllCoordinate()\n\t\t\t\t\t\t\tif ( cursor.y < end.y || alwaysRedraw )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\t\t\t\tredraw() ;\n\t\t\t\t\t\t\t\tif ( dynamic.autoCompleteHint ) { autoCompleteHint() ; }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\t\t\t\tself.delete( 1 ) ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'deleteAllBefore' :\n\t\t\t\t\tif ( inputs[ inputIndex ].length && offset > 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\t//inputs[ inputIndex ] = inputs[ inputIndex ].slice( 0 , offset - 1 ) + inputs[ inputIndex ].slice( offset ) ;\n\t\t\t\t\t\tinputs[ inputIndex ].splice( 0 , offset ) ;\n\t\t\t\t\t\toffset = 0 ;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( echo )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\t\t\tredraw() ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'deleteAllAfter' :\n\t\t\t\t\tif ( inputs[ inputIndex ].length && offset < inputs[ inputIndex ].length )\n\t\t\t\t\t{\n\t\t\t\t\t\tinputs[ inputIndex ].splice( offset , inputs[ inputIndex ].length - offset ) ;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( echo )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\t\t\tredraw() ;\n\t\t\t\t\t\t\tif ( dynamic.autoCompleteHint ) { autoCompleteHint() ; }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'backward' :\n\t\t\t\t\tif ( inputs[ inputIndex ].length && offset > 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( dynamic.autoCompleteHint && offset === inputs[ inputIndex ].length )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tclearHint() ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\toffset -- ;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( echo )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\t\t\tself.moveTo( cursor.x , cursor.y ) ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'forward' :\n\t\t\t\t\tif ( inputs[ inputIndex ].length && offset < inputs[ inputIndex ].length )\n\t\t\t\t\t{\n\t\t\t\t\t\toffset ++ ;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( echo )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\t\t\tself.moveTo( cursor.x , cursor.y ) ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( dynamic.autoCompleteHint && offset === inputs[ inputIndex ].length )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tautoCompleteHint() ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'previousWord' :\n\t\t\t\t\tif ( inputs[ inputIndex ].length && offset > 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( dynamic.autoCompleteHint && offset === inputs[ inputIndex ].length )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tclearHint() ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\toffset -- ;\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile ( offset > 0 && inputs[ inputIndex ][ offset ] === ' ' ) { offset -- ; }\n\t\t\t\t\t\twhile ( offset > 0 && inputs[ inputIndex ][ offset - 1 ] !== ' ' ) { offset -- ; }\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( echo )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\t\t\tself.moveTo( cursor.x , cursor.y ) ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'nextWord' :\n\t\t\t\t\tif ( inputs[ inputIndex ].length && offset < inputs[ inputIndex ].length )\n\t\t\t\t\t{\n\t\t\t\t\t\twhile ( offset < inputs[ inputIndex ].length && inputs[ inputIndex ][ offset ] === ' ' ) { offset ++ ; }\n\t\t\t\t\t\twhile ( offset < inputs[ inputIndex ].length && inputs[ inputIndex ][ offset ] !== ' ' ) { offset ++ ; }\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( echo )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\t\t\tself.moveTo( cursor.x , cursor.y ) ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( dynamic.autoCompleteHint && offset === inputs[ inputIndex ].length )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tautoCompleteHint() ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'startOfInput' :\n\t\t\t\t\tif ( dynamic.autoCompleteHint && offset === inputs[ inputIndex ].length )\n\t\t\t\t\t{\n\t\t\t\t\t\tclearHint() ;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\toffset = 0 ;\n\t\t\t\t\t\n\t\t\t\t\tif ( echo )\n\t\t\t\t\t{\n\t\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\t\tself.moveTo( cursor.x , cursor.y ) ;\n\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'endOfInput' :\n\t\t\t\t\toffset = inputs[ inputIndex ].length ;\n\t\t\t\t\t\n\t\t\t\t\tif ( echo )\n\t\t\t\t\t{\n\t\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\t\tself.moveTo( cursor.x , cursor.y ) ;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ( dynamic.autoCompleteHint && lastOffset !== inputs[ inputIndex ].length )\n\t\t\t\t\t{\n\t\t\t\t\t\tautoCompleteHint() ;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'historyNext' :\n\t\t\t\t\tif ( inputIndex < inputs.length - 1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tinputIndex ++ ;\n\t\t\t\t\t\toffset = inputs[ inputIndex ].length ;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( echo )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\textraLines = end.y - start.y ;\n\t\t\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\t\t\textraLines -= end.y - start.y ;\n\t\t\t\t\t\t\tredraw( extraLines ) ;\n\t\t\t\t\t\t\tself.moveTo( cursor.x , cursor.y ) ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Not sure if this is desirable\n\t\t\t\t\t\t//if ( dynamic.autoCompleteHint ) { autoCompleteHint() ; }\n\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'historyPrevious' :\n\t\t\t\t\tif ( inputIndex > 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tinputIndex -- ;\n\t\t\t\t\t\toffset = inputs[ inputIndex ].length ;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( echo )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\textraLines = end.y - start.y ;\n\t\t\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\t\t\textraLines -= end.y - start.y ;\n\t\t\t\t\t\t\tredraw( extraLines ) ;\n\t\t\t\t\t\t\tself.moveTo( cursor.x , cursor.y ) ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Not sure if this is desirable\n\t\t\t\t\t\t//if ( dynamic.autoCompleteHint ) { autoCompleteHint() ; }\n\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'autoComplete' :\n\t\t\t\t\t\t\n\t\t\t\t\tif ( ! dynamic.autoComplete ) { break ; }\n\t\t\t\t\t\n\t\t\t\t\tleftPart = inputs[ inputIndex ].slice( 0 , offset ) ;\n\t\t\t\t\t\n\t\t\t\t\tvar finishCompletion = function finishCompletion()\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( Array.isArray( autoCompleted ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( dynamic.autoCompleteMenu ) { autoCompleteMenu( autoCompleted ) ; }\n\t\t\t\t\t\t\treturn ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tleftPart = string.unicode.toArray( autoCompleted ).slice( 0 , options.maxLength ) ;\n\t\t\t\t\t\t\n\t\t\t\t\t\tinputs[ inputIndex ] = leftPart.concat(\n\t\t\t\t\t\t\tinputs[ inputIndex ].slice( offset , options.maxLength + offset - leftPart.length )\n\t\t\t\t\t\t) ;\n\t\t\t\t\t\t\n\t\t\t\t\t\toffset = leftPart.length ;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( echo )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\t\t\t\tredraw() ;\n\t\t\t\t\t\t}\n\t\t\t\t\t} ;\n\t\t\t\t\t\n\t\t\t\t\tif ( Array.isArray( dynamic.autoComplete ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tautoCompleted = autoComplete( dynamic.autoComplete , leftPart.join( '' ) , dynamic.autoCompleteMenu ) ;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( typeof dynamic.autoComplete === 'function' )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( dynamic.autoComplete.length === 2 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdynamic.autoComplete( leftPart.join( '' ) , function( error , autoCompleted_ ) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif ( error ) { cleanup( error ) ; return ; }\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tautoCompleted = autoCompleted_ ;\n\t\t\t\t\t\t\t\tfinishCompletion() ;\n\t\t\t\t\t\t\t} ) ;\n\t\t\t\t\t\t\treturn ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tautoCompleted = dynamic.autoComplete( leftPart.join( '' ) ) ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfinishCompletion() ;\n\t\t\t\t\t\n\t\t\t\t\tbreak ;\n\t\t\t}\n\t\t}\n\t} ;\n\t\n\t\n\t\n\tvar onAreaKey = function onAreaKey( key , trash , data ) {\n\t\t\n\t\t//var leftPart , autoCompleted , extraLines ;\n\t\t\n\t\tif ( data && data.isCharacter )\n\t\t{\n\t\t\t// if data.isCharacter, this is a regular UTF-8 character, not a special key\n\t\t\t//if ( inputs[ inputIndex ].length >= options.maxLength ) { return ; }\n\t\t\tif ( textAttr ) { textBuffer.insert( key , textAttr ) ; }\n\t\t\telse { textBuffer.insert( key ) ; }\n\t\t\t//textBuffer.insert( key , { color: 'white' } ) ;\n\t\t\tareaDraw() ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Here we have a special key\n\t\t\t\n\t\t\tswitch( keyBindings[ key ] )\n\t\t\t{\n\t\t\t\tcase 'submit' :\n\t\t\t\t\t\n\t\t\t\t\t//if ( inputs[ inputIndex ].length < options.minLength ) { break ; }\n\t\t\t\t\t//cleanup( undefined , inputs[ inputIndex ] ) ;\n\t\t\t\t\t\n\t\t\t\t\tcleanup( undefined , textBuffer.getText() ) ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'newLine' :\n\t\t\t\t\ttextBuffer.newLine() ;\n\t\t\t\t\tareaDraw() ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'cancel' :\n\t\t\t\t\tif ( options.cancelable ) { cleanup() ; }\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'backDelete' :\n\t\t\t\t\ttextBuffer.backDelete() ;\n\t\t\t\t\tareaDraw() ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'delete' :\n\t\t\t\t\ttextBuffer.delete() ;\n\t\t\t\t\tareaDraw() ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'backward' :\n\t\t\t\t\ttextBuffer.moveBackward() ;\n\t\t\t\t\tareaDrawCursor() ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'forward' :\n\t\t\t\t\ttextBuffer.moveForward() ;\n\t\t\t\t\tareaDrawCursor() ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'startOfLine' :\n\t\t\t\t\ttextBuffer.moveToColumn( 0 ) ;\n\t\t\t\t\tareaDrawCursor() ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'endOfLine' :\n\t\t\t\t\ttextBuffer.moveToEndOfLine() ;   \n\t\t\t\t\tareaDrawCursor() ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'down' :\n\t\t\t\t\ttextBuffer.moveDown() ;\n\t\t\t\t\tareaDrawCursor() ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\n\t\t\t\tcase 'up' :\n\t\t\t\t\ttextBuffer.moveUp() ;\n\t\t\t\t\tareaDrawCursor() ;\n\t\t\t\t\tbreak ;\n\t\t\t}\n\t\t}\n\t} ;\n\t\n\t\n\t\n\t// Return a controller for the input field\n\t\n\tcontroller = Object.create( NextGenEvents.prototype ) ;\n\t\n\tcontroller.defineStates( 'ready' ) ;\n\t\n\t// /!\\ .ready is deprecated, it is now a getter to .hasState('ready')\n\tObject.defineProperty( controller , 'ready' , {\n\t\tget: function() { return this.hasState( 'ready' ) ; }\n\t} ) ;\n\t\n\t// Tmp, for compatibility\n\tcontroller.widgetType = 'inputField' ;\n\t\n\t// Stop everything and do not even call the callback\n\tcontroller.abort = function controllerAbort()\n\t{\n\t\tif ( finished ) { return ; }\n\t\tcleanup( 'abort' ) ;\n\t} ;\n\t\n\t// Stop and call the completion callback with the current input\n\tcontroller.stop = function controllerStop()\n\t{\n\t\tif ( finished ) { return ; }\n\t\tcleanup( undefined , inputs[ inputIndex ] ) ;\n\t} ;\n\t\n\t// Pause and resume: the input field will not respond to event when paused\n\tcontroller.pause = function controllerPause() { pause = true ; } ;\n\tcontroller.resume = function controllerResume() { pause = false ; } ;\n\t\n\tcontroller.focus = function controllerFocus( value )\n\t{\n\t\tpause = ! value ;\n\t\tif ( ! inlineMode ) { areaDrawCursor() ; }\n\t} ;\n\t\n\t// Get the current input\n\tcontroller.getInput = function controllerGetInput() {\n\t\tif ( inlineMode ) { return inputs[ inputIndex ].join( '' ) ; }\n\t\telse { return textBuffer.getText() ; }\n\t} ;\n\t\n\tcontroller.value = controller.getInput ;\n\t\n\t// Get the current input\n\tcontroller.getPosition = function controllerGetPosition() { return { x: start.x , y: start.y } ; } ;\n\t\n\t// Hide the input field\n\tcontroller.hide = function controllerHide()\n\t{\n\t\tif ( ! controller.hasState( 'ready' ) ) { controller.once( 'ready' , controller.hide ) ; return ; }\n\t\t\n\t\tvar i , j ;\n\t\t\n\t\tfor ( i = start.x , j = start.y ; j <= end.y ; i = 1 , j ++ )\n\t\t{\n\t\t\tself.moveTo.eraseLineAfter( i , j ) ;\n\t\t}\n\t\t\n\t\techo = false ;\n\t} ;\n\t\n\t// Show the input field\n\tcontroller.show = function controllerShow()\n\t{\n\t\tif ( ! controller.hasState( 'ready' ) ) { controller.once( 'ready' , controller.show ) ; return ; }\n\t\t\n\t\techo = true ;\n\t\tredraw() ;\n\t} ;\n\t\n\t// Redraw the input field\n\tcontroller.redraw = function controllerRedraw()\n\t{\n\t\tif ( ! controller.hasState( 'ready' ) ) { controller.once( 'ready' , controller.redraw ) ; return ; }\n\t\t\n\t\tredraw() ;\n\t} ;\n\t\n\t// Rebase the input field where the cursor is\n\tcontroller.rebase = function controllerRebase()\n\t{\n\t\tif ( ! inlineMode ) { return ; }\n\t\tif ( ! controller.hasState( 'ready' ) ) { controller.once( 'ready' , controller.rebase ) ; return ; }\n\t\t\n\t\t// First, disable echoing: getCursorLocation is async!\n\t\techo = false ;\n\t\t\n\t\tself.getCursorLocation( function( error , x , y ) {\n\t\t\t\n\t\t\tif ( error ) { cleanup( error ) ; return ; }\n\t\t\t\n\t\t\tstart.x = x ;\n\t\t\tstart.y = y ;\n\t\t\t\n\t\t\tif ( options.echo )\n\t\t\t{\n\t\t\t\techo = true ;\n\t\t\t\tcomputeAllCoordinate() ;\n\t\t\t\tredraw() ;\n\t\t\t}\n\t\t} ) ;\n\t} ;\n\t\n\t// Init the input field\n\tinit() ;\n\t\n\treturn controller ;\n} ;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/fileInput.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\nvar autoComplete = require( './autoComplete.js' ) ;\nvar async = require( 'async-kit' ) ;\nvar tree = require( 'tree-kit' ) ;\nvar fs = require( 'fs' ) ;\nvar path = require( 'path' ) ;\n\n\n\n/*\n\t/!\\ Document that!!! /!\\\n*/\nmodule.exports = function fileInput( options , callback )\n{\n\tif ( arguments.length <= 0 ) { throw new Error( '[terminal] .fileInput(): should at least provide one callback as argument' ) ; }\n\tif ( arguments.length === 1 ) { callback = options ; options = {} ; }\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tvar self = this , baseDir ;\n\t\n\tif ( options.baseDir )\n\t{\n\t\tbaseDir = path.resolve( options.baseDir ) ;\n\t\t\n\t\tif ( ! path.isAbsolute( baseDir ) )\n\t\t{\n\t\t\tfs.realpath( options.baseDir , function( error , resolvedPath ) {\n\t\t\t\tif ( error ) { callback( error ) ; return ; }\n\t\t\t\toptions.baseDir = resolvedPath ;\n\t\t\t\tfileInput.call( self , options , callback ) ;\n\t\t\t} ) ;\n\t\t\t\n\t\t\treturn ;\n\t\t}\n\t}\n\telse\n\t{\n\t\tbaseDir = process.cwd() ;\n\t}\n\t\n\tif ( baseDir[ baseDir.length - 1 ] !== '/' ) { baseDir += '/' ; }\n\t\n\tvar autoCompleter = function autoCompleter( inputString , callback )\n\t{  \n\t\tvar inputDir , inputFile , currentDir ;\n\t\t\n\t\tif ( inputString[ inputString.length - 1 ] === '/' )\n\t\t{\n\t\t\tinputDir = inputString ;\n\t\t\tinputFile = '' ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tinputDir = path.dirname( inputString ) ;\n\t\t\tinputDir = inputDir === '.' ? '' : inputDir + '/' ;\n\t\t\tinputFile = path.basename( inputString ) ;\n\t\t}\n\t\t\n\t\t\n\t\t// If the input start with a '/', then forget about the baseDir\n\t\tif ( path.isAbsolute( inputString ) ) { currentDir = inputDir ; }\n\t\telse { currentDir = baseDir + inputDir ; }\n\t\t\n\t\t\n\t\t//console.error( \"### '\" + inputDir +\"' '\"+ inputFile +\"' '\"+ currentDir + \"'\" ) ;\n\t\t\n\t\treaddir( currentDir , function( error , files ) {\n\t\t\tif ( error || ! Array.isArray( files ) || ! files.length ) { callback( undefined , inputString ) ; return ; }\n\t\t\t\n\t\t\tvar completion = autoComplete( files , inputFile , true ) ;\n\t\t\t\n\t\t\t// force inputField() to prefix that *AFTER* singleLineMenu()\n\t\t\tif ( Array.isArray( completion ) ) { completion.prefix = inputDir ;\t}\n\t\t\telse { completion = path.normalize( inputDir + completion ) ; }\n\t\t\t\n\t\t\tcallback( undefined , completion ) ;\n\t\t} ) ;\n\t} ;\n\t\n\t// Transmit options to inputField()\n\toptions = tree.extend( null , {} , options , { autoComplete: autoCompleter , autoCompleteMenu: true , minLength: 1 } ) ;\n\t\n\tthis.inputField(\n\t\toptions ,\n\t\tfunction( error , input ) {\n\t\t\tif ( error ) { callback( error ) ; return ; }\n\t\t\telse if ( ! input && typeof input !== 'string' ) { callback() ; return ; }\n\t\t\t\n\t\t\tcallback( undefined ,\n\t\t\t\tpath.resolve( path.isAbsolute( input ) ? input : baseDir + input )\n\t\t\t) ;\n\t\t}\n\t) ;\n} ;\n\n\n\n// Like fs.readdir(), but performs fs.stat() for each file in order to add a '/' to directories\nfunction readdir( dir , callback )\n{\n\tif ( dir[ dir.length - 1 ] !== '/' ) { dir += '/' ; }\n\t\n\tfs.readdir( dir , function( error , files ) {\n\t\t\n\t\tif ( error ) { callback( error ) ; return ; }\n\t\t\n\t\tasync.map( files , function( file , foreachCallback ) {\n\t\t\t\n\t\t\tfs.lstat( dir + file , function( error , stats ) {\n\t\t\t\t\n\t\t\t\tif ( error ) { foreachCallback( error , file ) ; return ; }\n\t\t\t\tif ( stats.isDirectory() ) { file += '/' ; }\n\t\t\t\tforeachCallback( undefined , file ) ;\n\t\t\t} ) ;\n\t\t} )\n\t\t.exec( function( error , fixedFiles ) {\n\t\t\tif ( error ) { callback( error ) ; return ; }\n\t\t\tcallback( undefined , fixedFiles ) ;\n\t\t} ) ;\n\t\t\n\t} ) ;\n}\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/singleLineMenu.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n/*\n\tsingleLineMenu( menuItems , [options] , callback )\n\t\t* menuItems `array` of menu item text\n\t\t* options `object` of options, where:\n\t\t\t* y `number` the line where the menu will be displayed, default to the next line\n\t\t\t* separator `string` (default: '  ') the string separating each menu item\n\t\t\t* nextPageHint `string` (default: ' » ') string indicator for a next page\n\t\t\t* previousPageHint `string` (default: ' « ') string indicator for a previous page\n\t\t\t* style `function` the style of unselected items, default to `term`\n\t\t\t* selectedStyle `function` the style of the selected item, default to `term.dim.blue.bgGreen`\n\t\t\t* exitOnUnexpectedKey `boolean` if an unexpected key is pressed, it exits, calling the callback with undefined values\n\t\t* callback( error , response ), where:\n\t\t\t* error\n\t\t\t* response `Object` where:\n\t\t\t\t* selectedIndex `number` the user-selected menu item index\n\t\t\t\t* selectedText `string` the user-selected menu item text\n\t\t\t\t* x `number` the x coordinate of the selected menu item (the first character)\n\t\t\t\t* y `number` the y coordinate of the selected menu item (same coordinate for all items since it's a single line menu)\n\t\t\t\t* unexpectedKey `string` when 'exitOnUnexpectedKey' option is set, this contains the key that produced the exit\n*/\nmodule.exports = function singleLineMenu( menuItems , options , callback )\n{\n\tif ( arguments.length < 2 ) { throw new Error( '[terminal] singleLineMenu() needs at least an array of menuItems and a callback as argument' ) ; }\n\telse if ( arguments.length === 2 ) { callback = options ; options = {} ; }\n\t\n\tif ( ! Array.isArray( menuItems ) || ! menuItems.length ) { throw new TypeError( '[terminal] singleLineMenu(): argument #0 should be a non-empty array' ) ; }\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\tif ( typeof callback !== 'function' ) { throw new TypeError( '[terminal] singleLineMenu(): last argument should be a function' ) ; }\n\t\n\tif ( options.separator === undefined ) { options.separator = '  ' ; }\n\tif ( options.nextPageHint === undefined ) { options.nextPageHint = ' » ' ; }\n\tif ( options.previousPageHint === undefined ) { options.previousPageHint = ' « ' ; }\n\tif ( ! options.style ) { options.style = this ; }\n\tif ( ! options.selectedStyle ) { options.selectedStyle = this.dim.blue.bgGreen ; }\n\t\n\tif ( ! options.y ) { this( '\\n' ) ; }\n\telse { this.moveTo( 1 , options.y ) ; }\n\t\n\tif ( ! this.grabbing ) { this.grabInput() ; }\n\t\n\t\n\tvar self = this , start = {} , selectedPage = 0 , selectedIndex = 0 , finished = false , menuPages = [] ;\n\t\n\t\n\tvar computePages = function computePages()\n\t{\n\t\tvar i , p = 0 , endX = 1 , nextEndX , firstItem = true ,\n\t\t\tmax = self.width - options.nextPageHint.length ;\n\t\t\n\t\tmenuPages = [ [] ] ;\n\t\t\n\t\tfor ( i = 0 ; i < menuItems.length ; i ++ )\n\t\t{\n\t\t\tif ( p >= menuPages.length ) { menuPages.push( [] ) ; }\n\t\t\t\n\t\t\tnextEndX = endX + menuItems[ i ].length + ( i ? options.separator.length : 0 ) ;\n\t\t\t\n\t\t\tif ( nextEndX > max )\n\t\t\t{\n\t\t\t\tif ( firstItem )\n\t\t\t\t{\n\t\t\t\t\tmenuPages[ p ].push( {\n\t\t\t\t\t\tindex: i ,\n\t\t\t\t\t\ttext: menuItems[ i ] ,\n\t\t\t\t\t\tdisplayText: menuItems[ i ].slice( 0 , max - endX - 1 ) + '…' ,\n\t\t\t\t\t\tx: endX\n\t\t\t\t\t} ) ;\n\t\t\t\t\t\n\t\t\t\t\tp ++ ;\n\t\t\t\t\tendX = 1 + options.previousPageHint.length ;\n\t\t\t\t\tfirstItem = true ;\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tp ++ ;\n\t\t\t\t\tendX = 1 + options.previousPageHint.length ;\n\t\t\t\t\tfirstItem = true ;\n\t\t\t\t\ti -- ;\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmenuPages[ p ].push( {\n\t\t\t\tindex: i ,\n\t\t\t\ttext: menuItems[ i ] ,\n\t\t\t\tdisplayText: menuItems[ i ] ,\n\t\t\t\tx: endX\n\t\t\t} ) ;\n\t\t\t\n\t\t\tendX = nextEndX ;\n\t\t\tfirstItem = false ;\n\t\t}\n\t} ;\n\t\n\t\n\t// Compute the coordinate of the end of a string, given a start coordinate\n\tvar redraw = function redraw()\n\t{\n\t\tvar i , endX = 1 , cursorX ;\n\t\t\n\t\tself.moveTo.eraseLineAfter( start.x , start.y ) ;\n\t\t\n\t\tif ( selectedPage )\n\t\t{\n\t\t\toptions.style.noFormat( options.previousPageHint ) ;\n\t\t\tendX += options.previousPageHint.length ;\n\t\t}\n\t\t\n\t\tfor ( i = 0 ; i < menuPages[ selectedPage ].length ; i ++ )\n\t\t{\n\t\t\tif ( i )\n\t\t\t{\n\t\t\t\toptions.style.noFormat( options.separator ) ;\n\t\t\t\tendX += options.separator.length ;\n\t\t\t}\n\t\t\t\n\t\t\tif ( i === selectedIndex )\n\t\t\t{\n\t\t\t\toptions.selectedStyle.noFormat( menuPages[ selectedPage ][ i ].displayText ) ;\n\t\t\t\tcursorX = endX ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toptions.style.noFormat( menuPages[ selectedPage ][ i ].displayText ) ;\n\t\t\t}\n\t\t\t\n\t\t\tendX += menuPages[ selectedPage ][ i ].displayText.length ;\n\t\t}\n\t\t\n\t\tif ( selectedPage < menuPages.length - 1 )\n\t\t{\n\t\t\toptions.style.noFormat( options.nextPageHint ) ;\n\t\t\tendX += options.nextPageHint.length ;\n\t\t}\n\t\t\n\t\tself.column( cursorX ) ;\n\t} ;\n\t\n\t\n\tvar onEvent = function onEvent( key , trash , data ) {\n\t\t\n\t\tif ( finished ) { return ; }\n\t\t\n\t\tswitch ( key )\n\t\t{\n\t\t\tcase 'ENTER' :\n\t\t\tcase 'KP_ENTER' :\n\t\t\t\tfinished = true ;\n\t\t\t\tself.removeListener( 'key' , onEvent ) ;\n\t\t\t\t\n\t\t\t\tcallback( undefined , {\n\t\t\t\t\tselectedIndex: menuPages[ selectedPage ][ selectedIndex ].index ,\n\t\t\t\t\tselectedText: menuPages[ selectedPage ][ selectedIndex ].text ,\n\t\t\t\t\tx: menuPages[ selectedPage ][ selectedIndex ].x ,\n\t\t\t\t\ty: start.y\n\t\t\t\t} ) ;\n\t\t\t\t\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'LEFT' :\n\t\t\t\tif ( selectedIndex > 0 ) { selectedIndex -- ; }\n\t\t\t\telse if ( selectedPage > 0 ) { selectedPage -- ; selectedIndex = menuPages[ selectedPage ].length - 1 ; }\n\t\t\t\tredraw() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'RIGHT' :\n\t\t\t\tif ( selectedIndex < menuPages[ selectedPage ].length - 1 ) { selectedIndex ++ ; }\n\t\t\t\telse if ( selectedPage < menuPages.length - 1 ) { selectedPage ++ ; selectedIndex = 0 ; }\n\t\t\t\tredraw() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'HOME' :\n\t\t\t\tselectedPage = 0 ;\n\t\t\t\tselectedIndex = 0 ;\n\t\t\t\tredraw() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'TAB' :\n\t\t\t\tif ( selectedPage === menuPages.length - 1 && selectedIndex === menuPages[ selectedPage ].length - 1 )\n\t\t\t\t{\n\t\t\t\t\tselectedPage = 0 ;\n\t\t\t\t\tselectedIndex = 0 ;\n\t\t\t\t}\n\t\t\t\telse if ( selectedIndex < menuPages[ selectedPage ].length - 1 )\n\t\t\t\t{\n\t\t\t\t\tselectedIndex ++ ;\n\t\t\t\t}\n\t\t\t\telse if ( selectedPage < menuPages.length - 1 )\n\t\t\t\t{\n\t\t\t\t\tselectedPage ++ ;\n\t\t\t\t\tselectedIndex = 0 ;\n\t\t\t\t}\n\t\t\t\tredraw() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'SHIFT_TAB' :\n\t\t\t\tif ( selectedPage === 0 && selectedIndex === 0 )\n\t\t\t\t{\n\t\t\t\t\tselectedPage = menuPages.length - 1 ;\n\t\t\t\t\tselectedIndex = menuPages[ selectedPage ].length - 1 ;\n\t\t\t\t}\n\t\t\t\telse if ( selectedIndex > 0 )\n\t\t\t\t{\n\t\t\t\t\tselectedIndex -- ;\n\t\t\t\t}\n\t\t\t\telse if ( selectedPage > 0 )\n\t\t\t\t{\n\t\t\t\t\tselectedPage -- ;\n\t\t\t\t\tselectedIndex = menuPages[ selectedPage ].length - 1 ;\n\t\t\t\t}\n\t\t\t\tredraw() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'END' :\n\t\t\t\tselectedPage = menuPages.length - 1 ;\n\t\t\t\tselectedIndex = menuPages[ selectedPage ].length - 1 ;\n\t\t\t\tredraw() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'UP' :\n\t\t\t\tif ( selectedPage > 0 ) { selectedPage -- ; selectedIndex = 0 ; }\n\t\t\t\tredraw() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'DOWN' :\n\t\t\t\tif ( selectedPage < menuPages.length - 1 ) { selectedPage ++ ; selectedIndex = 0 ; }\n\t\t\t\tredraw() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tdefault :\n\t\t\t\tif ( options.exitOnUnexpectedKey )\n\t\t\t\t{\n\t\t\t\t\tfinished = true ;\n\t\t\t\t\tself.removeListener( 'key' , onEvent ) ;\n\t\t\t\t\tcallback( undefined , { unexpectedKey: key , unexpectedKeyData: data } ) ;\n\t\t\t\t}\n\t\t\t\tbreak ;\n\t\t}\n\t} ;\n\t\n\t\n\tthis.getCursorLocation( function( error , x , y ) {\n\t\tstart.x = x ;\n\t\tstart.y = y ;\n\t\tcomputePages() ;\n\t\tredraw() ;\n\t\tself.on( 'key' , onEvent ) ;\n\t} ) ;\n} ;\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/progressBar.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\n//var string = require( 'string-kit' ) ;\n\n\n\n/*\n\tprogressBar( options )\n\t\t* options `object` of options, all of them are OPTIONAL, where:\n\t\t\t* width: `number` the total width of the progress bar, default to the max available width\n\t\t\t* percent: `boolean` if true, it shows the progress in percent alongside with the progress bar\n\t\t\t* eta: `boolean` if true, it shows the Estimated Time of Arrival alongside with the progress bar\n\t\t\t* items `number` the number of items, turns the 'item mode' on\n\t\t\t* title `string` the title of the current progress bar, turns the 'title mode' on\n\t\t\t* barStyle `function` the style of the progress bar items, default to `term.cyan`\n\t\t\t* barBracketStyle `function` the style of the progress bar bracket character, default to options.barStyle if given\n\t\t\t  or `term.blue`\n\t\t\t* percentStyle `function` the style of percent value string, default to `term.yellow`\n\t\t\t* etaStyle `function` the style of the ETA display, default to `term.bold`\n\t\t\t* itemStyle `function` the style of the item display, default to `term.dim`\n\t\t\t* titleStyle `function` the style of the title display, default to `term.bold`\n\t\t\t* itemSize `number` the size of the item status, default to 33% of width\n\t\t\t* titleSize `number` the size of the title, default to 33% of width or title.length depending on context\n\t\t\t* barChar `string` the char used for the bar, default to '='\n\t\t\t* barHeadChar `string` the char used for the bar, default to '>'\n\t\t\t* maxRefreshTime `number` the maximum time between two refresh in ms, default to 500ms\n\t\t\t* minRefreshTime `number` the minimum time between two refresh in ms, default to 100ms\n\t\t\t* syncMode `boolean` true if it should work in sync mode\n*/\nmodule.exports = function progressBar( options )\n{\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tvar self = this , controller = {} , progress , ready = false , pause = false ,\n\t\tmaxItems , itemsDone = 0 , itemsStarted = [] , itemFiller ,\n\t\ttitle , titleFiller ,\n\t\twidth , y , startX , endX ,\n\t\twheel , wheelCounter = 0 , itemRollCounter = 0 ,\n\t\tupdateCount = 0 , progressUpdateCount = 0 ,\n\t\tlastUpdateTime , lastRedrawTime ,\n\t\tstartingTime , redrawTimer ,\n\t\tetaStartingTime , lastEta , etaFiller ;\n\t\n\tetaStartingTime = startingTime = ( new Date() ).getTime() ;\n\t\n\twheel = [ '|' , '/' , '-' , '\\\\' ] ;\n\t\n\toptions.syncMode = !! options.syncMode ;\n\t\n\twidth = options.width || this.width - 1 ;\n\t\n\tif ( ! options.barBracketStyle )\n\t{\n\t\tif ( options.barStyle ) { options.barBracketStyle = options.barStyle ; }\n\t\telse { options.barBracketStyle = this.blue ; }\n\t}\n\t\n\tif ( ! options.barStyle ) { options.barStyle = this.cyan ; }\n\tif ( ! options.percentStyle ) { options.percentStyle = this.yellow ; }\n\tif ( ! options.etaStyle ) { options.etaStyle = this.bold ; }\n\tif ( ! options.itemStyle ) { options.itemStyle = this.dim ; }\n\tif ( ! options.titleStyle ) { options.titleStyle = this.bold ; }\n\t\n\tif ( ! options.barChar ) { options.barChar = '=' ; }\n\telse { options.barChar = options.barChar[ 0 ] ; }\n\t\n\tif ( ! options.barHeadChar ) { options.barHeadChar = '>' ; }\n\telse { options.barHeadChar = options.barHeadChar[ 0 ] ; }\n\t\n\tif ( typeof options.maxRefreshTime !== 'number' ) { options.maxRefreshTime = 500 ; }\n\tif ( typeof options.minRefreshTime !== 'number' ) { options.minRefreshTime = 100 ; }\n\t\n\tif ( typeof options.items === 'number' ) { maxItems = options.items ; }\n\tif ( maxItems && typeof options.itemSize !== 'number' ) { options.itemSize = Math.round( width / 3 ) ; }\n\t\n\titemFiller = ' '.repeat( options.itemSize ) ;\n\t\n\t\n\tif ( options.title && typeof options.title === 'string' )\n\t{\n\t\ttitle = options.title ;\n\t\t\n\t\tif ( typeof options.titleSize !== 'number' )\n\t\t{\n\t\t\toptions.titleSize = Math.round( Math.min( options.title.length + 1 , width / 3 ) ) ;\n\t\t}\n\t}\n\t\n\ttitleFiller = ' '.repeat( options.titleSize ) ;\n\t\n\t\n\tetaFiller = '           ' ;\t// 11 chars\n\t\n\t// This is a naive ETA for instance...\n\tvar etaString = function etaString( updated )\n\t{\n\t\tvar eta = '' , elapsedTime , elapsedEtaTime , remainingTime ,\n\t\t\taverageUpdateDelay , averageUpdateProgress , lastUpdateElapsedTime , fakeProgress ;\n\t\t\n\t\tif ( progress >= 1 )\n\t\t{\n\t\t\teta = ' done' ;\n\t\t}\n\t\telse if ( progress > 0 )\n\t\t{\n\t\t\telapsedTime = ( new Date() ).getTime() - startingTime ;\n\t\t\telapsedEtaTime = ( new Date() ).getTime() - etaStartingTime ;\n\t\t\t\n\t\t\tif ( ! updated && progressUpdateCount > 1 )\n\t\t\t{\n\t\t\t\tlastUpdateElapsedTime = ( new Date() ).getTime() - lastUpdateTime ;\n\t\t\t\taverageUpdateDelay = elapsedEtaTime / progressUpdateCount ;\n\t\t\t\taverageUpdateProgress = progress / progressUpdateCount ;\n\t\t\t\t\n\t\t\t\t//console.log( '\\n' , elapsedEtaTime , lastUpdateElapsedTime , averageUpdateDelay , averageUpdateProgress , '\\n' ) ;\n\t\t\t\t\n\t\t\t\t// Do not update ETA if it's not an update, except if update time is too long\n\t\t\t\tif ( lastUpdateElapsedTime < averageUpdateDelay )\n\t\t\t\t{\n\t\t\t\t\tfakeProgress = progress + averageUpdateProgress * lastUpdateElapsedTime / averageUpdateDelay ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfakeProgress = progress + averageUpdateProgress ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( fakeProgress > 0.99 ) { fakeProgress = 0.99 ; }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfakeProgress = progress ;\n\t\t\t}\n\t\t\t\n\t\t\tremainingTime = elapsedEtaTime * ( ( 1 - fakeProgress ) / fakeProgress ) / 1000 ;\n\t\t\t\n\t\t\teta = ' in ' ;\n\t\t\t\n\t\t\tif ( remainingTime < 10 ) { eta += Math.round( remainingTime * 10 ) / 10 + 's' ; }\n\t\t\telse if ( remainingTime < 120 ) { eta += Math.round( remainingTime ) + 's' ; }\n\t\t\telse if ( remainingTime < 7200 ) { eta += Math.round( remainingTime / 60 ) + 'min' ; }\n\t\t\telse if ( remainingTime < 172800 ) { eta += Math.round( remainingTime / 3600 ) + 'hours' ; }\n\t\t\telse if ( remainingTime < 31536000 ) { eta += Math.round( remainingTime / 86400 ) + 'days' ; }\n\t\t\telse { eta = 'few years' ; }\n\t\t}\n\t\telse\n\t\t{\n\t\t\tetaStartingTime = ( new Date() ).getTime() ;\n\t\t}\n\t\t\n\t\teta = ( eta + etaFiller ).slice( 0 , etaFiller.length ) ;\n\t\tlastEta = eta ;\n\t\t\n\t\treturn eta ;\n\t} ;\n\t\n\t\n\t\n\tvar redraw = function redraw( updated ) {\n\t\t\n\t\tvar time , itemIndex , itemName = itemFiller , titleName = titleFiller ,\n\t\t\tinnerBarSize , progressSize , voidSize ,\n\t\t\tprogressBar = '' , voidBar = '' , percent = '' , eta = '' ;\n\t\t\n\t\tif ( ! ready || pause ) { return ; }\n\t\t\n\t\ttime = ( new Date() ).getTime() ;\n\t\t\n\t\t// If progress is >= 1, then it's finished, so we should redraw NOW (before the program eventually quit)\n\t\tif ( ( ! progress || progress < 1 ) && lastRedrawTime && time < lastRedrawTime + options.minRefreshTime )\n\t\t{\n\t\t\tif ( ! options.syncMode )\n\t\t\t{\n\t\t\t\tif ( redrawTimer ) { clearTimeout( redrawTimer ) ; }\n\t\t\t\tredrawTimer = setTimeout( redraw.bind( this , updated ) , lastRedrawTime + options.minRefreshTime - time ) ;\n\t\t\t}\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\t\n\t\tself.saveCursor() ;\n\t\t\n\t\t// If 'y' is null, we are in the blind mode, we haven't get the cursor location\n\t\tif ( y === null ) { self.column( startX ) ; }\n\t\telse { self.moveTo( startX , y ) ; }\n\t\t\n\t\t//self.noFormat( Math.floor( progress * 100 ) + '%' ) ;\n\t\t\n\t\tinnerBarSize = width - 2 ;\n\t\t\n\t\tif ( options.percent )\n\t\t{\n\t\t\tinnerBarSize -= 4 ;\n\t\t\tpercent = ( '   ' + Math.round( ( progress || 0 ) * 100 ) + '%' ).slice( -4 ) ;\n\t\t}\n\t\t\n\t\tif ( options.eta )\n\t\t{\n\t\t\teta = etaString( updated ) ;\n\t\t\tinnerBarSize -= eta.length ;\n\t\t}\n\t\t\n\t\tinnerBarSize -= options.itemSize || 0 ;\n\t\tif ( maxItems )\n\t\t{\n\t\t\tif ( ! itemsStarted.length )\n\t\t\t{\n\t\t\t\titemName = '' ;\n\t\t\t}\n\t\t\telse if ( itemsStarted.length === 1 )\n\t\t\t{\n\t\t\t\titemName = ' ' + itemsStarted[ 0 ] ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\titemIndex = ( itemRollCounter ++ ) % itemsStarted.length ;\n\t\t\t\titemName = ' [' + ( itemIndex + 1 ) + '/' + itemsStarted.length + '] ' + itemsStarted[ itemIndex ] ;\n\t\t\t}\n\t\t\t\n\t\t\tif ( itemName.length > itemFiller.length ) { itemName = itemName.slice( 0 , itemFiller.length - 1 ) + '…' ; }\n\t\t\telse if ( itemName.length < itemFiller.length ) { itemName = ( itemName + itemFiller ).slice( 0 , itemFiller.length ) ; }\n\t\t}\n\t\t\n\t\tinnerBarSize -= options.titleSize || 0 ;\n\t\tif ( title )\n\t\t{\n\t\t\ttitleName = title ;\n\t\t\t\n\t\t\tif ( titleName.length >= titleFiller.length ) { titleName = titleName.slice( 0 , titleFiller.length - 2 ) + '… ' ; }\n\t\t\telse { titleName = ( titleName + titleFiller ).slice( 0 , titleFiller.length ) ; }\n\t\t}\n\t\t\n\t\tprogressSize = progress === undefined ? 1 : Math.round( innerBarSize * Math.max( Math.min( progress , 1 ) , 0 ) ) ;\n\t\tvoidSize = innerBarSize - progressSize ;\n\t\t\n\t\t/*\n\t\tconsole.log( \"Size:\" , width ,\n\t\t\tvoidSize , innerBarSize , progressSize , eta.length , title.length , itemName.length ,\n\t\t\tvoidSize + progressSize + eta.length + title.length + itemName.length\n\t\t) ;\n\t\t//*/\n\t\t\n\t\tif ( progressSize )\n\t\t{\n\t\t\tif ( progress === undefined )\n\t\t\t{\n\t\t\t\tprogressBar = wheel[ ++ wheelCounter % wheel.length ] ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprogressBar += options.barChar.repeat( progressSize - 1 ) ;\n\t\t\t\tprogressBar += options.barHeadChar ;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoidBar += ' '.repeat( voidSize ) ;\n\t\t\n\t\toptions.titleStyle( titleName ) ;\n\t\t\n\t\tif ( percent ) { options.percentStyle( percent ) ; }\n\t\t\n\t\tif ( progress === undefined ) { self( ' ' ) ; }\n\t\telse { options.barBracketStyle( '[' ) ; }\n\t\t\n\t\toptions.barStyle( progressBar ) ;\n\t\tself( voidBar ) ;\n\t\t\n\t\tif ( progress === undefined ) { self( ' ' ) ; /*self( '+' ) ;*/ }\n\t\telse { options.barBracketStyle( ']' ) ; }\n\t\t\n\t\toptions.etaStyle( eta ) ;\n\t\t//self( '*' ) ;\n\t\toptions.itemStyle( itemName ) ;\n\t\t//self( '&' ) ;\n\t\t\n\t\tself.restoreCursor() ;\n\t\t\n\t\tif ( ! options.syncMode )\n\t\t{\n\t\t\tif ( redrawTimer ) { clearTimeout( redrawTimer ) ; }\n\t\t\tif ( ! progress || progress < 1 ) { redrawTimer = setTimeout( redraw , options.maxRefreshTime ) ; }\n\t\t}\n\t\t\n\t\tlastRedrawTime = time ;\n\t} ;\n\t\n\t\n\t// Get the cursor location before getting started\n\t\n\tif ( options.syncMode )\n\t{\n\t\tvar oldWidth = width ;\n\t\t\n\t\tstartX = 1 ;\n\t\tendX = Math.min( 1 + width , self.width ) ;\n\t\ty = null ;\n\t\twidth = endX - startX ;\n\t\t\n\t\tif ( width !== oldWidth )\n\t\t{\n\t\t\t// Should resize all part here\n\t\t\tif ( options.titleSize ) { options.titleSize = Math.floor( options.titleSize * width / oldWidth ) ; }\n\t\t\tif ( options.itemSize ) { options.itemSize = Math.floor( options.itemSize * width / oldWidth ) ; }\n\t\t}\n\t\t\n\t\tready = true ;\n\t\tredraw() ;\n\t}\n\telse\n\t{\n\t\tthis.getCursorLocation( function( error , x_ , y_ ) {\n\t\t\t\n\t\t\tvar oldWidth = width ;\n\t\t\t\n\t\t\tstartX = x_ ;\n\t\t\tendX = Math.min( x_ + width , self.width ) ;\n\t\t\ty = y_ ;\n\t\t\twidth = endX - startX ;\n\t\t\t\n\t\t\tif ( width !== oldWidth )\n\t\t\t{\n\t\t\t\t// Should resize all part here\n\t\t\t\tif ( options.titleSize ) { options.titleSize = Math.floor( options.titleSize * width / oldWidth ) ; }\n\t\t\t\tif ( options.itemSize ) { options.itemSize = Math.floor( options.itemSize * width / oldWidth ) ; }\n\t\t\t}\n\t\t\t\n\t\t\tready = true ;\n\t\t\tredraw() ;\n\t\t} ) ;\n\t}\n\t\n\tcontroller.startItem = function item( name ) {\n\t\t\n\t\titemsStarted.push( name ) ;\n\t\t\n\t\t// No need to redraw NOW if there are other items running.\n\t\t// Let the timer do the job.\n\t\tif ( itemsStarted.length === 1 )\n\t\t{\n\t\t\t// If progress is >= 1, then it's finished, so we should redraw NOW (before the program eventually quit)\n\t\t\tif ( progress >= 1 ) { redraw() ; return ; }\n\t\t\t\n\t\t\tif ( options.syncMode )\n\t\t\t{\n\t\t\t\tredraw() ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Using a setTimeout with a 0ms time and redrawTimer clearing has a nice effect:\n\t\t\t\t// if multiple synchronous update are performed, redraw will be called once\n\t\t\t\tif ( redrawTimer ) { clearTimeout( redrawTimer ) ; }\n\t\t\t\tredrawTimer = setTimeout( redraw , 0 ) ;\n\t\t\t}\n\t\t}\n\t} ;\n\t\n\tcontroller.itemDone = function itemDone( name ) {\n\t\t\n\t\tvar index ;\n\t\t\n\t\titemsDone ++ ;\n\t\t\n\t\tif ( maxItems ) { progress = itemsDone / maxItems ; }\n\t\telse { progress = undefined ; }\n\t\t\n\t\tlastUpdateTime = ( new Date() ).getTime() ;\n\t\tupdateCount ++ ;\n\t\tprogressUpdateCount ++ ;\n\t\t\n\t\tindex = itemsStarted.indexOf( name ) ;\n\t\tif ( index >= 0 ) { itemsStarted.splice( index , 1 ) ; }\n\t\t\n\t\t// If progress is >= 1, then it's finished, so we should redraw NOW (before the program eventually quit)\n\t\tif ( progress >= 1 ) { redraw( true ) ; return ; }\n\t\t\n\t\tif ( options.syncMode )\n\t\t{\n\t\t\tredraw() ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Using a setTimeout with a 0ms time and redrawTimer clearing has a nice effect:\n\t\t\t// if multiple synchronous update are performed, redraw will be called once\n\t\t\tif ( redrawTimer ) { clearTimeout( redrawTimer ) ; }\n\t\t\tredrawTimer = setTimeout( redraw.bind( self , true ) , 0 ) ;\n\t\t}\n\t} ;\n\t\n\tcontroller.update = function update( toUpdate ) {\n\t\t\n\t\tif ( ! toUpdate ) { toUpdate = {} ; }\n\t\telse if ( typeof toUpdate === 'number' ) { toUpdate = { progress: toUpdate } ; }\n\t\t\n\t\tif ( 'progress' in toUpdate )\n\t\t{\n\t\t\tif ( typeof toUpdate.progress !== 'number' )\n\t\t\t{\n\t\t\t\tprogress = undefined ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Not sure if it is a good thing to let the user set progress to a value that is lesser than the current one\n\t\t\t\tprogress = toUpdate.progress ;\n\t\t\t\t\n\t\t\t\tif ( progress > 1 ) { progress = 1 ; }\n\t\t\t\telse if ( progress < 0 ) { progress = 0 ; }\n\t\t\t\t\n\t\t\t\tif ( progress > 0 ) { progressUpdateCount ++ ; }\n\t\t\t\t\n\t\t\t\tlastUpdateTime = ( new Date() ).getTime() ;\n\t\t\t\tupdateCount ++ ;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ( typeof toUpdate.items === 'number' )\n\t\t{\n\t\t\tmaxItems = toUpdate.items ;\n\t\t\tif ( maxItems ) { progress = itemsDone / maxItems ; }\n\t\t\t\n\t\t\tif ( typeof options.itemSize !== 'number' )\n\t\t\t{\n\t\t\t\toptions.itemSize = Math.round( width / 3 ) ;\n\t\t\t\titemFiller = ' '.repeat( options.itemSize ) ;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ( typeof toUpdate.title === 'string' )\n\t\t{\n\t\t\ttitle = toUpdate.title ;\n\t\t\t\n\t\t\tif ( typeof options.titleSize !== 'number' )\n\t\t\t{\n\t\t\t\toptions.titleSize = Math.round( width / 3 ) ;\n\t\t\t\ttitleFiller = ' '.repeat( options.titleSize ) ;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If progress is >= 1, then it's finished, so we should redraw NOW (before the program eventually quit)\n\t\tif ( progress >= 1 ) { redraw( true ) ; return ; }\n\t\t\n\t\tif ( options.syncMode )\n\t\t{\n\t\t\tredraw() ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Using a setTimeout with a 0ms time and redrawTimer clearing has a nice effect:\n\t\t\t// if multiple synchronous update are performed, redraw will be called once\n\t\t\tif ( redrawTimer ) { clearTimeout( redrawTimer ) ; }\n\t\t\tredrawTimer = setTimeout( redraw.bind( self , true ) , 0 ) ;\n\t\t}\n\t} ;\n\t\n\tcontroller.pause = controller.stop = function stop() {\n\t\tpause = true ;\n\t} ;\n\t\n\tcontroller.resume = function resume() {\n\t\tif ( pause )\n\t\t{\n\t\t\tpause = false ;\n\t\t\tredraw() ;\n\t\t}\n\t} ;\n\t\n\treturn controller ;\n} ;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/slowTyping.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n/*\n\tfakeTyping( str , [options] , callback )\n\t\t* str\n\t\t* options\n\t\t\t* style\n\t\t\t* delay\n\t\t\t* flashStyle\n\t\t\t* flashDelay\n\t\t* callback\n*/\nmodule.exports = function slowTyping( str , options , callback )\n{\n\tif ( arguments.length < 2 ) { throw new Error( '[terminal] fakeTyping() needs at least a string and a callback as argument' ) ; }\n\telse if ( arguments.length === 2 ) { callback = options ; options = {} ; }\n\t\n\tif ( typeof str !== 'string' ) { throw new TypeError( '[terminal] singleLineMenu(): argument #0 should be a string' ) ; }\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\tif ( typeof callback !== 'function' ) { throw new TypeError( '[terminal] singleLineMenu(): last argument should be a function' ) ; }\n\t\n\tif ( ! options.style ) { options.style = this.green ; }\n\tif ( ! options.delay ) { options.delay = 150 ; }\n\tif ( ! options.flashStyle ) { options.flashStyle = this.bold.brightGreen ; }\n\tif ( ! options.flashDelay ) { options.flashDelay = 100 ; }\n\t\n\tvar self = this , index , unflashTimer ;\n\t\n\tvar printChar = function printChar() {\n\t\t\n\t\tif ( unflashTimer )\n\t\t{\n\t\t\tclearTimeout( unflashTimer ) ;\n\t\t\tunflashTimer = null ;\n\t\t\tunflash() ;\n\t\t}\n\t\t\n\t\tif ( index === undefined )\n\t\t{\n\t\t\tindex = 0 ;\n\t\t}\n\t\telse if ( index >= str.length )\n\t\t{\n\t\t\tcallback() ;\n\t\t\treturn ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ( options.flashStyle && str[ index ].match( /\\S/ ) )\n\t\t\t{\n\t\t\t\toptions.flashStyle( str[ index ] ) ;\n\t\t\t\tunflashTimer = setTimeout( unflash , options.flashDelay ) ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toptions.style( str[ index ] ) ;\n\t\t\t}\n\t\t\t\n\t\t\tindex ++ ;\n\t\t}\n\t\t\n\t\tsetTimeout( printChar , ( 0.2 + Math.random() * 1.8 ) * options.delay ) ;\n\t} ;\n\t\n\tvar unflash = function unflash() {\n\t\t\n\t\tself.left( 1 ) ;\n\t\toptions.style( str[ index - 1 ] ) ;\n\t\tunflashTimer = null ;\n\t} ;\n\t\n\tprintChar() ;\n} ;\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/document/Element.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\n//var events = require( 'events' ) ;\nvar NextGenEvents = require( 'nextgen-events' ) ;\n\n\n\nfunction Element() { throw new Error( 'Use Element.create() instead' ) ; }\nmodule.exports = Element ;\nElement.prototype = Object.create( NextGenEvents.prototype ) ;\nElement.prototype.constructor = Element ;\nElement.prototype.elementType = 'Element' ;\n\n\n\nElement.create = function createElement( options )\n{\n\tvar element = Object.create( Element.prototype ) ;\n\telement.create( options ) ;\n\treturn element ;\n} ;\n\n\n\n// Useful to split that for inheritance\nElement.prototype.create = function create( options )\n{\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tthis.setInterruptible( true ) ;\n\t\n\tObject.defineProperties( this , {\n\t\tparent: { value: options.parent && options.parent.elementType ? options.parent : null , enumerable: true , writable: true } ,\n\t\tdocument: { value: null , enumerable: true , writable: true } ,\n\t\toutputDst: { value: options.outputDst || options.parent.inputDst } ,\n\t\tinputDst: { value: null , enumerable: true , writable: true } ,\n\t\tlabel: { value: options.label || '' , enumerable: true , writable: true } ,\n\t\tcontent: { value: options.content || '' , enumerable: true , writable: true } ,\n\t\tkey: { value: options.key || null , enumerable: true , writable: true } ,\n\t\tvalue: { value: options.value || null , enumerable: true , writable: true } ,\n\t\t\n\t\toutputX: { value: options.outputX || options.x || 0 , enumerable: true , writable: true } ,\n\t\toutputY: { value: options.outputY || options.y || 0 , enumerable: true , writable: true } ,\n\t\toutputWidth: { value: options.outputWidth || options.width || 1 , enumerable: true , writable: true } ,\n\t\toutputHeight: { value: options.outputHeight || options.height || 1 , enumerable: true , writable: true } ,\n\t\t\n\t\tsavedCursorX: { value: 0 , enumerable: true , writable: true } ,\n\t\tsavedCursorY: { value: 0 , enumerable: true , writable: true } ,\n\t\t\n\t\thasFocus: { value: false , enumerable: true , writable: true } ,\n\t\tchildren: { value: [] , enumerable: true , writable: true } ,\n\t\tchildIndex: { value: null , enumerable: true , writable: true } ,\n\t\t//onKey: { value: this.onKey.bind( this ) , writable: true } ,\n\t} ) ;\n\t\n\t// Children needs an inputDst, by default, everything is the same as for output (except for Container)\n\tthis.inputDst = this.outputDst ;\n\tthis.inputX = this.outputX ;\n\tthis.inputY = this.outputY ;\n\tthis.inputWidth = this.outputWidth ;\n\tthis.inputHeight = this.outputHeight ;\n\t\n\tif ( this.parent ) { this.parent.attach( this , options.id ) ; }\n} ;\n\n\n\n// Destroy the element and all its children, detaching them and removing listeners\nElement.prototype.destroy = function destroy( isSubDestroy )\n{\n\tvar i , iMax ;\n\t\n\t// Destroy children first\n\tfor ( i = 0 , iMax = this.children.length ; i < iMax ; i ++ )\n\t{\n\t\tthis.children[ i ].destroy( true ) ;\n\t}\n\t\n\tthis.children = [] ;\n\t\n\tif ( ! isSubDestroy )\n\t{\n\t\tthis.detach() ;\n\t}\n\telse\n\t{\n\t\tdelete this.document.elements[ this.id ] ;\n\t\tObject.defineProperty( this , 'id' , { value: null , enumerable: true , configurable: true } ) ;\n\t\t\n\t\tthis.parent = null ;\n\t\tthis.document = null ;\n\t}\n} ;\n\n\n\n// Clear the Element, destroy all children\nElement.prototype.clear = function clear()\n{\n\tvar i , iMax ;\n\t\n\t// Destroy children first\n\tfor ( i = 0 , iMax = this.children.length ; i < iMax ; i ++ )\n\t{\n\t\tthis.children[ i ].destroy( true ) ;\n\t}\n\t\n\tthis.children = [] ;\n\tthis.draw() ;\n} ;\n\n\n\nElement.prototype.attach = function attach( child , id )\n{\n\t// Insert it if it is not already a child\n\tif ( this.children.indexOf( child ) === -1 )\n\t{\n\t\tchild.parent = this ;\n\t\tchild.document = this.document ;\n\t\tthis.children.push( child ) ;\n\t\tchild.childIndex = this.children.length - 1 ;\n\t\t//this.document.assignId( this , options.id ) ;\n\t\t\n\t\tchild.document = this.document ;\n\t\tthis.document.assignId( child , id ) ;\n\t}\n\t\n\t// /!\\ Draw? /!\\\n\t\n\treturn this ;\n} ;\n\n\n\nElement.prototype.attachTo = function attachTo( parent , id )\n{\n\tif ( parent.elementType ) { parent.attach( this , id ) ; }\n\treturn this ;\n} ;\n\n\n\nElement.prototype.detach = function detach()\n{\n\tvar index , parent = this.parent ;\n\t\n\t// Already detached\n\tif ( ! parent ) { return ; }\n\t\n\tindex = parent.children.indexOf( this ) ;\n\t\n\tif ( index >= 0 )\n\t{\n\t\tparent.children.splice( index , 1 ) ;\n\t}\n\t\n\tdelete this.document.elements[ this.id ] ;\n\tObject.defineProperty( this , 'id' , { value: null , enumerable: true , configurable: true } ) ;\n\t\n\tthis.parent = null ;\n\tthis.document = null ;\n\t\n\t// Redraw\n\t\n\t// /!\\ Draw parent should work, but it does not always /!\\\n\t//parent.draw() ;\n\tparent.document.draw() ;\n\t\n\treturn this ;\n} ;\n\n\n\nElement.prototype.isAncestorOf = function isAncestorOf( element )\n{\n\tvar currentElement = element ;\n\t\n\tfor (;;)\n\t{\n\t\tif ( currentElement === this )\n\t\t{\n\t\t\t// Self found: ancestor match!\n\t\t\treturn true ;\n\t\t}\n\t\telse if ( ! currentElement.parent )\n\t\t{\n\t\t\t// The element is either detached or attached to another parent element\n\t\t\treturn false ;\n\t\t}\n\t\telse if ( currentElement.parent.children.indexOf( currentElement ) === -1 )\n\t\t{\n\t\t\t// Detached but still retain a ref to its parent.\n\t\t\t// It's probably a bug, so we will remove that link now.\n\t\t\tcurrentElement.parent = null ;\n\t\t\treturn false ;\n\t\t}\n\t\t\n\t\tcurrentElement = currentElement.parent ;\n\t}\n} ;\n\n\n\nElement.prototype.getParentContainer = function getParentContainer()\n{\n\tvar currentElement = this ;\n\t\n\tfor (;;)\n\t{\n\t\tif ( ! currentElement.parent ) { return null ; }\n\t\tif ( currentElement.parent.isContainer ) { return currentElement.parent ; }\n\t\t\n\t\tcurrentElement = currentElement.parent ;\n\t}\n} ;\n\n\n\n// Internal: get the index of the direct child that have the focus or have a descendant having the focus\nElement.prototype.getFocusBranchIndex = function getFocusBranchIndex()\n{\n\tvar index , currentElement ;\n\t\n\tif ( ! this.document.focusElement ) { return null ; }\n\t\n\tcurrentElement = this.document.focusElement ;\n\t\n\tfor (;;)\n\t{\n\t\tif ( currentElement === this )\n\t\t{\n\t\t\t// Self found: ancestor match!\n\t\t\treturn null ;\n\t\t}\n\t\telse if ( ! currentElement.parent )\n\t\t{\n\t\t\t// The element is either detached or attached to another parent element\n\t\t\treturn null ;\n\t\t}\n\t\t\n\t\tif ( currentElement.parent === this )\n\t\t{\n\t\t\tindex = currentElement.parent.children.indexOf( currentElement ) ;\n\t\t\t\n\t\t\tif ( index === -1 )\n\t\t\t{\n\t\t\t\t// Detached but still retain a ref to its parent.\n\t\t\t\t// It's probably a bug, so we will remove that link now.\n\t\t\t\tcurrentElement.parent = null ;\n\t\t\t\treturn null ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn index ;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurrentElement = currentElement.parent ;\n\t\t}\n\t}\n} ;\n\n\n\nElement.prototype.focusNextChild = function focusNextChild()\n{\n\tvar index , startingIndex , focusAware ;\n\t\n\tif ( ! this.children.length || ! this.document ) { return null ; }\n\t\n\t//if ( ! this.document.focusElement || ( index = this.children.indexOf( this.document.focusElement ) ) === -1 )\n\tif ( ! this.document.focusElement || ( index = this.getFocusBranchIndex() ) === null )\n\t{\n\t\tindex = this.children.length - 1 ;\n\t}\n\t\n\tstartingIndex = index ;\n\t\n\tfor (;;)\n\t{\n\t\tindex ++ ;\n\t\tif ( index >= this.children.length ) { index = 0 ; }\n\t\t\n\t\tfocusAware = this.document.giveFocusTo_( this.children[ index ] , 'cycle' ) ;\n\t\t\n\t\t// Exit if the focus was given to a focus-aware element or if we have done a full loop already\n\t\tif ( focusAware || startingIndex === index ) { break ; }\n\t}\n\t\n\treturn this.children[ index ] ;\n} ;\n\n\n\nElement.prototype.focusPreviousChild = function focusPreviousChild()\n{\n\tvar index , startingIndex , focusAware ;\n\t\n\tif ( ! this.children.length || ! this.document ) { return null ; }\n\t\n\t//if ( ! this.document.focusElement || ( index = this.children.indexOf( this.document.focusElement ) ) === -1 )\n\tif ( ! this.document.focusElement || ( index = this.getFocusBranchIndex() ) === null )\n\t{\n\t\tindex = 0 ;\n\t}\n\t\n\tstartingIndex = index ;\n\t\n\tfor (;;)\n\t{\n\t\tindex -- ;\n\t\tif ( index < 0 ) { index = this.children.length - 1 ; }\n\t\t\n\t\tfocusAware = this.document.giveFocusTo_( this.children[ index ] , 'cycle' ) ;\n\t\t\n\t\t// Exit if the focus was given to a focus-aware element or if we have done a full loop already\n\t\tif ( focusAware || startingIndex === index ) { break ; }\n\t}\n\t\n\treturn this.children[ index ] ;\n} ;\n\n\n\n// Get all child element matching a x,y coordinate relative to the current element\nElement.prototype.childrenAt = function childrenAt( x , y , matches )\n{\n\tvar i , iMax , current ;\n\t\n\tif ( ! matches ) { matches = [] ; }\n\t\n\tfor ( i = 0 , iMax = this.children.length ; i < iMax ; i ++ )\n\t{\n\t\tcurrent = this.children[ i ] ;\n\t\t\n\t\t//console.error( 'Checking: ' , x , y , current.id , current.outputX , current.outputY , current.outputWidth , current.outputHeight ) ;\n\t\t\n\t\tif (\n\t\t\tx >= current.outputX && x <= current.outputX + current.outputWidth - 1 &&\n\t\t\ty >= current.outputY && y <= current.outputY + current.outputHeight - 1\n\t\t)\n\t\t{\n\t\t\t// Bounding box match!\n\t\t\t\n\t\t\t// Check and add children of children first (depth-first)\n\t\t\tif ( current.isContainer )\n\t\t\t{\n\t\t\t\tcurrent.childrenAt( x - current.outputX , y - current.outputY , matches ) ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcurrent.childrenAt( x , y , matches ) ;\n\t\t\t}\n\t\t\t\n\t\t\tmatches.push( { element: current , x: x - current.outputX , y: y - current.outputY } ) ;\n\t\t}\n\t\telse if ( ! current.isContainer )\n\t\t{\n\t\t\t// If it is not a container, give a chance to its children to get selected\n\t\t\tcurrent.childrenAt( x , y , matches ) ;\n\t\t}\n\t}\n\t\n\treturn matches ;\n} ;\n\n\n\nElement.prototype.saveCursor = function saveCursor()\n{\n\tif ( this.inputDst )\n\t{\n\t\tthis.savedCursorX = this.inputDst.cx ;\n\t\tthis.savedCursorY = this.inputDst.cy ;\n\t}\n\telse if ( this.outputDst )\n\t{\n\t\tthis.savedCursorX = this.outputDst.cx ;\n\t\tthis.savedCursorY = this.outputDst.cy ;\n\t}\n\t\n\treturn this ;\n} ;\n\n\n\nElement.prototype.restoreCursor = function restoreCursor()\n{\n\tif ( this.inputDst )\n\t{\n\t\tthis.inputDst.cx = this.savedCursorX ;\n\t\tthis.inputDst.cy = this.savedCursorY ;\n\t\tthis.inputDst.drawCursor() ;\n\t}\n\telse if ( this.outputDst )\n\t{\n\t\tthis.outputDst.cx = this.savedCursorX ;\n\t\tthis.outputDst.cy = this.savedCursorY ;\n\t\tthis.outputDst.drawCursor() ;\n\t}\n\t\n\treturn this ;\n} ;\n\n\n\nElement.prototype.draw = function draw()\n{\n\tif ( ! this.document ) { return this ; }\n\t\n\tthis.saveCursor() ;\n\tthis.descendantDraw() ;\n\tthis.ascendantDraw() ;\n\tthis.drawCursor() ;\n\treturn this ;\n} ;\n\n\n\n// .draw() is used when drawing the current Element is enough: the Element has not moved, and has not been resized.\n// If it has, then it is necessary to draw the closest ancestor which is a container.\nElement.prototype.redraw = function redraw()\n{\n\tif ( ! this.document ) { return this ; }\n\t\n\tvar container = this.getParentContainer() ;\n\t\n\t//console.error( \"parentContainer:\" , container ) ;\n\tif ( ! container ) { this.draw() ; }\n\telse { container.draw() ; }\n\t\n\treturn this ;\n} ;\n\n\n\n// Draw all the children\nElement.prototype.descendantDraw = function descendantDraw( isSubcall )\n{\n\tvar i , iMax ;\n\t\n\t//console.error( '\\ndescendantDraw: ' , this.elementType , this.id , \"  (\" + this.children.length + \" children)\" ) ;\n\t\n\tif ( this.preDrawSelf )\n\t{\n\t\t//console.error( 'preDrawSelf: ' , this.elementType , this.id ) ;\n\t\tthis.preDrawSelf( ! isSubcall ) ;\n\t}\n\t\n\tfor ( i = 0 , iMax = this.children.length ; i < iMax ; i ++ )\n\t{\n\t\t//console.error( \">>>\" , i , iMax ) ;\n\t\tthis.children[ i ].descendantDraw( true ) ;\n\t}\n\t\n\tif ( isSubcall && this.postDrawSelf )\n\t{\n\t\t//console.error( 'postDrawSelf: ' , this.elementType , this.id ) ;\n\t\tthis.postDrawSelf( ! isSubcall ) ;\n\t}\n\t\n\treturn this ;\n} ;\n\n\n\n// Post-draw from the current element through all the ancestor chain\nElement.prototype.ascendantDraw = function ascendantDraw()\n{\n\t//console.error( '\\nascendantDraw: ' , this.elementType , this.id ) ;\n\tvar currentElement ;\n\t\n\tif ( this.postDrawSelf )\n\t{\n\t\t//console.error( 'postDrawSelf: ' , this.elementType , this.id ) ;\n\t\tthis.postDrawSelf( true ) ;\n\t}\n\t\n\tcurrentElement = this ;\n\t\n\twhile ( currentElement.parent && currentElement.outputDst !== currentElement.document.outputDst )\n\t{\n\t\tcurrentElement = currentElement.parent ;\n\t\t\n\t\tif ( currentElement.outputDst !== currentElement.inputDst && currentElement.postDrawSelf )\n\t\t{\n\t\t\t//console.error( 'postDrawSelf: ' , currentElement.elementType , currentElement.id ) ;\n\t\t\tcurrentElement.postDrawSelf( false ) ;\n\t\t}\n\t}\n\t\n\treturn this ;\n} ;\n\n\n\n// Draw cursor from the current element through all the ancestor chain\nElement.prototype.drawCursor = function drawCursor()\n{\n\tvar currentElement ;\n\t\n\tif ( this.drawSelfCursor )\n\t{\n\t\tthis.drawSelfCursor( true ) ;\n\t}\n\t\n\tcurrentElement = this ;\n\t\n\twhile ( currentElement.outputDst !== currentElement.document.outputDst && currentElement.parent )\n\t{\n\t\tcurrentElement = currentElement.parent ;\n\t\t\n\t\tif ( currentElement.drawSelfCursor )\n\t\t{\n\t\t\tcurrentElement.drawSelfCursor( false ) ;\n\t\t}\n\t}\n\t\n\treturn this ;\n} ;\n\n\n\n// Should be redefined\nElement.prototype.isContainer = false ;\t// true if it's a container, having a different inputDst and outputDst and local coords\nElement.prototype.computeBoundingBoxes = null ;\t// should be a function if this element can be drawn\nElement.prototype.preDrawSelf = null ;\t// should be a function if this element can be drawn\nElement.prototype.postDrawSelf = null ;\t// should be a function if this element can be drawn\nElement.prototype.drawSelfCursor = null ;\t// should be a function if this element's cursor can be drawn\nElement.prototype.getValue = function getValue() { return null ; } ;\nElement.prototype.setValue = function setValue() {} ;\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/document/Document.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\nvar Element = require( './Element.js' ) ;\nvar Container = require( './Container.js' ) ;\nvar ScreenBuffer = require( '../ScreenBuffer.js' ) ;\n\n\nfunction Document() { throw new Error( 'Use Document.create() instead' ) ; }\nmodule.exports = Document ;\n//Document.prototype = Object.create( Element.prototype ) ;\nDocument.prototype = Object.create( Container.prototype ) ;\nDocument.prototype.constructor = Document ;\nDocument.prototype.elementType = 'Document' ;\n\n\n\nDocument.create = function createDocument( options )\n{\n\tvar document = Object.create( Document.prototype ) ;\n\tdocument.create( options ) ;\n\treturn document ;\n} ;\n\n\n\nDocument.prototype.create = function create( options )\n{\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\toptions.outputX = 1 ;\n\toptions.outputY = 1 ;\n\toptions.outputWidth = options.outputDst.width ;\n\toptions.outputHeight = options.outputDst.height ;\n\t\n\t//Element.prototype.create.call( this , options ) ;\n\tContainer.prototype.create.call( this , options ) ;\n\t\n\t// A document do not have parent\n\tthis.parent = null ;\n\t\n\t// The document of a document is itself\n\tthis.document = this ;\n\t\n\t// Being the top-level element before the Terminal object, this must use delta-drawing\n\tthis.deltaDraw = true ;\n\t\n\tObject.defineProperties( this , {\n\t\tid: { value: '_document' + '_' + ( nextId ++ ) , enumerable: true } ,\n\t\teventSource: { value: options.eventSource } ,\n\t\tfocusElement: { value: null , enumerable: true , writable: true } ,\n\t\telements: { value: {} , enumerable: true } ,\n\t\tonEventSourceKey: { value: this.onEventSourceKey.bind( this ) , enumerable: true } ,\n\t\tonEventSourceMouse: { value: this.onEventSourceMouse.bind( this ) , enumerable: true } ,\n\t\tonEventSourceResize: { value: this.onEventSourceResize.bind( this ) , enumerable: true } ,\n\t} ) ;\n\t\n\tthis.eventSource.grabInput( { mouse: 'motion' } ) ;\n\t//this.eventSource.grabInput( { mouse: 'button' } ) ;\n\t\n\tthis.eventSource.on( 'key' , this.onEventSourceKey ) ;\n\tthis.eventSource.on( 'mouse' , this.onEventSourceMouse ) ;\n\tthis.eventSource.on( 'resize' , this.onEventSourceResize ) ;\n\t\n\t// Only draw if we are not a superclass of the object\n\tif ( this.elementType === 'Document' ) { this.draw() ; }\n} ;\n\n\n\nDocument.prototype.destroy = function destroy( isSubDestroy )\n{\n\tthis.eventSource.off( 'key' , this.onEventSourceKey ) ;\n\tthis.eventSource.off( 'mouse' , this.onEventSourceMouse ) ;\n\tthis.eventSource.off( 'resize' , this.onEventSourceResize ) ;\n\t\n\tElement.prototype.destroy.call( this , isSubDestroy ) ;\n} ;\n\n\n\n// Next element ID\nvar nextId = 0 ;\n\nDocument.prototype.assignId = function assignId( element , id )\n{\n\tif ( ! id || typeof id !== 'string' || id[ 0 ] === '_' || this.elements[ id ] )\n\t{\n\t\tid = '_' + element.elementType + '_' + ( nextId ++ ) ;\n\t}\n\t\n\tObject.defineProperty( element , 'id' , { value: id , enumerable: true , configurable: true } ) ;\n\tthis.elements[ id ] = element ;\n} ;\n\n\n\nDocument.prototype.giveFocusTo = function giveFocusTo( element , type )\n{\n\tif ( ! ( element instanceof Element ) ) { throw new TypeError( '' + element + ' is not an instance of Element.' ) ; }\n\tif ( ! type ) { type = 'direct' ; }\n\tif ( this.isAncestorOf( element ) ) { return this.giveFocusTo_( element , type ) ; }\n} ;\n\n\n\nDocument.prototype.giveFocusTo_ = function giveFocusTo_( element , type )\n{\n\tif ( this.focusElement !== element )\n\t{\n\t\tif ( this.focusElement ) { this.focusElement.emit( 'focus' , false , type , this.focusElement ) ; }\n\t\tthis.focusElement = element ;\n\t\tthis.focusElement.emit( 'focus' , true , type , this.focusElement ) ;\n\t\t\n\t\t/*\n\t\tconsole.error(\n\t\t\t'Giving focus to' , this.focusElement.content ,\n\t\t\tthis.focusElement.listenerCount( 'focus' ) ,\n\t\t\tthis.focusElement.listenerCount( 'key' )\n\t\t) ;\n\t\t*/\n\t}\n\t\n\t// Return false if the focus was given to a element that does not care about focus and key event\n\treturn ( this.focusElement.listenerCount( 'focus' ) || this.focusElement.listenerCount( 'key' ) ) ;\n} ;\n\n\n\nDocument.prototype.focusNext = function focusNext()\n{\n\tvar index , startingElement , currentElement , focusAware ;\n\t\n\tif ( ! this.focusElement || ! this.isAncestorOf( this.focusElement ) ) { currentElement = this ; }\n\telse { currentElement = this.focusElement ; }\n\t\n\tif ( currentElement === this && ! this.children.length ) { return ; }\n\t\n\tstartingElement = currentElement ;\n\t\n\tfor (;;)\n\t{\n\t\t//console.error( 'focusNext() loop1: ' , currentElement.id , \"(\" + startingElement.id + \")\" ) ;\n\t\tif ( currentElement.children.length )\n\t\t{\n\t\t\t// Give focus to the first child of the element\n\t\t\tcurrentElement = currentElement.children[ 0 ] ;\n\t\t\tfocusAware = this.giveFocusTo_( currentElement , 'cycle' ) ;\n\t\t}\n\t\telse if ( currentElement.parent )\n\t\t{\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\t//console.error( 'focusNext() loop2' ) ;\n\t\t\t\tindex = currentElement.parent.children.indexOf( currentElement ) ;\n\t\t\t\t\n\t\t\t\tif ( index + 1 < currentElement.parent.children.length )\n\t\t\t\t{\n\t\t\t\t\t// Give focus to the next sibling\n\t\t\t\t\tcurrentElement = currentElement.parent.children[ index + 1 ] ;\n\t\t\t\t\tfocusAware = this.giveFocusTo_( currentElement , 'cycle' ) ;\n\t\t\t\t\tbreak ;\n\t\t\t\t}\n\t\t\t\telse if ( currentElement.parent.parent )\n\t\t\t\t{\n\t\t\t\t\tcurrentElement = currentElement.parent ;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We are at the top-level, just below the document, so cycle again at the first-top-level child\n\t\t\t\t\t\n\t\t\t\t\t// This check fixes infinite loop\n\t\t\t\t\tif ( startingElement === currentElement.parent ) { return ; }\n\t\t\t\t\t\n\t\t\t\t\tcurrentElement = currentElement.parent.children[ 0 ] ;\n\t\t\t\t\tfocusAware = this.giveFocusTo_( currentElement , 'cycle' ) ;\n\t\t\t\t\tbreak ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Nothing to do: no children, no parent, nothing...\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\t// Exit if the focus was given to a focus-aware element or if we have done a full loop already\n\t\t//console.error( 'end of loop: ' , focusAware , startingElement.content , currentElement.content ) ;\n\t\tif ( focusAware || startingElement === currentElement ) { break ; }\n\t}\n} ;\n\n\n\nDocument.prototype.focusPrevious = function focusPrevious()\n{\n\tvar index , startingElement , currentElement , focusAware ;\n\t\n\tif ( ! this.focusElement || ! this.isAncestorOf( this.focusElement ) ) { currentElement = this ; }\n\telse { currentElement = this.focusElement ; }\n\t\n\tstartingElement = currentElement ;\n\t\n\tfor (;;)\n\t{\n\t\tif ( currentElement.parent )\n\t\t{\n\t\t\tindex = currentElement.parent.children.indexOf( currentElement ) ;\n\t\t\t\n\t\t\tif ( index - 1 >= 0 )\n\t\t\t{\n\t\t\t\t// Give focus to the last child of the last child of the ... of the previous sibling\n\t\t\t\tcurrentElement = currentElement.parent.children[ index - 1 ] ;\n\t\t\t\t\n\t\t\t\twhile ( currentElement.children.length )\n\t\t\t\t{\n\t\t\t\t\tcurrentElement = currentElement.children[ currentElement.children.length - 1 ] ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfocusAware = this.giveFocusTo_( currentElement , 'cycle' ) ;\n\t\t\t}\n\t\t\telse if ( currentElement.parent.parent )\n\t\t\t{\n\t\t\t\tcurrentElement = currentElement.parent ;\n\t\t\t\tfocusAware = this.giveFocusTo_( currentElement , 'cycle' ) ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We are at the top-level, just below the document, so cycle again to the last child of the last child\n\t\t\t\t// of the ... of the last-top-level child\n\t\t\t\t\n\t\t\t\t// This check fixes infinite loop\n\t\t\t\tif ( startingElement === currentElement.parent ) { return ; }\n\t\t\t\t\n\t\t\t\tcurrentElement = currentElement.parent.children[ currentElement.parent.children.length - 1 ] ;\n\t\t\t\t\n\t\t\t\twhile ( currentElement.children.length )\n\t\t\t\t{\n\t\t\t\t\tcurrentElement = currentElement.children[ currentElement.children.length - 1 ] ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfocusAware = this.giveFocusTo_( currentElement , 'cycle' ) ;\n\t\t\t}\n\t\t}\n\t\telse if ( currentElement.children.length )\n\t\t{\n\t\t\t// Give focus to the last child of the element\n\t\t\tcurrentElement = currentElement.children[ currentElement.children.length - 1 ] ;\n\t\t\t\n\t\t\twhile ( currentElement.children.length )\n\t\t\t{\n\t\t\t\tcurrentElement = currentElement.children[ currentElement.children.length - 1 ] ;\n\t\t\t}\n\t\t\t\n\t\t\tfocusAware = this.giveFocusTo_( currentElement , 'cycle' ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Nothing to do: no children, no parent, nothing...\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\t// Exit if the focus was given to a focus-aware element or if we have done a full loop already\n\t\t//console.error( 'end of loop: ' , focusAware , startingElement.content , currentElement.content ) ;\n\t\tif ( focusAware || startingElement === currentElement ) { break ; }\n\t}\n} ;\n\n\n\nDocument.prototype.onEventSourceKey = function onEventSourceKey( key , trash , data )\n{\n\tif ( this.focusElement )\n\t{\n\t\tthis.bubblingEvent( this.focusElement , key , trash , data ) ;\n\t}\n\telse\n\t{\n\t\tthis.defaultKeyHandling( key , trash , data ) ;\n\t}\n} ;\n\n\n\nDocument.prototype.bubblingEvent = function bubblingEvent( element , key , trash , data )\n{\n\tvar self = this ;\n\t\n\tif ( element !== this )\n\t{\n\t\telement.emit( 'key' , key , trash , data , function( interruption , event ) {\n\t\t\t\n\t\t\tif ( ! interruption )\n\t\t\t{\n\t\t\t\tif ( element.parent ) { self.bubblingEvent( element.parent , key , trash , data ) ; }\n\t\t\t\telse { self.defaultKeyHandling( key , trash , data ) ; }\n\t\t\t}\n\t\t} ) ;\n\t}\n\telse\n\t{\n\t\tthis.defaultKeyHandling( key , trash , data ) ;\n\t}\n} ;\n\n\n\nDocument.prototype.defaultKeyHandling = function defaultKeyHandling( key , trash , data )\n{\n\tthis.emit( 'key' , key , trash , data ) ;\n\t\n\tswitch ( key )\n\t{\n\t\tcase 'TAB' :\n\t\t\tthis.focusNext() ;\n\t\t\tbreak ;\n\t\tcase 'SHIFT_TAB' :\n\t\t\tthis.focusPrevious() ;\n\t\t\tbreak ;\n\t}\n} ;\n\n\n\nDocument.prototype.onEventSourceMouse = function onEventSourceMouse( name , data )\n{\n\tvar matches ;\n\t\n\tswitch ( name )\n\t{\n\t\tcase 'MOUSE_LEFT_BUTTON_PRESSED' :\n\t\t\tmatches = this.childrenAt( data.x - this.outputX , data.y - this.outputY ) ;\n\t\t\t//console.error( \"\\n\\n\\n\\n\" , matches ) ;\n\t\t\t\n\t\t\tif ( ! matches.length ) { return ; }\n\t\t\t\n\t\t\tmatches[ 0 ].element.emit( 'click' , { x: matches[ 0 ].x , y: matches[ 0 ].y } , matches[ 0 ].element ) ;\n\t\t\tbreak ;\n\t\t\t\n\t\tcase 'MOUSE_MOTION' :\n\t\t\t// Unflood mouse motions\n\t\t\tif ( this.mouseMotionTimer ) { clearTimeout( this.mouseMotionTimer ) ; }\n\t\t\tthis.mouseMotionTimer = setTimeout( this.mouseMotion.bind( this , data ) , 50 ) ;\n\t\t\tbreak ;\n\t}\n} ;\n\n\n\nDocument.prototype.mouseMotion = function mouseMotion( data )\n{\n\tvar matches ;\n\t\n\tthis.mouseMotionTimer = null ;\n\t\n\tmatches = this.childrenAt( data.x - this.outputX , data.y - this.outputY ) ;\n\t//console.error( \"\\n\\n\\n\\n\" , matches ) ;\n\t\n\tif ( ! matches.length ) { return ; }\n\t\n\tmatches[ 0 ].element.emit( 'hover' , { x: matches[ 0 ].x , y: matches[ 0 ].y } , matches[ 0 ].element ) ;\n} ;\n\n\n\nDocument.prototype.onEventSourceResize = function onEventSourceResize( width , height )\n{\n\t//console.error( \"Document#onEventSourceResize() \" , width , height ) ;\n\t\n\t// Always resize inputDst to match outputDst (Terminal)\n\tthis.resizeInput( {\n\t\tx: 0 ,\n\t\ty: 0 ,\n\t\twidth: width ,\n\t\theight: height\n\t} ) ;\n\t\n\t//this.inputDst.clear() ;\n\t//this.postDrawSelf() ;\n\t\n\tthis.draw() ;\n} ;\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/document/Container.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Container: an enclosed surface (ScreenBuffer).\n// Later it will feature a viewport and an internal surface, to allow scrolling.\n\n\n\n// Load modules\nvar Element = require( './Element.js' ) ;\nvar ScreenBuffer = require( '../ScreenBuffer.js' ) ;\n\n\n\nfunction Container() { throw new Error( 'Use Container.create() instead' ) ; }\nmodule.exports = Container ;\nContainer.prototype = Object.create( Element.prototype ) ;\nContainer.prototype.constructor = Container ;\nContainer.prototype.elementType = 'Container' ;\n\nContainer.prototype.isContainer = true ;\n\n\n\nContainer.create = function createContainer( options )\n{\n\tvar container = Object.create( Container.prototype ) ;\n\tcontainer.create( options ) ;\n\treturn container ;\n} ;\n\n\n\nContainer.prototype.create = function create( options )\n{\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tElement.prototype.create.call( this , options ) ;\n\t\n\t// No scrolling for instance: input coords is equals to output coords\n\tthis.inputX = options.inputX || this.outputX ;\n\tthis.inputY = options.inputY || this.outputY ;\n\tthis.inputWidth = options.inputWidth || this.outputWidth ;\n\tthis.inputHeight = options.inputHeight || this.outputHeight ;\n\t\n\tthis.inputDst = ScreenBuffer.create( {\n\t\tdst: this.outputDst ,\n\t\tx: this.inputX ,\n\t\ty: this.inputY ,\n\t\twidth: this.inputWidth ,\n\t\theight: this.inputHeight\n\t} ) ;\n\t\n\tObject.defineProperties( this , {\n\t\tdeltaDraw: { value: false , enumerable: true , writable: true } ,\t// Useful for Document, not so useful for other containers\n\t\tbackgroundAttr: { value: options.backgroundAttr || { bgColor: 'black' } , enumerable: true , writable: true } ,\n\t} ) ;\n\t\n\t// Only draw if we are not a superclass of the object\n\tif ( this.elementType === 'Container' ) { this.draw() ; }\n} ;\n\n\n\nContainer.prototype.destroy = function destroy( isSubDestroy )\n{\n\tElement.prototype.destroy.call( this , isSubDestroy ) ;\n} ;\n\n\n\n// /!\\ TODO /!\\\n/*\n\tAccept ScreenBuffer#resize() argument: x, y, width, height.\n\tShould it support output* and input* args?\n*/\nContainer.prototype.resize =\nContainer.prototype.resizeInput = function resizeInput( to )\n{\n\tif ( ! to.x ) { to.x = 0 ; }\n\tif ( ! to.y ) { to.y = 0 ; }\n\t\n\tthis.inputDst.resize( to ) ;\n} ;\n\n\n\nContainer.prototype.moveTo = function moveTo( x , y )\n{\n\tthis.outputX = this.inputDst.x = x ;\n\tthis.outputY = this.inputDst.y = y ;\n} ;\n\n\n\nContainer.prototype.preDrawSelf = function preDrawSelf()\n{\n\tthis.inputDst.fill( { char: ' ' , attr: this.backgroundAttr } ) ;\n} ;\n\n\n\nContainer.prototype.postDrawSelf = function postDrawSelf()\n{\n\t// No scrolling for instance, so nothing to do, just draw it\n\t//this.inputDst.x = this.outputX ;\n\t//this.inputDst.y = this.outputY ;\n\t\n\tthis.inputDst.draw( {\n\t\tdelta: this.deltaDraw\t\t// Draw only diff or not?\n\t} ) ;\n} ;\n\n\n\nContainer.prototype.drawSelfCursor = function drawSelfCursor( elementTargeted )\n{\n\tif ( elementTargeted ) { this.restoreCursor() ; }\n\telse { this.inputDst.drawCursor() ; }\n} ;\n\n\n\nContainer.prototype.onOutputDstResize = function onOutputDstResize( data )\n{\n} ;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/document/Text.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\nvar Element = require( './Element.js' ) ;\nvar ScreenBuffer = require( '../ScreenBuffer.js' ) ;\nvar TextBuffer = require( '../TextBuffer.js' ) ;\n\n\n\nfunction Text() { throw new Error( 'Use Text.create() instead' ) ; }\nmodule.exports = Text ;\nText.prototype = Object.create( Element.prototype ) ;\nText.prototype.constructor = Text ;\nText.prototype.elementType = 'Text' ;\n\n\n\nText.create = function createText( options )\n{\n\tvar text = Object.create( Text.prototype ) ;\n\ttext.create( options ) ;\n\treturn text ;\n} ;\n\n\n\nText.prototype.create = function create( options )\n{\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tElement.prototype.create.call( this , options ) ;\n\t\n\tObject.defineProperties( this , {\n\t\ttextAttr: { value: options.textAttr || options.attr || { bgColor: 'black' , color: 'white' } , enumerable: true , writable: true } ,\n\t\temptyAttr: { value: options.emptyAttr || options.textAttr || options.attr || { bgColor: 'black' , color: 'white' } , enumerable: true , writable: true } ,\n\t\ttextBuffer: { value: null , enumerable: true , writable: true } ,\n\t\tcontentSize: { value: null , enumerable: true , writable: true } ,\n\t} ) ;\n\t\n\tthis.textBuffer = TextBuffer.create( {\n\t\tdst: this.outputDst ,\n\t\tx: this.outputX ,\n\t\ty: this.outputY\n\t} ) ;\n\t\n\tthis.textAttr = ScreenBuffer.object2attr( this.textAttr ) ;\n\tthis.emptyAttr = ScreenBuffer.object2attr( this.emptyAttr ) ;\n\tthis.textBuffer.setEmptyCellAttr( this.emptyAttr ) ;\n\t\n\tthis.setContent( this.content , true ) ;\n\t\n\t// Only draw if we are not a superclass of the object\n\tif ( this.elementType === 'Text' ) { this.draw() ; }\n} ;\n\n\n\nText.prototype.getContent = function getContent()\n{\n\treturn this.textBuffer.getText() ;\n} ;\n\n\n\nText.prototype.setContent = function setContent( content , dontDraw )\n{\n\tvar contentSize ;\n\t\n\tthis.content = content ;\n\t\n\tthis.textBuffer.setText( this.content ) ;\n\tcontentSize = this.textBuffer.getContentSize() ;\n\tthis.outputWidth = contentSize.width ;\n\tthis.outputHeight = contentSize.height ;\n\t\n\tthis.textBuffer.setAttrCodeRegion( this.textAttr ) ;\n\t\n\tif ( ! dontDraw ) { this.redraw() ; }\n} ;\n\n\n\nText.prototype.destroy = function destroy( isSubDestroy )\n{\n\tElement.prototype.destroy.call( this , isSubDestroy ) ;\n} ;\n\n\n\nText.prototype.postDrawSelf = function postDrawSelf()\n{\n\t//this.outputDst.put( { x: this.outputX , y: this.outputY , attr: this.textAttr } , this.content ) ;\n\tthis.textBuffer.draw( { srcClipRect: { x: 0 , y: 0 , width: this.outputWidth , height: this.outputHeight } } ) ;\n} ;\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/document/Button.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\nvar Element = require( './Element.js' ) ;\n\n\nfunction Button() { throw new Error( 'Use Button.create() instead' ) ; }\nmodule.exports = Button ;\nButton.prototype = Object.create( Element.prototype ) ;\nButton.prototype.constructor = Button ;\nButton.prototype.elementType = 'Button' ;\n\n\n\nButton.create = function createButton( options )\n{\n\tvar button = Object.create( Button.prototype ) ;\n\tbutton.create( options ) ;\n\treturn button ;\n} ;\n\n\n\nButton.prototype.create = function create( options )\n{\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\toptions.width = options.content.length || 1 ;\n\toptions.height = 1 ;\n\t\n\tElement.prototype.create.call( this , options ) ;\n\t\n\tObject.defineProperties( this , {\n\t\tfocusAttr: { value: options.focusAttr || { bgColor: 'blue' } , enumerable: true , writable: true } ,\n\t\tblurAttr: { value: options.blurAttr || { bgColor: 'brightBlack' } , enumerable: true , writable: true } ,\n\t\tcurrentAttr: { value: null , enumerable: true , writable: true } ,\n\t\tanimationCountdown: { value: 0 , enumerable: true , writable: true } ,\n\t\tonKey: { value: this.onKey.bind( this ) , enumerable: true } ,\n\t\tonFocus: { value: this.onFocus.bind( this ) , enumerable: true } ,\n\t\tonHover: { value: this.onHover.bind( this ) , enumerable: true } ,\n\t\tonClick: { value: this.onClick.bind( this ) , enumerable: true } ,\n\t} ) ;\n\t\n\tthis.currentAttr = this.blurAttr ;\n\t\n\tthis.on( 'key' , this.onKey ) ;\n\tthis.on( 'focus' , this.onFocus ) ;\n\tthis.on( 'click' , this.onClick ) ;\n\tthis.on( 'hover' , this.onHover ) ;\n\t\n\tthis.draw() ;\n} ;\n\n\n\nButton.prototype.destroy = function destroy( isSubDestroy )\n{\n\tthis.off( 'key' , this.onKey ) ;\n\tthis.off( 'focus' , this.onFocus ) ;\n\tthis.off( 'click' , this.onClick ) ;\n\tthis.off( 'hover' , this.onHover ) ;\n\t\n\tElement.prototype.destroy.call( this , isSubDestroy ) ;\n} ;\n\n\n\nButton.prototype.postDrawSelf = function postDrawSelf()\n{\n\tif ( ! this.outputDst ) { return this ; }\n\t\n\tthis.outputDst.put( { x: this.outputX , y: this.outputY , attr: this.currentAttr } , this.content ) ;\n} ;\n\n\n\nButton.prototype.drawSelfCursor = function drawSelfCursor()\n{\n\t// Move the cursor back to the first cell\n\tthis.outputDst.moveTo( this.outputX , this.outputY ) ;\n\tthis.outputDst.drawCursor() ;\n} ;\n\n\n\n// Blink effect, when the button is submitted\nButton.prototype.blink = function blink()\n{\n\tif ( ! this.animationCountdown ) { this.animationCountdown = 4 ; }\n\telse { this.animationCountdown -- ; }\n\t\n\tif ( this.animationCountdown )\n\t{\n\t\tif ( this.animationCountdown % 2 ) { this.currentAttr = this.focusAttr ; }\n\t\telse { this.currentAttr = this.blurAttr ; }\n\t\t\n\t\tthis.draw() ;\n\t\t\n\t\tsetTimeout( this.blink.bind( this ) , 80 ) ;\n\t}\n\telse\n\t{\n\t\tthis.currentAttr = this.hasFocus ? this.focusAttr : this.blurAttr ;\n\t\tthis.draw() ;\n\t}\n} ;\n\n\n\nButton.prototype.onFocus = function onFocus( focus , type )\n{\n\tthis.hasFocus = focus ;\n\tthis.currentAttr = this.hasFocus ? this.focusAttr : this.blurAttr ;\n\tthis.draw() ;\n} ;\n\n\n\nButton.prototype.onKey = function onKey( key , trash , data )\n{\n\tswitch ( key )\n\t{\n\t\tcase 'KP_ENTER' :\n\t\tcase 'ENTER' :\n\t\t\tthis.emit( 'submit' , this.value , undefined , this ) ;\n\t\t\tthis.blink() ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\treturn ;\t// Bubble up\n\t}\n\t\n\treturn true ;\t// Do not bubble up\n} ;\n\n\n\nButton.prototype.onHover = function onHover( data )\n{\n\tthis.document.giveFocusTo( this , 'hover' ) ;\n} ;\n\n\n\nButton.prototype.onClick = function onClick( data )\n{\n\tthis.document.giveFocusTo( this , 'select' ) ;\n\tthis.emit( 'submit' , this.value , undefined , this ) ;\n\tthis.blink() ;\n} ;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/document/TextInput.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\nvar string = require( 'string-kit' ) ;\n//var autoComplete = require( './autoComplete.js' ) ;\nvar ScreenBuffer = require( '../ScreenBuffer.js' ) ;\nvar TextBuffer = require( '../TextBuffer.js' ) ;\n\nvar Element = require( './Element.js' ) ;\n\n\nfunction TextInput() { throw new Error( 'Use TextInput.create() instead' ) ; }\nmodule.exports = TextInput ;\nTextInput.prototype = Object.create( Element.prototype ) ;\nTextInput.prototype.constructor = TextInput ;\nTextInput.prototype.elementType = 'TextInput' ;\n\n\n\nTextInput.create = function createTextInput( options )\n{\n\tvar textInput = Object.create( TextInput.prototype ) ;\n\ttextInput.create( options ) ;\n\treturn textInput ;\n} ;\n\n\n\nTextInput.prototype.create = function create( options )\n{\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tElement.prototype.create.call( this , options ) ;\n\t\n\tObject.defineProperties( this , {\n\t\ttextAttr: { value: options.textAttr || { bgColor: 'blue' } , enumerable: true , writable: true } ,\n\t\temptyAttr: { value: options.emptyAttr || { bgColor: 'blue' } , enumerable: true , writable: true } ,\n\t\tlabelFocusAttr: { value: options.labelFocusAttr || { bold: true } , enumerable: true , writable: true } ,\n\t\tlabelBlurAttr: { value: options.labelBlurAttr || { dim: true } , enumerable: true , writable: true } ,\n\t\thidden: { value: options.hidden , enumerable: true , writable: true } ,\n\t\tonKey: { value: this.onKey.bind( this ) , enumerable: true } ,\n\t\tonFocus: { value: this.onFocus.bind( this ) , enumerable: true } ,\n\t\tonClick: { value: this.onClick.bind( this ) , enumerable: true } ,\n\t\tscreenBuffer: { value: null , enumerable: true , writable: true } ,\n\t\tlabelTextBuffer: { value: null , enumerable: true , writable: true } ,\n\t\tinputTextBuffer: { value: null , enumerable: true , writable: true } ,\n\t} ) ;\n\t\n\tif ( options.keyBindings ) { this.keyBindings = options.keyBindings ; }\n\t\n\tthis.screenBuffer = ScreenBuffer.create( {\n\t\tdst: this.outputDst ,\n\t\tx: this.outputX ,\n\t\ty: this.outputY ,\n\t\twidth: this.outputWidth ,\n\t\theight: this.outputHeight\n\t} ) ;\n\t\n\tif ( this.label )\n\t{\n\t\tthis.labelTextBuffer = TextBuffer.create( {\n\t\t\tdst: this.screenBuffer ,\n\t\t\twidth: this.label.length ,\n\t\t\theight: 1\n\t\t} ) ;\n\t\t\n\t\tthis.labelTextBuffer.setText( this.label ) ;\n\t\t\n\t\tthis.inputTextBuffer = TextBuffer.create( {\n\t\t\tdst: this.screenBuffer ,\n\t\t\tx: this.label.length ,\n\t\t\thidden: this.hidden ,\n\t\t\tforceInBound: true\n\t\t} ) ;\n\t}\n\telse\n\t{\n\t\tthis.inputTextBuffer = TextBuffer.create( {\n\t\t\tdst: this.screenBuffer ,\n\t\t\tforceInBound: true\n\t\t} ) ;\n\t}\n\t\n\tthis.textAttr = ScreenBuffer.object2attr( this.textAttr ) ;\n\tthis.emptyAttr = ScreenBuffer.object2attr( this.emptyAttr ) ;\n\tthis.labelFocusAttr = ScreenBuffer.object2attr( this.labelFocusAttr ) ;\n\tthis.labelBlurAttr = ScreenBuffer.object2attr( this.labelBlurAttr ) ;\n\t\n\tthis.inputTextBuffer.setEmptyCellAttr( this.emptyAttr ) ;\n\t\n\tthis.on( 'key' , this.onKey ) ;\n\tthis.on( 'focus' , this.onFocus ) ;\n\tthis.on( 'click' , this.onClick ) ;\n\t\n\t// Only draw if we are not a superclass of the object\n\tif ( this.elementType === 'TextInput' ) { this.draw() ; }\n} ;\n\n\n\nTextInput.prototype.destroy = function destroy( isSubDestroy )\n{\n\tthis.off( 'key' , this.onKey ) ;\n\tthis.off( 'focus' , this.onFocus ) ;\n\tthis.off( 'click' , this.onClick ) ;\n\t\n\tElement.prototype.destroy.call( this , isSubDestroy ) ;\n} ;\n\n\n\nTextInput.prototype.keyBindings = {\n\tENTER: 'submit' ,\n\tKP_ENTER: 'submit' ,\n\t//ESCAPE: 'cancel' ,\n\tBACKSPACE: 'backDelete' ,\n\tDELETE: 'delete' ,\n\tLEFT: 'backward' ,\n\tRIGHT: 'forward' ,\n\tUP: 'up' ,\n\tDOWN: 'down' ,\n\tHOME: 'startOfLine' ,\n\tEND: 'endOfLine' ,\n\tTAB: 'autoComplete'\n} ;\n\n\n\nTextInput.prototype.postDrawSelf = function postDrawSelf()\n{\n\tif ( this.labelTextBuffer )\n\t{\n\t\tthis.labelTextBuffer.setEmptyCellAttr( this.hasFocus ? this.labelFocusAttr : this.labelBlurAttr ) ;\n\t\tthis.labelTextBuffer.setAttrCodeRegion( this.hasFocus ? this.labelFocusAttr : this.labelBlurAttr ) ;\n\t\tthis.labelTextBuffer.draw() ;\n\t}\n\t\n\tthis.inputTextBuffer.draw() ;\n\tthis.screenBuffer.draw() ;\n} ;\n\n\n\nTextInput.prototype.drawSelfCursor = function drawSelfCursor()\n{\n\tthis.inputTextBuffer.drawCursor() ;\n\tthis.screenBuffer.drawCursor() ;\n} ;\n\n\n\nTextInput.prototype.getValue = function getValue()\n{\n\treturn this.inputTextBuffer.getText() ;\n} ;\n\n\n\nTextInput.prototype.onKey = function onKey( key , trash , data )\n{\n\tif ( data && data.isCharacter )\n\t{\n\t\tthis.inputTextBuffer.insert( key , this.textAttr ) ;\n\t\tthis.draw() ;\n\t}\n\telse\n\t{\n\t\t// Here we have a special key\n\t\t\n\t\tswitch( this.keyBindings[ key ] )\n\t\t{\n\t\t\tcase 'submit' :\n\t\t\t\tthis.emit( 'submit' , this.inputTextBuffer.getText() , undefined , this ) ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'newLine' :\n\t\t\t\tthis.inputTextBuffer.newLine() ;\n\t\t\t\tthis.draw() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\t/*\n\t\t\tcase 'cancel' :\n\t\t\t\tif ( options.cancelable ) { cleanup() ; }\n\t\t\t\tbreak ;\n\t\t\t*/\n\t\t\t\n\t\t\tcase 'backDelete' :\n\t\t\t\tthis.inputTextBuffer.backDelete() ;\n\t\t\t\tthis.draw() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'delete' :\n\t\t\t\tthis.inputTextBuffer.delete() ;\n\t\t\t\tthis.draw() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'backward' :\n\t\t\t\tthis.inputTextBuffer.moveBackward() ;\n\t\t\t\tthis.drawCursor() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'forward' :\n\t\t\t\tthis.inputTextBuffer.moveForward() ;\n\t\t\t\tthis.drawCursor() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'startOfLine' :\n\t\t\t\tthis.inputTextBuffer.moveToColumn( 0 ) ;\n\t\t\t\tthis.drawCursor() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'endOfLine' :\n\t\t\t\tthis.inputTextBuffer.moveToEndOfLine() ;   \n\t\t\t\tthis.drawCursor() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'down' :\n\t\t\t\tthis.inputTextBuffer.moveDown() ;\n\t\t\t\tthis.drawCursor() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'up' :\n\t\t\t\tthis.inputTextBuffer.moveUp() ;\n\t\t\t\tthis.drawCursor() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'left' :\n\t\t\t\tthis.inputTextBuffer.moveLeft() ;\n\t\t\t\tthis.drawCursor() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tcase 'right' :\n\t\t\t\tthis.inputTextBuffer.moveRight() ;\n\t\t\t\tthis.drawCursor() ;\n\t\t\t\tbreak ;\n\t\t\t\n\t\t\tdefault :\n\t\t\t\treturn ;\t// Bubble up\n\t\t}\n\t}\n\t\n\treturn true ;\t\t// Do not bubble up\n} ;\n\n\n\nTextInput.prototype.onFocus = function onFocus( focus , type )\n{\n\tthis.hasFocus = focus ;\n\tthis.draw() ;\n} ;\n\n\n\nTextInput.prototype.onClick = function onClick( data )\n{\n\tthis.document.giveFocusTo( this , 'select' ) ;\n} ;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/document/Form.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\nvar Element = require( './Element.js' ) ;\nvar TextInput = require( './TextInput.js' ) ;\nvar Button = require( './Button.js' ) ;\n\n\nfunction Form() { throw new Error( 'Use Form.create() instead' ) ; }\nmodule.exports = Form ;\nForm.prototype = Object.create( Element.prototype ) ;\nForm.prototype.constructor = Form ;\nForm.prototype.elementType = 'Form' ;\n\n\n\nForm.create = function createForm( options )\n{\n\tvar form = Object.create( Form.prototype ) ;\n\tform.create( options ) ;\n\treturn form ;\n} ;\n\n\n\nForm.prototype.create = function create( options )\n{\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tif ( ! options.outputWidth && ! options.width ) { options.outputWidth = 78 ; }\n\t\n\tElement.prototype.create.call( this , options ) ;\n\t\n\tObject.defineProperties( this , {\n\t\ttextInputsDef: { value: options.textInputs || [] , enumerable: true , writable: true } ,\n\t\ttextInputs: { value: [] , enumerable: true , writable: true } ,\n\t\tbuttonsDef: { value: options.buttons || [] , enumerable: true , writable: true } ,\n\t\tbuttons: { value: [] , enumerable: true , writable: true } ,\n\t\tfocusChild: { value: null , enumerable: true , writable: true } ,\n\t\tonButtonSubmit: { value: this.onButtonSubmit.bind( this ) , enumerable: true } ,\n\t\tonKey: { value: this.onKey.bind( this ) , enumerable: true } ,\n\t\tonFocus: { value: this.onFocus.bind( this ) , enumerable: true } ,\n\t\t\n\t\t// Global default attributes\n\t\ttextAttr: { value: options.textAttr || null , enumerable: true , writable: true } ,\n\t\temptyAttr: { value: options.emptyAttr || null , enumerable: true , writable: true } ,\n\t\tlabelFocusAttr: { value: options.labelFocusAttr || null , enumerable: true , writable: true } ,\n\t\tlabelBlurAttr: { value: options.labelBlurAttr || null , enumerable: true , writable: true } ,\n\t\tbuttonFocusAttr: { value: options.buttonFocusAttr || null , enumerable: true , writable: true } ,\n\t\tbuttonBlurAttr: { value: options.buttonBlurAttr || null , enumerable: true , writable: true } ,\n\t} ) ;\n\t\n\tif ( options.keyBindings ) { this.keyBindings = options.keyBindings ; }\n\tif ( options.textInputKeyBindings ) { this.textInputKeyBindings = options.textInputKeyBindings ; }\n\t\n\tthis.initChildren() ;\n\t\n\tthis.on( 'key' , this.onKey ) ;\n\tthis.on( 'focus' , this.onFocus ) ;\n\t\n\t// Only draw if we are not a superclass of the object\n\tif ( this.elementType === 'Form' ) { this.draw() ; }\n} ;\n\n\n\nForm.prototype.destroy = function destroy( isSubDestroy )\n{\n\tthis.off( 'key' , this.onKey ) ;\n\tthis.off( 'focus' , this.onFocus ) ;\n\t\n\tElement.prototype.destroy.call( this , isSubDestroy ) ;\n} ;\n\n\n\nForm.prototype.textInputKeyBindings = {\n\tBACKSPACE: 'backDelete' ,\n\tDELETE: 'delete' ,\n\tLEFT: 'backward' ,\n\tRIGHT: 'forward' ,\n//\tUP: 'up' ,\n//\tDOWN: 'down' ,\n\tHOME: 'startOfLine' ,\n\tEND: 'endOfLine'\n} ;\n\n\n\nForm.prototype.keyBindings = {\n\tLEFT: 'previous' ,\n\tRIGHT: 'next' ,\n\tUP: 'previous' ,\n\tDOWN: 'next' ,\n\tENTER: 'next' ,\n\tKP_ENTER: 'next'\n} ;\n\n\n\n// Create TextInput and Button automatically\nForm.prototype.initChildren = function initChildren()\n{\n\tvar i , iMax ,\n\t\tlabelMaxLength = 0 , label ,\n\t\tbuttonsTextLength = 0 , buttonSpacing = 0 , buttonOffsetX , buttonOffsetY ;\n\t\n\t\n\t// TextInput part\n\tiMax = this.textInputsDef.length ;\n\t\n\tfor ( i = 0 ; i < iMax ; i ++ )\n\t{\n\t\tif ( this.textInputsDef[ i ].label.length > labelMaxLength ) { labelMaxLength = this.textInputsDef[ i ].label.length ; }\n\t}\n\t\n\tfor ( i = 0 ; i < iMax ; i ++ )\n\t{\n\t\tlabel = this.textInputsDef[ i ].label + ' '.repeat( labelMaxLength - this.textInputsDef[ i ].label.length ) ;\n\t\t\n\t\tthis.textInputs[ i ] = TextInput.create( {\n\t\t\tparent: this ,\n\t\t\tlabel: label ,\n\t\t\tkey: this.textInputsDef[ i ].key ,\n\t\t\toutputX: this.outputX , \n\t\t\toutputY: this.outputY + i ,\n\t\t\toutputWidth: this.textInputsDef[ i ].outputWidth || this.textInputsDef[ i ].width || this.outputWidth ,\n\t\t\toutputHeight: 1 ,\n\t\t\ttextAttr: this.textInputsDef[ i ].textAttr || this.textAttr ,\n\t\t\temptyAttr: this.textInputsDef[ i ].emptyAttr || this.emptyAttr ,\n\t\t\thidden: this.textInputsDef[ i ].hidden ,\n\t\t\tlabelFocusAttr: this.textInputsDef[ i ].labelFocusAttr || this.labelFocusAttr ,\n\t\t\tlabelBlurAttr: this.textInputsDef[ i ].labelBlurAttr || this.labelBlurAttr ,\n\t\t\tkeyBindings: this.textInputKeyBindings ,\n\t\t} ) ;\n\t}\n\t\n\t\n\t// Submit Button part\n\tif ( ! this.buttonsDef.length )\n\t{\n\t\tthis.buttonsDef.push( {\n\t\t\tcontent: 'Submit' ,\n\t\t\tvalue: 'submit'\n\t\t} ) ;\n\t}\n\t\n\tiMax = this.buttonsDef.length ;\n\t\n\tfor ( i = 0 ; i < iMax ; i ++ ) { buttonsTextLength += this.buttonsDef[ i ].content.length ; }\n\tbuttonSpacing = Math.floor( ( this.outputWidth - buttonsTextLength ) / ( this.buttonsDef.length + 1 ) ) ;\n\t\n\tbuttonOffsetX = buttonSpacing ;\n\tbuttonOffsetY = this.textInputsDef.length + 1 ;\n\t\n\tfor ( i = 0 ; i < iMax ; i ++ )\n\t{\n\t\tthis.buttons[ i ] = Button.create( {\n\t\t\tparent: this ,\n\t\t\tcontent: this.buttonsDef[ i ].content ,\n\t\t\tvalue: this.buttonsDef[ i ].value ,\n\t\t\toutputX: this.outputX + buttonOffsetX , \n\t\t\toutputY: this.outputY + buttonOffsetY ,\n\t\t\tfocusAttr: this.buttonsDef[ i ].focusAttr || this.buttonFocusAttr ,\n\t\t\tblurAttr: this.buttonsDef[ i ].blurAttr || this.buttonBlurAttr ,\n\t\t} ) ;\n\t\t\n\t\tthis.buttons[ i ].on( 'submit' , this.onButtonSubmit ) ;\n\t\t\n\t\tbuttonOffsetX += this.buttonsDef[ i ].content.length + buttonSpacing ;\n\t}\n\t\n} ;\n\n\n\nForm.prototype.getValue = function getValue()\n{\n\tvar i , iMax , values = {} ;\n\t\n\tiMax = this.textInputs.length ;\n\t\n\tfor ( i = 0 ; i < iMax ; i ++ )\n\t{\n\t\tvalues[ this.textInputs[ i ].key ] = this.textInputs[ i ].getValue() ;\n\t}\n\t\n\treturn values ;\n} ;\n\n\n\nForm.prototype.onKey = function onKey( key , trash , data )\n{\n\tswitch( this.keyBindings[ key ] )\n\t{\n\t\tcase 'previous' :\n\t\t\tthis.focusChild = this.focusPreviousChild() ;\n\t\t\tbreak ;\n\t\tcase 'next' :\n\t\t\tthis.focusChild = this.focusNextChild() ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\treturn ;\t// Bubble up\n\t}\n\t\n\treturn true ;\t// Do not bubble up\n} ;\n\n\n\nForm.prototype.onFocus = function onFocus( focus , type )\n{\n\tif ( type === 'cycle' ) { return ; }\n\t\n\tif ( focus )\n\t{\n\t\tif ( this.focusChild ) { this.document.giveFocusTo( this.focusChild , 'delegate' ) ; }\n\t\telse { this.focusChild = this.focusNextChild() ; }\n\t}\n} ;\n\n\n\nForm.prototype.onButtonSubmit = function onButtonSubmit( buttonValue )\n{\n\tthis.emit( 'submit' , buttonValue , this.getValue() , this ) ;\n} ;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/document/RowMenu.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\nvar Element = require( './Element.js' ) ;\nvar Button = require( './Button.js' ) ;\n\n\n\nfunction RowMenu() { throw new Error( 'Use RowMenu.create() instead' ) ; }\nmodule.exports = RowMenu ;\nRowMenu.prototype = Object.create( Element.prototype ) ;\nRowMenu.prototype.constructor = RowMenu ;\nRowMenu.prototype.elementType = 'RowMenu' ;\n\n\n\nRowMenu.create = function createRowMenu( options )\n{\n\tvar rowMenu = Object.create( RowMenu.prototype ) ;\n\trowMenu.create( options ) ;\n\treturn rowMenu ;\n} ;\n\n\n\nRowMenu.prototype.create = function create( options )\n{\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tif ( ! options.outputWidth && ! options.width )\n\t{\n\t\toptions.outputWidth = Math.min( options.parent.inputWidth , options.parent.outputWidth ) ;\n\t}\n\t\n\tElement.prototype.create.call( this , options ) ;\n\t\n\tObject.defineProperties( this , {\n\t\tbackgroundAttr: { value: options.backgroundAttr || { bgColor: 'white' } , enumerable: true , writable: true } ,\n\t\titemsDef: { value: options.items || [] , enumerable: true , writable: true } ,\n\t\tbuttons: { value: [] , enumerable: true , writable: true } ,\n\t\tfocusChild: { value: null , enumerable: true , writable: true } ,\n\t\tonButtonSubmit: { value: this.onButtonSubmit.bind( this ) , enumerable: true } ,\n\t\tonKey: { value: this.onKey.bind( this ) , enumerable: true } ,\n\t\tonFocus: { value: this.onFocus.bind( this ) , enumerable: true } ,\n\t\t\n\t\t// Global default attributes\n\t\tbuttonFocusAttr: { value: options.buttonFocusAttr || { bgColor: 'green' , color: 'blue' , dim: true } , enumerable: true , writable: true } ,\n\t\tbuttonBlurAttr: { value: options.buttonBlurAttr || { bgColor: 'white' , color: 'black' } , enumerable: true , writable: true } ,\n\t} ) ;\n\t\n\tif ( options.keyBindings ) { this.keyBindings = options.keyBindings ; }\n\t\n\tthis.initChildren() ;\n\t\n\tthis.on( 'key' , this.onKey ) ;\n\tthis.on( 'focus' , this.onFocus ) ;\n\t\n\t// Only draw if we are not a superclass of the object\n\tif ( this.elementType === 'RowMenu' ) { this.draw() ; }\n} ;\n\n\n\nRowMenu.prototype.destroy = function destroy( isSubDestroy )\n{\n\tthis.off( 'key' , this.onKey ) ;\n\tthis.off( 'focus' , this.onFocus ) ;\n\t\n\tElement.prototype.destroy.call( this , isSubDestroy ) ;\n} ;\n\n\n\nRowMenu.prototype.keyBindings = {\n\tLEFT: 'previous' ,\n\tRIGHT: 'next' ,\n//\tUP: 'previous' ,\n//\tDOWN: 'next' ,\n} ;\n\n\n\n// Create TextInput and Button automatically\nRowMenu.prototype.initChildren = function initChildren()\n{\n\tvar i , iMax ,\n\t\tlabelMaxLength = 0 , label ,\n\t\tbuttonsTextLength = 0 , buttonSpacing = 0 , buttonOffsetX , buttonOffsetY ;\n\t\n\t\n\tiMax = this.itemsDef.length ;\n\tif ( ! iMax ) { return ; } \n\t\n\tfor ( i = 0 ; i < iMax ; i ++ ) { buttonsTextLength += this.itemsDef[ i ].content.length ; }\n\t\n\t//buttonSpacing = Math.floor( ( this.outputWidth - buttonsTextLength ) / ( this.itemsDef.length ) ) ;\n\tbuttonSpacing = 1 ;\n\t\n\tbuttonOffsetX = 0 ;\n\tbuttonOffsetY = 0 ;\n\t\n\tfor ( i = 0 ; i < iMax ; i ++ )\n\t{\n\t\tthis.buttons[ i ] = Button.create( {\n\t\t\tparent: this ,\n\t\t\tcontent: this.itemsDef[ i ].content ,\n\t\t\tvalue: this.itemsDef[ i ].value ,\n\t\t\toutputX: this.outputX + buttonOffsetX ,\n\t\t\toutputY: this.outputY + buttonOffsetY ,\n\t\t\tfocusAttr: this.itemsDef[ i ].focusAttr || this.buttonFocusAttr ,\n\t\t\tblurAttr: this.itemsDef[ i ].blurAttr || this.buttonBlurAttr ,\n\t\t} ) ;\n\t\t\n\t\tthis.buttons[ i ].on( 'submit' , this.onButtonSubmit ) ;\n\t\t\n\t\tbuttonOffsetX += this.itemsDef[ i ].content.length + buttonSpacing ;\n\t}\n\t\n} ;\n\n\n\nRowMenu.prototype.preDrawSelf = function preDrawSelf()\n{\n\tthis.outputDst.put( { x: this.outputX , y: this.outputY , attr: this.backgroundAttr } , ' '.repeat( this.outputWidth ) ) ;\n} ;\n\n\n\nRowMenu.prototype.onKey = function onKey( key , trash , data )\n{\n\tswitch( this.keyBindings[ key ] )\n\t{\n\t\tcase 'previous' :\n\t\t\tthis.focusChild = this.focusPreviousChild() ;\n\t\t\tbreak ;\n\t\tcase 'next' :\n\t\t\tthis.focusChild = this.focusNextChild() ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\treturn ;\t// Bubble up\n\t}\n\t\n\treturn true ;\t// Do not bubble up\n} ;\n\n\n\nRowMenu.prototype.onFocus = function onFocus( focus , type )\n{\n\tif ( type === 'cycle' ) { return ; }\n\t\n\tif ( focus )\n\t{\n\t\tif ( this.focusChild ) { this.document.giveFocusTo( this.focusChild , 'delegate' ) ; }\n\t\telse { this.focusChild = this.focusNextChild() ; }\n\t}\n} ;\n\n\n\nRowMenu.prototype.onButtonSubmit = function onButtonSubmit( buttonValue )\n{\n\tthis.emit( 'submit' , buttonValue , undefined , this ) ;\n} ;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/document/ColumnMenu.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\nvar Element = require( './Element.js' ) ;\nvar Button = require( './Button.js' ) ;\n\n\n\nfunction ColumnMenu() { throw new Error( 'Use ColumnMenu.create() instead' ) ; }\nmodule.exports = ColumnMenu ;\nColumnMenu.prototype = Object.create( Element.prototype ) ;\nColumnMenu.prototype.constructor = ColumnMenu ;\nColumnMenu.prototype.elementType = 'ColumnMenu' ;\n\n\n\nColumnMenu.create = function createColumnMenu( options )\n{\n\tvar columnMenu = Object.create( ColumnMenu.prototype ) ;\n\tcolumnMenu.create( options ) ;\n\treturn columnMenu ;\n} ;\n\n\n\nColumnMenu.prototype.create = function create( options )\n{\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tif ( ! options.outputWidth && ! options.width )\n\t{\n\t\toptions.outputWidth = Math.min( options.parent.inputWidth , options.parent.outputWidth ) ;\n\t}\n\t\n\toptions.height = options.items && options.items.length ;\n\t\n\tElement.prototype.create.call( this , options ) ;\n\t\n\tObject.defineProperties( this , {\n\t\t//backgroundAttr: { value: options.backgroundAttr || { bgColor: 'white' } , enumerable: true , writable: true } ,\n\t\titemsDef: { value: options.items || [] , enumerable: true , writable: true } ,\n\t\tbuttons: { value: [] , enumerable: true , writable: true } ,\n\t\tfocusChild: { value: null , enumerable: true , writable: true } ,\n\t\tonButtonSubmit: { value: this.onButtonSubmit.bind( this ) , enumerable: true } ,\n\t\tonKey: { value: this.onKey.bind( this ) , enumerable: true } ,\n\t\tonFocus: { value: this.onFocus.bind( this ) , enumerable: true } ,\n\t\t\n\t\t// Global default attributes\n\t\tbuttonFocusAttr: { value: options.buttonFocusAttr || { bgColor: 'white' , color: 'black' , bold: true } , enumerable: true , writable: true } ,\n\t\tbuttonBlurAttr: { value: options.buttonBlurAttr || { bgColor: 'black' , color: 'white' , bold: true } , enumerable: true , writable: true } ,\n\t} ) ;\n\t\n\tif ( options.keyBindings ) { this.keyBindings = options.keyBindings ; }\n\t\n\tthis.initChildren() ;\n\t\n\tthis.on( 'key' , this.onKey ) ;\n\tthis.on( 'focus' , this.onFocus ) ;\n\t\n\t// Only draw if we are not a superclass of the object\n\tif ( this.elementType === 'ColumnMenu' ) { this.draw() ; }\n} ;\n\n\n\nColumnMenu.prototype.destroy = function destroy( isSubDestroy )\n{\n\tthis.off( 'key' , this.onKey ) ;\n\tthis.off( 'focus' , this.onFocus ) ;\n\t\n\tElement.prototype.destroy.call( this , isSubDestroy ) ;\n} ;\n\n\n\nColumnMenu.prototype.keyBindings = {\n//\tLEFT: 'previous' ,\n//\tRIGHT: 'next' ,\n\tUP: 'previous' ,\n\tDOWN: 'next' ,\n} ;\n\n\n\n// Create TextInput and Button automatically\nColumnMenu.prototype.initChildren = function initChildren()\n{\n\tvar i , iMax ,\n\t\tlabelMaxLength = 0 , label ,\n\t\tbuttonsMaxLength = 0 , //buttonSpacing = 0 ,\n\t\tbuttonOffsetX , buttonOffsetY ;\n\t\n\t\n\tiMax = this.itemsDef.length ;\n\tif ( ! iMax ) { return ; } \n\t\n\tfor ( i = 0 ; i < iMax ; i ++ )\n\t{\n\t\tif ( buttonsMaxLength < this.itemsDef[ i ].content.length )\n\t\t{\n\t\t\tbuttonsMaxLength = this.itemsDef[ i ].content.length ;\n\t\t}\n\t}\n\t\n\t//buttonSpacing = Math.floor( ( this.outputWidth - buttonsTextLength ) / ( this.itemsDef.length ) ) ;\n\t//buttonSpacing = 1 ;\n\t\n\tbuttonOffsetX = 0 ;\n\tbuttonOffsetY = 0 ;\n\t\n\tfor ( i = 0 ; i < iMax ; i ++ )\n\t{\n\t\tthis.buttons[ i ] = Button.create( {\n\t\t\tparent: this ,\n\t\t\tcontent: ' ' + this.itemsDef[ i ].content + ' '.repeat( buttonsMaxLength - this.itemsDef[ i ].content.length ) + ' ' ,\n\t\t\tvalue: this.itemsDef[ i ].value ,\n\t\t\toutputX: this.outputX + buttonOffsetX ,\n\t\t\toutputY: this.outputY + buttonOffsetY ,\n\t\t\tfocusAttr: this.itemsDef[ i ].focusAttr || this.buttonFocusAttr ,\n\t\t\tblurAttr: this.itemsDef[ i ].blurAttr || this.buttonBlurAttr ,\n\t\t} ) ;\n\t\t\n\t\tthis.buttons[ i ].on( 'submit' , this.onButtonSubmit ) ;\n\t\t\n\t\tbuttonOffsetY ++ ;\n\t}\n\t\n} ;\n\n\n\n/*\nColumnMenu.prototype.preDrawSelf = function preDrawSelf()\n{\n\t//this.outputDst.put( { x: this.outputX , y: this.outputY , attr: this.backgroundAttr } , ' '.repeat( this.outputWidth ) ) ;\n} ;\n*/\n\n\n\nColumnMenu.prototype.onKey = function onKey( key , trash , data )\n{\n\tswitch( this.keyBindings[ key ] )\n\t{\n\t\tcase 'previous' :\n\t\t\tthis.focusChild = this.focusPreviousChild() ;\n\t\t\tbreak ;\n\t\tcase 'next' :\n\t\t\tthis.focusChild = this.focusNextChild() ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\treturn ;\t// Bubble up\n\t}\n\t\n\treturn true ;\t// Do not bubble up\n} ;\n\n\n\nColumnMenu.prototype.onFocus = function onFocus( focus , type )\n{\n\tif ( type === 'cycle' ) { return ; }\n\t\n\tif ( focus )\n\t{\n\t\tif ( this.focusChild ) { this.document.giveFocusTo( this.focusChild , 'delegate' ) ; }\n\t\telse { this.focusChild = this.focusNextChild() ; }\n\t}\n} ;\n\n\n\nColumnMenu.prototype.onButtonSubmit = function onButtonSubmit( buttonValue )\n{\n\tthis.emit( 'submit' , buttonValue , undefined , this ) ;\n} ;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/document/DropDownMenu.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\nvar Element = require( './Element.js' ) ;\nvar RowMenu = require( './RowMenu.js' ) ;\nvar ColumnMenu = require( './ColumnMenu.js' ) ;\n\n\n\nfunction DropDownMenu() { throw new Error( 'Use DropDownMenu.create() instead' ) ; }\nmodule.exports = DropDownMenu ;\nDropDownMenu.prototype = Object.create( RowMenu.prototype ) ;\nDropDownMenu.prototype.constructor = DropDownMenu ;\nDropDownMenu.prototype.elementType = 'DropDownMenu' ;\n\n\n\nDropDownMenu.create = function createDropDownMenu( options )\n{\n\tvar dropDownMenu = Object.create( DropDownMenu.prototype ) ;\n\tdropDownMenu.create( options ) ;\n\treturn dropDownMenu ;\n} ;\n\n\n\nDropDownMenu.prototype.create = function create( options )\n{\n\tvar i , iMax ;\n\t\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tRowMenu.prototype.create.call( this , options ) ;\n\t\n\tObject.defineProperties( this , {\n\t\tcolumnMenu: { value: null , enumerable: true , writable: true } ,\n\t\tcolumnButtonFocusAttr: { value: options.buttonFocusAttr || { bgColor: 'blue' , color: 'white' , bold: true } , enumerable: true , writable: true } ,\n\t\tcolumnButtonBlurAttr: { value: options.buttonBlurAttr || { bgColor: 'brightBlack' , color: 'white' , bold: true } , enumerable: true , writable: true } ,\n\t\tonButtonFocus: { value: this.onButtonFocus.bind( this ) , enumerable: true } ,\n\t\tonColumnMenuSubmit: { value: this.onColumnMenuSubmit.bind( this ) , enumerable: true } ,\n\t} ) ;\n\t\n\tfor ( i = 0 , iMax = this.buttons.length ; i < iMax ; i ++ )\n\t{\n\t\tthis.buttons[ i ].on( 'focus' , this.onButtonFocus ) ;\n\t}\n\t\n\t// Only draw if we are not a superclass of the object\n\tif ( this.elementType === 'DropDownMenu' ) { this.draw() ; }\n} ;\n\n\n\nDropDownMenu.prototype.destroy = function destroy( isSubDestroy )\n{\n\tRowMenu.prototype.destroy.call( this , isSubDestroy ) ;\n} ;\n\n\n\nDropDownMenu.prototype.keyBindings = {\n\tLEFT: 'previous' ,\n\tRIGHT: 'next' ,\n\tESCAPE: 'clearColumnMenu' ,\n\tUP: 'clearColumnMenu' ,\n\tDOWN: 'dropDown' ,\n} ;\n\n\n\nDropDownMenu.prototype.dropDown = function dropDown( index , x , y )\n{\n\tvar itemsDef = this.itemsDef[ index ].items ;\n\t\n\t//console.error( \"Submit!\" , button.childIndex ) ;\n\t\n\tif ( this.columnMenu )\n\t{\n\t\t// Already dropped down? Nothing to do!\n\t\tif ( this.columnMenu.index === index ) { return ; }\n\t\tthis.clearColumnMenu() ;\n\t}\n\t\n\t// No submenu, leave now...\n\tif ( ! itemsDef || ! itemsDef.length ) { return ; }\n\t\n\t// Make the ColumnMenu a child of the button, so focus cycle will work as expected\n\tthis.columnMenu = ColumnMenu.create( {\n\t\tparent: this.children[ index ] ,\n\t\tx: x ,\n\t\ty: y ,\n\t\titems: itemsDef ,\n\t\tbuttonFocusAttr: this.columnButtonFocusAttr ,\n\t\tbuttonBlurAttr: this.columnButtonBlurAttr ,\n\t} ) ;\n\t\n\tthis.columnMenu.on( 'submit' , this.onColumnMenuSubmit ) ;\n\t\n\tthis.columnMenu.menuIndex = index ;\n\t\n\t//this.document.giveFocusTo( this.columnMenu , 'delegate' ) ;\n} ;\n\n\n\nDropDownMenu.prototype.clearColumnMenu = function clearColumnMenu()\n{\n\tif ( ! this.columnMenu ) { return ; }\n\tthis.columnMenu.destroy() ;\n\tthis.columnMenu = null ;\n} ;\n\n\n\nDropDownMenu.prototype.onColumnMenuSubmit = function onColumnMenuSubmit( buttonValue , data , button )\n{\n\tthis.emit( 'submit' , buttonValue , undefined , this ) ;\n} ;\n\n\n\nDropDownMenu.prototype.onButtonSubmit = function onButtonSubmit( buttonValue , data , button )\n{\n\tthis.dropDown( button.childIndex , button.outputX , button.outputY + 1 ) ;\n} ;\n\n\n\nDropDownMenu.prototype.onButtonFocus = function onButtonFocus( focus , type , button )\n{\n\tif ( focus ) { this.dropDown( button.childIndex , button.outputX , button.outputY + 1 ) ; }\n} ;\n\n\n\nDropDownMenu.prototype.onKey = function onKey( key , trash , data )\n{\n\tswitch( this.keyBindings[ key ] )\n\t{\n\t\tcase 'previous' :\n\t\t\tthis.focusChild = this.focusPreviousChild() ;\n\t\t\t//this.clearColumnMenu() ;\n\t\t\tbreak ;\n\t\tcase 'next' :\n\t\t\tthis.focusChild = this.focusNextChild() ;\n\t\t\t//this.clearColumnMenu() ;\n\t\t\tbreak ;\n\t\tcase 'dropDown' :\n\t\t\tif ( this.columnMenu ) { this.columnMenu.focusNextChild() ; }\n\t\t\t//this.focusChild = this.focusNextChild() ;\n\t\t\t//this.clearColumnMenu() ;\n\t\t\tbreak ;\n\t\tcase 'clearColumnMenu' :\n\t\t\tthis.clearColumnMenu() ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\treturn ;\t// Bubble up\n\t}\n\t\n\treturn true ;\t// Do not bubble up\n} ;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/document/Layout.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Load modules\nvar Element = require( './Element.js' ) ;\nvar Container = require( './Container.js' ) ;\nvar boxesChars = require( '../spChars.js' ).box ;\n\n\n\nfunction Layout() { throw new Error( 'Use Layout.create() instead' ) ; }\nmodule.exports = Layout ;\nLayout.prototype = Object.create( Element.prototype ) ;\nLayout.prototype.constructor = Layout ;\nLayout.prototype.elementType = 'Layout' ;\n\n\n\nLayout.create = function createLayout( options )\n{\n\tvar layout = Object.create( Layout.prototype ) ;\n\tlayout.create( options ) ;\n\treturn layout ;\n} ;\n\n\n\nLayout.prototype.create = function create( options )\n{\n\tvar key ;\n\t\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tElement.prototype.create.call( this , options ) ;\n\t\n\tObject.defineProperties( this , {\n\t\tlayoutDef: { value: options.layout , enumerable: true } ,\n\t\tcomputed: { value: {} , enumerable: true , writable: true } ,\n\t\tboxesContainer: { value: {} , enumerable: true , writable: true } ,\n\t\tboxChars: { value: boxesChars.light , enumerable: true , writable: true } ,\n\t} ) ;\n\t\n\tif ( options.boxChars )\n\t{\n\t\tif ( typeof options.boxChars === 'object' )\n\t\t{\n\t\t\tthis.boxChars = options.boxChars ;\n\t\t}\n\t\telse if ( typeof options.boxChars === 'string' && boxesChars[ options.boxChars ] )\n\t\t{\n\t\t\tthis.boxChars = boxesChars[ options.boxChars ] ;\n\t\t}\n\t}\n\t\n\t// Only draw if we are not a superclass of the object\n\tif ( this.elementType === 'Layout' ) { this.draw() ; }\n} ;\n\n\n\nLayout.prototype.destroy = function destroy( isSubDestroy )\n{\n\tElement.prototype.destroy.call( this , isSubDestroy ) ;\n} ;\n\n\n\nLayout.prototype.preDrawSelf = function preDrawSelf()\n{\n\tvar y , tees = {} ;\n\t\n\tthis.computeBoundingBoxes() ;\n\t\t\n\t// Draw the top border\n\tthis.outputDst.put(\n\t\t{ x: this.computed.xmin , y: this.computed.ymin } ,\n\t\tthis.boxChars.topLeft + this.boxChars.horizontal.repeat( this.computed.dx - 1 ) + this.boxChars.topRight\n\t) ;\n\t\n\t// Draw the bottom border\n\tthis.outputDst.put(\n\t\t{ x: this.computed.xmin , y: this.computed.ymax } ,\n\t\tthis.boxChars.bottomLeft + this.boxChars.horizontal.repeat( this.computed.dx - 1 ) + this.boxChars.bottomRight\n\t) ;\n\t\n\t// Draw the left and right border\n\tfor ( y = this.computed.ymin + 1 ; y < this.computed.ymax ; y ++ )\n\t{\n\t\tthis.outputDst.put( { x: this.computed.xmin , y: y } , this.boxChars.vertical ) ;\n\t\tthis.outputDst.put( { x: this.computed.xmax , y: y } , this.boxChars.vertical ) ;\n\t}\n\t\n\tthis.drawRecursive( this.computed , tees ) ;\n} ;\n\n\n\nLayout.prototype.computeBoundingBoxes = function computeBoundingBoxes()\n{\n\tvar computed = this.computed = {} ;\n\t\n\tvar layoutDef = this.layoutDef ;\n\t\n\tvar parent = {\n\t\twidth_: this.outputDst.width ,\n\t\theight_: this.outputDst.height ,\n\t\tdx_: this.outputDst.width - 1 ,\n\t\tdy_: this.outputDst.height - 1 ,\n\t\txmin_: 0 ,\n\t\tymin_: 0\n\t} ;\n\t\n\tvar inProgress = {\n\t\toffsetX: ( this.layoutDef.x ) || 0 ,\n\t\toffsetY: ( this.layoutDef.y ) || 0 ,\n\t\tremainingDx: parent.dx_ ,\n\t\tremainingDy: parent.dy_ ,\n\t} ;\n\t\n\tthis.computeBoundingBoxes_( layoutDef , computed , parent , inProgress ) ;\n} ;\n\n\n\nLayout.prototype.computeBoundingBoxes_ = function computeBoundingBoxes_( layoutDef , computed , parent , inProgress )\n{\n\tvar i , nextInProgress , hasChild = false ;\n\t\n\t//console.error( \"\\n\\nlayoutDef #\" + layoutDef.id + ':\\n' , computed ) ;\n\t\n\tthis.computeDxDy( layoutDef , computed , parent , inProgress ) ;\n\t\n\t//console.error( \"\\n\\nlayoutDef #\" + layoutDef.id + ':\\n' , computed ) ;\n\t\n\tcomputed.xmin_ = parent.xmin_ + inProgress.offsetX ;\n\tcomputed.xmax_ = computed.xmin_ + computed.dx_ ;\n\tcomputed.ymin_ = parent.ymin_ + inProgress.offsetY ;\n\tcomputed.ymax_ = computed.ymin_ + computed.dy_ ;\n\t\n\t//console.error( \"\\n\\nlayoutDef #\" + layoutDef.id + ':\\n' , computed ) ;\n\t\n\t// Check if it goes out of its parent\n\tif ( computed.xmax_ > parent.xmax_ )\n\t{\n\t\tcomputed.xmax_ = parent.xmax_ ;\n\t\tcomputed.dx_ = computed.xmax_ - computed.xmin_ ;\n\t}\n\t\n\tif ( computed.ymax_ > parent.ymax_ )\n\t{\n\t\tcomputed.ymax_ = parent.ymax_ ;\n\t\tcomputed.dy_ = computed.ymax_ - computed.ymin_ ;\n\t}\n\t\n\t// Width and height are not used internally, but provided for userland\n\tcomputed.width_ = computed.dx_ + 1 ;\n\tcomputed.height_ = computed.dy_ + 1 ;\n\t\n\tcomputed.columns = [] ;\n\tcomputed.rows = [] ;\n\t\n\t//console.error( \"\\n\\nlayoutDef #\" + layoutDef.id + ':\\n' , computed ) ;\n\t\n\tnextInProgress = {\n\t\toffsetX: 0 ,\n\t\toffsetY: 0 ,\n\t\tremainingDx: computed.dx_ ,\n\t\tremainingDy: computed.dy_ ,\n\t\tautoDxCount: 0 ,\n\t\tautoDyCount: 0 ,\n\t} ;\n\t\n\tif ( layoutDef.columns && layoutDef.columns.length )\n\t{\n\t\t// First pass\n\t\tfor ( i = 0 ; i < layoutDef.columns.length ; i ++ )\n\t\t{\n\t\t\tcomputed.columns[ i ] = {} ;\n\t\t\tthis.computeDxDy( layoutDef.columns[ i ] , computed.columns[ i ] , computed , nextInProgress , true ) ;\n\t\t\t\n\t\t\tif ( computed.columns[ i ].dx_ !== undefined ) { nextInProgress.remainingDx -= computed.columns[ i ].dx_ ; }\n\t\t\telse { nextInProgress.autoDxCount ++ ; }\n\t\t}\n\t\t\n\t\tfor ( i = 0 ; i < layoutDef.columns.length ; i ++ )\n\t\t{\n\t\t\tthis.computeBoundingBoxes_( layoutDef.columns[ i ] , computed.columns[ i ] , computed , nextInProgress ) ;\n\t\t\tnextInProgress.offsetX = computed.columns[ i ].xmax_ - computed.xmin_ ;\n\t\t}\n\t\t\n\t\thasChild = true ;\n\t}\n\telse if ( layoutDef.rows && layoutDef.rows.length )\n\t{\n\t\t// First pass\n\t\tfor ( i = 0 ; i < layoutDef.rows.length ; i ++ )\n\t\t{\n\t\t\tcomputed.rows[ i ] = {} ;\n\t\t\tthis.computeDxDy( layoutDef.rows[ i ] , computed.rows[ i ] , computed , nextInProgress , true ) ;\n\t\t\t\n\t\t\tif ( computed.rows[ i ].dy_ !== undefined ) { nextInProgress.remainingDy -= computed.rows[ i ].dy_ ; }\n\t\t\telse { nextInProgress.autoDyCount ++ ; }\n\t\t}\n\t\t\n\t\tfor ( i = 0 ; i < layoutDef.rows.length ; i ++ )\n\t\t{\n\t\t\tthis.computeBoundingBoxes_( layoutDef.rows[ i ] , computed.rows[ i ] , computed , nextInProgress ) ;\n\t\t\tnextInProgress.offsetY = computed.rows[ i ].ymax_ - computed.ymin_ ;\n\t\t}\n\t\t\n\t\thasChild = true ;\n\t}\n\t\n\tcomputed.width_ = computed.dx_ + 1 ;\n\tcomputed.height_ = computed.dy_ + 1 ;\n\t\n\tthis.round( computed ) ;\n\t//console.error( \"\\n\\nfinal #\" + layoutDef.id + ':\\n' , computed ) ;\n\t\n\t// Container surfaces are only created for \"leaf\" boxes, i.e. boxes that don't have child\n\tif ( ! hasChild )\n\t{\n\t\tif ( this.boxesContainer[ layoutDef.id ] )\n\t\t{\n\t\t\tif ( this.boxesContainer[ layoutDef.id ].width !== computed.width - 2 || this.boxesContainer[ layoutDef.id ].height !== computed.height - 2 )\n\t\t\t{\n\t\t\t\tthis.boxesContainer[ layoutDef.id ].resize( {\n\t\t\t\t\tx: 0 ,\n\t\t\t\t\ty: 0 ,\n\t\t\t\t\twidth: computed.width - 2 ,\n\t\t\t\t\theight: computed.height - 2\n\t\t\t\t} ) ;\n\t\t\t}\n\t\t\t\n\t\t\tthis.boxesContainer[ layoutDef.id ].outputX = computed.xmin + 1 ;\n\t\t\tthis.boxesContainer[ layoutDef.id ].outputY = computed.ymin + 1 ;\n\t\t\t\n\t\t\tthis.boxesContainer[ layoutDef.id ].moveTo(\n\t\t\t\tthis.boxesContainer[ layoutDef.id ].outputX ,\n\t\t\t\tthis.boxesContainer[ layoutDef.id ].outputY\n\t\t\t) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar container = Container.create( {\n\t\t\t\tid: layoutDef.id ,\n\t\t\t\tparent: this ,\n\t\t\t\toutputDst: this.outputDst ,\n\t\t\t\toutputX: computed.xmin + 1 ,\n\t\t\t\toutputY: computed.ymin + 1 ,\n\t\t\t\toutputWidth: computed.width - 2 ,\n\t\t\t\toutputHeight: computed.height - 2\n\t\t\t} ) ;\n\t\t\t\n\t\t\tlayoutDef.id = container.id ;\n\t\t\tthis.boxesContainer[ layoutDef.id ] = container ;\n\t\t}\n\t}\n} ;\n\n\n\nLayout.prototype.computeDxDy = function computeDxDy( layoutDef , computed , parent , inProgress , firstPass )\n{\n\t//console.error( \">>>>>>>>>> #\" + layoutDef.id + ' firstPass: ' , !! firstPass ) ;\n\t\n\t// Dx\n\tif ( firstPass || computed.dx_ === undefined )\n\t{\n\t\tif ( layoutDef.width !== undefined )\n\t\t{\n\t\t\tcomputed.dx_ = Math.max( 0 , Math.min( parent.dx_ , layoutDef.width - 1 ) ) ;\n\t\t}\n\t\telse if ( layoutDef.widthPercent !== undefined )\n\t\t{\n\t\t\tcomputed.dx_ = Math.max( 0 , Math.min( parent.dx_ , parent.dx_ * layoutDef.widthPercent / 100 ) ) ;\n\t\t}\n\t\telse if ( ! firstPass )\n\t\t{\n\t\t\t//console.error( \">>>>>>>>>> #\" + layoutDef.id + ' remaining dx: ' , inProgress.remainingDx , '/' , inProgress.autoDxCount , ' --- ' , inProgress ) ;\n\t\t\tcomputed.dx_ = Math.max( 0 , inProgress.remainingDx / ( inProgress.autoDxCount || 1 ) ) ;\n\t\t\t//console.error( \">>>>>>>>>> #\" + layoutDef.id + ' computed dx: ' , computed.dx_ ) ;\n\t\t}\n\t}\n\t\n\t// Dy\n\tif ( firstPass || computed.dy_ === undefined )\n\t{\n\t\tif ( layoutDef.height !== undefined )\n\t\t{\n\t\t\tcomputed.dy_ = Math.max( 0 , Math.min( parent.dy_ , layoutDef.height - 1 ) ) ;\n\t\t}\n\t\telse if ( layoutDef.heightPercent !== undefined )\n\t\t{\n\t\t\tcomputed.dy_ = Math.max( 0 , Math.min( parent.dy_ , parent.dy_ * layoutDef.heightPercent / 100 ) ) ;\n\t\t}\n\t\telse if ( ! firstPass )\n\t\t{\n\t\t\tcomputed.dy_ = Math.max( 0 , inProgress.remainingDy / ( inProgress.autoDyCount || 1 ) ) ;\n\t\t}\n\t}\n} ;\n\t\n\n\nLayout.prototype.round = function round( computed )\n{\n\tcomputed.xmin = Math.round( computed.xmin_ ) ;\n\tcomputed.xmax = Math.round( computed.xmax_ ) ;\n\tcomputed.ymin = Math.round( computed.ymin_ ) ;\n\tcomputed.ymax = Math.round( computed.ymax_ ) ;\n\t\n\tcomputed.dx = computed.xmax - computed.xmin ;\n\tcomputed.dy = computed.ymax - computed.ymin ;\n\tcomputed.width = computed.dx + 1 ;\n\tcomputed.height = computed.dy + 1 ;\n} ;\n\n\n\nLayout.prototype.drawRecursive = function drawRecursive( computed , tees )\n{\n\tvar i ;\n\t\n\tif ( computed.columns.length )\n\t{\n\t\tfor ( i = 0 ; i < computed.columns.length ; i ++ )\n\t\t{\n\t\t\tthis.drawColumn( computed.columns[ i ] , tees , i === computed.columns.length - 1 ) ;\n\t\t}\n\t}\n\telse if ( computed.rows.length )\n\t{\n\t\tfor ( i = 0 ; i < computed.rows.length ; i ++ )\n\t\t{\n\t\t\tthis.drawRow( computed.rows[ i ] , tees , i === computed.rows.length - 1 ) ;\n\t\t}\n\t}\n} ;\n\n\n\nLayout.prototype.drawColumn = function drawColumn( computed , tees , last )\n{\n\tvar y ;\n\t\n\tif ( ! last )\n\t{\n\t\t// Draw Tee-junction\n\t\tthis.drawTee( computed.xmax , computed.ymin , 'top' , tees ) ;\n\t\tthis.drawTee( computed.xmax , computed.ymax , 'bottom' , tees ) ;\n\t\t\n\t\t// Draw the right border\n\t\tfor ( y = computed.ymin + 1 ; y < computed.ymax ; y ++ )\n\t\t{\n\t\t\tthis.outputDst.put( { x: computed.xmax , y: y } , this.boxChars.vertical ) ;\n\t\t}\n\t}\n\t\n\tthis.drawRecursive( computed , tees ) ;\n} ;\n\n\n\nLayout.prototype.drawTee = function drawTee( x , y , type , tees )\n{\n\tvar key = x + ':' + y ;\n\t\n\tif ( ! tees[ key ] )\n\t{\n\t\tthis.outputDst.put( { x: x , y: y } , this.boxChars[ type + 'Tee' ] ) ;\n\t\ttees[ key ] = type ;\n\t}\n\telse if ( tees[ key ] !== type )\n\t{\n\t\tthis.outputDst.put( { x: x , y: y } , this.boxChars.cross ) ;\n\t}\n} ;\n\n\n\nLayout.prototype.drawRow = function drawRow( computed , tees , last )\n{\n\tif ( ! last )\n\t{\n\t\t// Draw Tee-junction\n\t\tthis.drawTee( computed.xmin , computed.ymax , 'left' , tees ) ;\n\t\tthis.drawTee( computed.xmax , computed.ymax , 'right' , tees ) ;\n\t\t\n\t\t// Draw the bottom border\n\t\tthis.outputDst.put( { x: computed.xmin + 1 , y: computed.ymax } , this.boxChars.horizontal.repeat( computed.dx - 1 ) ) ;\n\t}\n\t\n\tthis.drawRecursive( computed , tees ) ;\n} ;\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/termconfig/xterm.generic.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\nvar tree = require( 'tree-kit' ) ;\nvar xterm = require( './xterm.js' ) ;\n\n\n\n// Fail-safe xterm-compatible\n\nvar esc = tree.extend( null , Object.create( xterm.esc ) , {\n\t\n\t// KDE Konsole does not support that. This workaround use up()/down() & column(1)\n\tnextLine: { on: '\\x1b[%UB\\x1b[1G' } ,\n\tpreviousLine: { on: '\\x1b[%UA\\x1b[1G' } ,\n\t\n\t// Cursor styles\n\t\n\t// Try that sequences for instance, if it fails gracefully, it will be kept\n\t// Xterm sequences fail and write garbage\n\tblockCursor: { on: '\\x1b]50;CursorShape=0\\x07' } ,\n\tblinkingBlockCursor: { on: '\\x1b]50;CursorShape=0\\x07' } ,\n\tunderlineCursor: { on: '\\x1b]50;CursorShape=2\\x07' } ,\n\tblinkingUnderlineCursor: { on: '\\x1b]50;CursorShape=2\\x07' } ,\n\tbeamCursor: { on: '\\x1b]50;CursorShape=1\\x07' } ,\n\tblinkingBeamCursor: { on: '\\x1b]50;CursorShape=1\\x07' }\n\t\n\t// Disabled version\n\t/*\n\tblockCursor: { on: '' } ,\n\tblinkingBlockCursor: { on: '' } ,\n\tunderlineCursor: { on: '' } ,\n\tblinkingUnderlineCursor: { on: '' } ,\n\tbeamCursor: { on: '' } ,\n\tblinkingBeamCursor: { on: '' }\n\t*/\n} ) ;\n\n\n\n\n\n\t\t\t/* Key Mapping */\n\n\n\nvar keymap = Object.create( xterm.keymap ) ;\n\n\n\n\n\n\t\t\t/* Handlers */\n\n\n\nvar handler = Object.create( xterm.handler ) ;\n\n\n\n\n\nmodule.exports = {\n\tesc: esc ,\n\tkeymap: keymap ,\n\thandler: handler ,\n\tsupport: {\n\t\tdeltaEscapeSequence: true ,\n\t\t\"256colors\": false ,\n\t\t\"24bitsColors\": false\n\t} ,\n\tcolorRegister: require( '../colorScheme/vga.json' )\n} ;\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/termconfig/xterm.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\nvar string = require( 'string-kit' ) ;\n\n\n\n\n\n\t\t\t/* Escape sequences */\n\n\n\n// Mini-doc:\n\n// ESC = \\x1b\n// CSI = ESC + [\n// OSC = ESC + ]\n// DSC = ESC + P\n// ST = ESC + \\\t(end some sequences)\n\n// CSI: ESC + [ + <command> + <type>\n// It is possible to separate many command with a ';' before the final 'type'.\n\n// See: http://en.wikipedia.org/wiki/ANSI_escape_code\n// and: http://invisible-island.net/xterm/ctlseqs/ctlseqs.html\n// man tput\n// man infocmp\n// man 5 terminfo\n// For tput tcap name, see: http://pubs.opengroup.org/onlinepubs/7990989799/xcurses/terminfo.html\n// useful command: infocmp -l $TERM\n\n\n// Common sequences\n\n// Remove colors\nvar defaultColor = '\\x1b[39m' ;\t// back to the default color, most of time it is the same than .white\nvar bgDefaultColor = '\\x1b[49m' ;\t// back to the default color, most of time it is the same than .bgBlack\n\n\n\nvar esc = {\n\t\n\t\t\t/* Common sequences */\n\n\t// Reset the terminal\n\treset: { on: '\\x1bc' } ,\n\t\n\t\t\t/* Cursor sequences */\n\t\n\tsaveCursor: { on: '\\x1b7' } ,\t// also '\\x1b[s'\n\trestoreCursor: { on: '\\x1b8' } ,\t// also '\\x1b[u'\n\t\n\tup: { on: '\\x1b[%UA' } ,\n\tdown: { on: '\\x1b[%UB' } ,\n\tright: { on: '\\x1b[%UC' } ,\n\tleft: { on: '\\x1b[%UD' } ,\n\tnextLine: { on: '\\x1b[%UE' } ,\n\tpreviousLine: { on: '\\x1b[%UF' } ,\n\tcolumn: { on: '\\x1b[%UG' } ,\n\trow: { on: '\\x1b[%Ud' } ,\n\tscrollUp: { on: '\\x1b[%US' } ,\n\tscrollDown: { on: '\\x1b[%UT' } ,\n\tmoveTo: { on: '\\x1b[%+1U;%-1UH' , optimized: function( x , y ) { return '\\x1b[' + y + ';' + x + 'H' ; } } ,\n\t//moveToBottomLeft: { on: '\\x1bF' } ,\t// Not widely supported\n\thideCursor: { on: '\\x1b[?25l' , off: '\\x1b[?25h' } ,\n\t\n\t// Cursor styles\n\tblockCursor: { on: '\\x1b[2 q' } ,\n\tblinkingBlockCursor: { on: '\\x1b[0 q' } ,\n\tunderlineCursor: { on: '\\x1b[4 q' } ,\n\tblinkingUnderlineCursor: { on: '\\x1b[3 q' } ,\n\tbeamCursor: { on: '\\x1b[6 q' } ,\n\tblinkingBeamCursor: { on: '\\x1b[5 q' } ,\n\t\n\t\t\t/* Editing sequences */\n\t\n\tclear: { on: '\\x1b[H\\x1b[2J' } ,\n\teraseDisplayBelow: { on: '\\x1b[0J' } ,\n\teraseDisplayAbove: { on: '\\x1b[1J' } ,\n\teraseDisplay: { on: '\\x1b[2J' } ,\n\teraseLineAfter: { on: '\\x1b[0K' } ,\n\teraseLineBefore: { on: '\\x1b[1K' } ,\n\teraseLine: { on: '\\x1b[2K' } ,\n\tinsertLine: { on: '\\x1b[%UL' } ,\n\tdeleteLine: { on: '\\x1b[%UM' } ,\n\tinsert: { on: '\\x1b[%U@' } ,\t// insert char\n\t'delete': { on: '\\x1b[%UP' } ,\t// delete char\n\tbackDelete: { on: '\\x1b[1D\\x1b[1P' } ,\t// Backspace-like, left(1) followed by delete(1)\n\t\n\t// This set the alternate screen buffer, do not work on many term, due to this titeInhibit shit...\n\talternateScreenBuffer: { on: '\\x1b[?1049h' , off: '\\x1b[?1049l' } ,\n\t\n\t\t\t/* Misc sequences */\n\t\n\tbeep: { on: '\\x07' } ,\t// Deprecated -- use bell instead\n\tbell: { on: '\\x07' } ,\t// Emit an audible bell\n\t\n\t\t\t/* Style sequences */\n\t\n\tstyleReset: { on: '\\x1b[0m' } ,\n\t\n\tbold: { on: '\\x1b[1m' , off: '\\x1b[22m' } ,\t\t// here we use the dim.off code (22) that have a better support than (21), for God-only known reason...\n\tdim: { on: '\\x1b[2m' , off: '\\x1b[22m' } ,\t\t// dim: darker, 'off' remove removes also bold/bright\n\titalic: { on: '\\x1b[3m' , off: '\\x1b[23m' } ,\n\tunderline: { on: '\\x1b[4m' , off: '\\x1b[24m' } ,\n\tblink: { on: '\\x1b[5m' , off: '\\x1b[25m' } ,\n\tinverse: { on: '\\x1b[7m' , off: '\\x1b[27m' } ,\n\thidden: { on: '\\x1b[8m' , off: '\\x1b[28m' } ,\t// invisible, but can be copy/paste'd\n\tstrike: { on: '\\x1b[9m' , off: '\\x1b[29m' } ,\n\t\n\t// Foreground color\n\tdefaultColor: { on: defaultColor } ,\n\tblack: { on: '\\x1b[30m' , off: defaultColor } ,\n\tred: { on: '\\x1b[31m' , off: defaultColor } ,\n\tgreen: { on: '\\x1b[32m' , off: defaultColor } ,\n\tyellow: { on: '\\x1b[33m' , off: defaultColor } ,\n\tblue: { on: '\\x1b[34m' , off: defaultColor } ,\n\tmagenta: { on: '\\x1b[35m' , off: defaultColor } ,\n\tcyan: { on: '\\x1b[36m' , off: defaultColor } ,\n\twhite: { on: '\\x1b[37m' , off: defaultColor } ,\n\tdarkColor: { on: '\\x1b[3%um' , off: defaultColor } ,\t// should be called with a 0..7 integer\n\tbrightBlack: { on: '\\x1b[90m' , off: defaultColor } ,\n\tbrightRed: { on: '\\x1b[91m' , off: defaultColor } ,\n\tbrightGreen: { on: '\\x1b[92m' , off: defaultColor } ,\n\tbrightYellow: { on: '\\x1b[93m' , off: defaultColor } ,\n\tbrightBlue: { on: '\\x1b[94m' , off: defaultColor } ,\n\tbrightMagenta: { on: '\\x1b[95m' , off: defaultColor } ,\n\tbrightCyan: { on: '\\x1b[96m' , off: defaultColor } ,\n\tbrightWhite: { on: '\\x1b[97m' , off: defaultColor } ,\n\tbrightColor: { on: '\\x1b[9%um' , off: defaultColor } ,\t// should be called with a 0..7 integer\n    \n\t// Background color\n\tbgDefaultColor: { on: bgDefaultColor } ,\n\tbgBlack: { on: '\\x1b[40m' , off: bgDefaultColor } ,\n\tbgRed: { on: '\\x1b[41m' , off: bgDefaultColor } ,\n\tbgGreen: { on: '\\x1b[42m' , off: bgDefaultColor } ,\n\tbgYellow: { on: '\\x1b[43m' , off: bgDefaultColor } ,\n\tbgBlue: { on: '\\x1b[44m' , off: bgDefaultColor } ,\n\tbgMagenta: { on: '\\x1b[45m' , off: bgDefaultColor } ,\n\tbgCyan: { on: '\\x1b[46m' , off: bgDefaultColor } ,\n\tbgWhite: { on: '\\x1b[47m' , off: bgDefaultColor } ,\n\tbgDarkColor: { on: '\\x1b[4%um' , off: bgDefaultColor } ,\t// should be called with a 0..7 integer\n\tbgBrightBlack: { on: '\\x1b[100m' , off: bgDefaultColor } ,\n\tbgBrightRed: { on: '\\x1b[101m' , off: bgDefaultColor } ,\n\tbgBrightGreen: { on: '\\x1b[102m' , off: bgDefaultColor } ,\n\tbgBrightYellow: { on: '\\x1b[103m' , off: bgDefaultColor } ,\n\tbgBrightBlue: { on: '\\x1b[104m' , off: bgDefaultColor } ,\n\tbgBrightMagenta: { on: '\\x1b[105m' , off: bgDefaultColor } ,\n\tbgBrightCyan: { on: '\\x1b[106m' , off: bgDefaultColor } ,\n\tbgBrightWhite: { on: '\\x1b[107m' , off: bgDefaultColor } ,\n\tbgBrightColor: { on: '\\x1b[10%um' , off: bgDefaultColor } ,\t// should be called with a 0..7 integer\n\t\n\t\t\t/* Input / Output sequences */\n\t\n\t// Request terminal ID\n\t// requestTerminalId: { on: '\\x1b[>c' } ,\n\t\n\t// Terminal will send the cursor coordinate only one time\n\trequestCursorLocation: { on: '\\x1b[6n' } ,\t// '\\x1b[?6n' is not widely supported, '\\x1b[6n' is better\n\t\n\t// Terminal will send the cursor coordinate only one time\n\trequestScreenSize: { on: '\\x1b[18t' } ,\n\t\n\t// Terminal will send the rgb color for a register\n\trequestColor: { on: '\\x1b]4;%u;?\\x07' } ,\n\t\n\t// Terminal will send event on button pressed with mouse position\n\tmouseButton: { on: '\\x1b[?1000h' , off: '\\x1b[?1000l' } ,\n\t\n\t// Terminal will send position of the column hilighted\n\tmouseHilight: { on: '\\x1b[?1001h' , off: '\\x1b[?1001l' } ,\n\t\n\t// Terminal will send event on button pressed and mouse motion as long as a button is down, with mouse position\n\tmouseDrag: { on: '\\x1b[?1002h' , off: '\\x1b[?1002l' } ,\n\t\n\t// Terminal will send event on button pressed and motion\n\tmouseMotion: { on: '\\x1b[?1003h' , off: '\\x1b[?1003l' } ,\n\t\n\t// Another mouse protocol that extend coordinate mapping (without it, it supports only 223 rows and columns)\n\tmouseSGR: { on: '\\x1b[?1006h' , off: '\\x1b[?1006l' } ,\n\t\n\t// Terminal will send event when it gains and loses focus\n\tfocusEvent: { on: '\\x1b[?1004h' , off: '\\x1b[?1004l' } ,\n\t\n\t// Should allow keypad to send different code than 0..9 keys but it does not works on some setup\n\tapplicationKeypad: { on: '\\x1b[?1h\\x1b=' , off: '\\x1b[?1l\\x1b>' } ,\n\t\n\t// When enabled, the terminal will report if modifiers (SHIFT, CTRL, ALT) are on\n\t/*\tNot widely supported\n\tkeyboardModifier: { on: '\\x1b[>0;1m' , off: '\\x1b[>0;0m' } ,\n\tcursorKeyModifier: { on: '\\x1b[>1;1m' , off: '\\x1b[>1;0m' } ,\n\tfunctionKeyModifier: { on: '\\x1b[>2;1m' , off: '\\x1b[>2;0m' } ,\n\totherKeyModifier: { on: '\\x1b[>3;1m' , off: '\\x1b[>3;0m' } ,\n\t*/\n\t\n\t// Do not work... use node.js stdout.setRawMode(true) instead\n\t//noecho: { on: '\\x1b[12h' } ,\n\t\n\t\t\t/* OSC - OS Control sequences: may be unavailable on some context */\n\t\n\t// Set the title of an xterm-compatible window\n\twindowTitle: { on: '\\x1b]2;%s\\x1b\\\\' } ,\n\ticonName: { on: '\\x1b]1;%s\\x1b\\\\' } ,\n\tcwd: { on: '\\x1b]7;%s\\x1b\\\\' } ,\n\tnotify: { on: '\\x1b]777;notify;%s;%s\\x1b\\\\' } ,\n\t\n\t// Those sequences accept either #%x%x%x or rgb:%d/%d/%d\n\t// Sometime rgb:%d/%d/%d should be encoded into the 0..65535 range, so #%x%x%x is more reliable\n\tsetCursorColorRgb: { on: '\\x1b]12;#%x%x%x\\x07' } ,\t// it want rgb as parameter, like rgb:127/0/32\n\tresetCursorColorRgb: { on: '\\x1b]112\\x07' } ,\n\tsetDefaultColorRgb: { on: '\\x1b]10;#%x%x%x\\x07' } ,\t// not widely supported\n\tresetDefaultColorRgb: { on: '\\x1b]110\\x07' } ,\n\tsetDefaultBgColorRgb: { on: '\\x1b]11;#%x%x%x\\x07' } ,\t// not widely supported\n\tresetDefaultBgColorRgb: { on: '\\x1b]111\\x07' } ,\n\tsetHighlightBgColorRgb: { on: '\\x1b]17;#%x%x%x\\x07' } ,\t// not widely supported\n\tresetHighlightBgColorRgb: { on: '\\x1b]117\\x07' } ,\n\tsetColorLL: { on: '\\x1b]4;%u;#%x%x%x\\x07' } ,\t// LL= Low Level\n\tresetColorLL: { on: '\\x1b]104;%u\\x07' } ,\n\t\n\tsetFont: { on: '\\x1b]50;%s\\x07' } ,\t// ->|TODOC|<- rarely supported\n\tcolor24bits: { on: '%D%D%D' , na: true } ,\t// not capable\n\tbgColor24bits: { on: '%D%D%D' , na: true } ,\t// not capable\n\t\n\t\t\t/* Functions */\n\t\n\tcolor256: {\n\t\ton: '%[color256:%a]F' ,\n\t\toff: defaultColor ,\n\t\tfb: true ,\n\t\thandler: function color256( register ) {\n\t\t\t\n\t\t\tif ( typeof register !== 'number' ) { return '' ; }\n\t\t\tif ( register < 0 || register > 255 ) { return '' ; }\n\t\t\t\n\t\t\t// If the register is greater than 15, find the 0..15 register that is close to it\n\t\t\tif ( register > 15 )\n\t\t\t{\n\t\t\t\tregister = this.root.registerForRgb( this.root.rgbForRegister( register ) , 0 , 15 ) ;\n\t\t\t}\n\t\t\t\n\t\t\t//return string.format.call( this.root.escHandler , this.root.esc.color.on , register ) ;\n\t\t\treturn this.root.escHandler.color( register ) ;\n\t\t}\n\t} ,\n\t\n\tbgColor256: {\n\t\ton: '%[bgColor256:%a]F' ,\n\t\toff: bgDefaultColor ,\n\t\tfb: true ,\n\t\thandler: function bgColor256( register ) {\n\t\t\t\n\t\t\tif ( typeof register !== 'number' ) { return '' ; }\n\t\t\tif ( register < 0 || register > 255 ) { return '' ; }\n\t\t\t\n\t\t\t// If the register is greater than 15, find the 0..15 register that is close to it\n\t\t\tif ( register > 15 )\n\t\t\t{\n\t\t\t\tregister = this.root.registerForRgb( this.root.rgbForRegister( register ) , 0 , 15 ) ;\n\t\t\t}\n\t\t\t\n\t\t\t//return string.format.call( this.root.escHandler , this.root.esc.bgColor.on , register ) ;\n\t\t\treturn this.root.escHandler.bgColor( register ) ;\n\t\t}\n\t} ,\n\t\n\t// Cannot find a way to set the cursor to a register, so try to guess\n\tsetCursorColor: {\n\t\ton: '%[setCursorColor:%a%a]F' ,\n\t\thandler: function setCursorColor( bg , fg ) {\n\t\t\t\n\t\t\tif ( typeof fg !== 'number' || typeof bg !== 'number' ) { return '' ; }\n\t\t\t\n\t\t\tfg = Math.floor( fg ) ;\n\t\t\tbg = Math.floor( bg ) ;\n\t\t\t\n\t\t\tif ( fg < 0 || fg > 255 || bg < 0 || bg > 255 ) { return '' ; }\n\t\t\t\n\t\t\tvar rgb = this.root.rgbForRegister( bg ) ;\n\t\t\t\n\t\t\treturn string.format( this.root.esc.setCursorColorRgb.on , rgb.r , rgb.g , rgb.b ) ;\n\t\t}\n\t}\n\t\n} ;\n\n\n\n\n\n\t\t\t/* Inputs management */\n\n\n\nvar handler = {} ;\n\n\n\nhandler.mouseX11Protocol = function mouseX11Protocol( basename , buffer )\n{\n\tvar code = buffer[ 0 ] ;\n\tvar result = {\n\t\tdata: {\n\t\t\tshift: code & 4 ? true : false ,\n\t\t\talt: code & 8 ? true : false ,\n\t\t\tctrl: code & 16 ? true : false\n\t\t}\n\t} ;\n\t\n\tif ( code & 32 )\n\t{\n\t\tif ( code & 64 )\n\t\t{\n\t\t\tresult.name = basename + ( code & 1 ? '_WHEEL_DOWN' : '_WHEEL_UP' ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Button event\n\t\t\tswitch ( code & 3 )\n\t\t\t{\n\t\t\t\tcase 0 : result.name = basename + '_LEFT_BUTTON_PRESSED' ; break ;\n\t\t\t\tcase 1 : result.name = basename + '_MIDDLE_BUTTON_PRESSED' ; break ;\n\t\t\t\tcase 2 : result.name = basename + '_RIGHT_BUTTON_PRESSED' ; break ;\n\t\t\t\tcase 3 : result.name = basename + '_BUTTON_RELEASED' ; break ;\n\t\t\t}\n\t\t}\n\t}\n\telse if ( code & 64 )\n\t{\n\t\t// Motion event\n\t\tresult.name = basename + '_MOTION' ;\n\t}\n\t\n\tresult.eaten = 3 ;\n\tresult.data.code = code ;\n\tresult.data.x = buffer[ 1 ] - 32 ;\n\tresult.data.y = buffer[ 2 ] - 32 ;\n\t\n\treturn result ;\n} ;\n\n\n\nhandler.mouseSGRProtocol = function mouseSGRProtocol( basename , buffer )\n{\n\tvar code , pressed , matches , result ;\n\t\n\tmatches = buffer.toString().match( /^(-?[0-9]*);?([0-9]*);?([0-9]*)(M|m)/ ) ;\n\t//matches = ';;M'.match( /^([0-9]*);?([0-9]*);?([0-9]*)(M|m)/ ) ;\n\t\n\tif ( ! matches || matches[ 3 ].length === 0 )\n\t{\n\t\treturn {\n\t\t\tname: 'ERROR' ,\n\t\t\teaten: matches ? matches[ 0 ].length : 0 ,\n\t\t\tdata: { matches: matches }\n\t\t} ;\n\t}\n\t\n\tcode = parseInt( matches[ 1 ] , 10 ) ;\n\tpressed = matches[ 4 ] !== 'm' ;\n\t\n\tresult = {\n\t\tdata: {\n\t\t\tshift: code & 4 ? true : false ,\n\t\t\talt: code & 8 ? true : false ,\n\t\t\tctrl: code & 16 ? true : false\n\t\t}\n\t} ;\n\t\n\tresult.data.x = parseInt( matches[ 2 ] , 10 ) ;\n\tresult.data.y = parseInt( matches[ 3 ] , 10 ) ;\n\tresult.eaten = matches[ 0 ].length ;\n\t\n\tif ( code & 32 )\n\t{\n\t\t// Motions event\n\t\tresult.name = basename + '_MOTION' ;\n\t}\n\telse\n\t{\n\t\tif ( code & 64 )\n\t\t{\n\t\t\tresult.name = basename + ( code & 1 ? '_WHEEL_DOWN' : '_WHEEL_UP' ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Button event\n\t\t\tswitch ( code & 3 )\n\t\t\t{\n\t\t\t\tcase 0 :\n\t\t\t\t\tresult.name = basename + '_LEFT_BUTTON' ;\n\t\t\t\t\t//if ( this.state.button.left === pressed ) { result.disable = true ; }\n\t\t\t\t\tthis.state.button.left = pressed ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\t\n\t\t\t\tcase 1 :\n\t\t\t\t\tresult.name = basename + '_MIDDLE_BUTTON' ;\n\t\t\t\t\t//if ( this.state.button.middle === pressed ) { result.disable = true ; }\n\t\t\t\t\tthis.state.button.middle = pressed ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\t\n\t\t\t\tcase 2 :\n\t\t\t\t\tresult.name = basename + '_RIGHT_BUTTON' ;\n\t\t\t\t\t//if ( this.state.button.right === pressed ) { result.disable = true ; }\n\t\t\t\t\tthis.state.button.right = pressed ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\t\n\t\t\t\tcase 3 :\n\t\t\t\t\tresult.name = basename + '_OTHER_BUTTON' ;\n\t\t\t\t\t//if ( this.state.button.other === pressed ) { result.disable = true ; }\n\t\t\t\t\tthis.state.button.other = pressed ;\n\t\t\t\t\tbreak ;\n\t\t\t}\n\t\t\t\n\t\t\tresult.name += pressed ? '_PRESSED' : '_RELEASED' ;\n\t\t}\n\t}\n\t\n\tresult.data.code = code ;\n\t\n\treturn result ;\n} ;\n\n\n\nhandler.cursorLocation = function cursorLocation( basename , paramString )\n{\n\tvar params = paramString.split( ';' ) ;\n\t\n\treturn {\n\t\tname: 'CURSOR_LOCATION' ,\n\t\tdata: {\n\t\t\tx: parseInt( params[ 1 ] , 10 ) ,\n\t\t\ty: parseInt( params[ 0 ] , 10 )\n\t\t}\n\t} ;\n} ;\n\n\n\nhandler.colorRegister = function colorRegister( basename , paramString )\n{\n\tvar matches = paramString.match( /^([0-9]*);rgb:([0-9a-f]{2})[0-9a-f]*\\/([0-9a-f]{2})[0-9a-f]*\\/([0-9a-f]{2})[0-9a-f]*/ ) ;\n\t\n\treturn {\n\t\tname: 'COLOR_REGISTER' ,\n\t\tdata: {\n\t\t\tregister: parseInt( matches[ 1 ] , 10 ) ,\n\t\t\tr: parseInt( matches[ 2 ] , 16 ) ,\n\t\t\tg: parseInt( matches[ 3 ] , 16 ) ,\n\t\t\tb: parseInt( matches[ 4 ] , 16 )\n\t\t}\n\t} ;\n} ;\n\n\n\nhandler.screenSize = function screenSize( basename , paramString )\n{\n\tvar params = paramString.split( ';' ) ,\n\t\twidth = parseInt( params[ 1 ] , 10 ) ,\n\t\theight = parseInt( params[ 0 ] , 10 ) ,\n\t\tresized = this.root.width !== width || this.root.height !== height ;\n\t\n\tthis.root.width = width ;\n\tthis.root.height = height ;\n\t\n\treturn {\n\t\tname: 'SCREEN_SIZE' ,\n\t\tdata: {\n\t\t\tresized: resized ,\n\t\t\twidth: width ,\n\t\t\theight: height\n\t\t}\n\t} ;\n} ;\n\n\n\n\n\n\t\t\t/* Key Mapping */\n\n\n\nvar keymap = {\n\t\n\tESCAPE: '\\x1b' ,\n\tTAB: '\\x09' ,\n\tENTER: '\\x0d' ,\n\t\n\tUP: [ '\\x1bOA' , '\\x1b[A' ] ,\n\tDOWN: [ '\\x1bOB' , '\\x1b[B' ] ,\n\tRIGHT: [ '\\x1bOC' , '\\x1b[C' ] ,\n\tLEFT: [ '\\x1bOD' , '\\x1b[D' ] ,\n\t\n\t//BACKSPACE: '\\x7f' ,\n\tBACKSPACE: [ '\\x7f' , '\\x08' ] ,\t// Most terminal use \\x08 for Ctrl-backspace, except Terminology...\n\tINSERT: '\\x1b[2~' ,\n\tDELETE: '\\x1b[3~' ,\n\tHOME:[ '\\x1b[1~' , '\\x1b[H' , '\\x1bOH' ] ,\n\tEND: [ '\\x1b[4~' , '\\x1b[F' , '\\x1bOF' ] ,\n\tPAGE_UP: '\\x1b[5~' ,\n\tPAGE_DOWN: '\\x1b[6~' ,\n\t\n\t//CTRL_BACKSPACE: '\\x08' ,\n\tCTRL_INSERT: '\\x1b[2;5~' ,\n\tCTRL_DELETE: '\\x1b[3;5~' ,\n\tCTRL_HOME: [ '\\x1b[1;5~' , '\\x1b[1;5H' ] ,\n\tCTRL_END: [ '\\x1b[4;5~' , '\\x1b[1;5F' ] ,\n\tCTRL_PAGE_UP: '\\x1b[5;5~' ,\n\tCTRL_PAGE_DOWN: '\\x1b[6;5~' ,\n\t\n\tSHIFT_INSERT: '\\x1b[2;2~' ,\n\tSHIFT_DELETE: '\\x1b[3;2~' ,\n\tSHIFT_HOME: [ '\\x1b[1;2~' , '\\x1b[1;2H' ] ,\n\tSHIFT_END: [ '\\x1b[4;2~' , '\\x1b[1;2F' ] ,\n\tSHIFT_PAGE_UP: '\\x1b[5;2~' ,\n\tSHIFT_PAGE_DOWN: '\\x1b[6;2~' ,\n\t\n\tALT_BACKSPACE: [ '\\x1b\\x7f' , '\\x1b\\x08' ] ,\n\tALT_INSERT: '\\x1b[2;3~' ,\n\tALT_DELETE: '\\x1b[3;3~' ,\n\tALT_HOME: [ '\\x1b[1;3~' , '\\x1b[1;3H' ] ,\n\tALT_END: [ '\\x1b[4;3~' , '\\x1b[1;3F' ] ,\n\tALT_PAGE_UP: '\\x1b[5;3~' ,\n\tALT_PAGE_DOWN: '\\x1b[6;3~' ,\n\t\n\t// Application Keypad\n\tKP_NUMLOCK: [] ,\t// '\\x1bOP' ,\n\tKP_DIVIDE: '\\x1bOo' ,\n\tKP_MULTIPLY: '\\x1bOj' ,\n\tKP_MINUS: '\\x1bOm' ,\n\tKP_0: [] ,\t// '\\x1b[2~' ,\n\tKP_1: [] ,\t// '\\x1bOF' ,\n\tKP_2: [] ,\t// '\\x1b[B' ,\n\tKP_3: [] ,\t// '\\x1b[6~' ,\n\tKP_4: [] ,\t// '\\x1b[D' ,\n\tKP_5: [ '\\x1bOE' , '\\x1b[E' ] ,\n\tKP_6: [] ,\t// '\\x1b[C' ,\n\tKP_7: [] ,\t// '\\x1bOH' ,\n\tKP_8: [] ,\t// '\\x1b[A' ,\n\tKP_9: [] ,\t// '\\x1b[5~' ,\n\tKP_PLUS: '\\x1bOk' ,\n\tKP_DELETE: [] ,\t// '\\x1b[3~' ,\n\tKP_ENTER: '\\x1bOM' ,\n\t\n\tF1: '\\x1bOP' ,\n\tF2: '\\x1bOQ' ,\n\tF3: '\\x1bOR' ,\n\tF4: '\\x1bOS' ,\n\tF5: '\\x1b[15~' ,\n\tF6: '\\x1b[17~' ,\n\tF7: '\\x1b[18~' ,\n\tF8: '\\x1b[19~' ,\n\tF9: '\\x1b[20~' ,\n\tF10: '\\x1b[21~' ,\n\tF11: [ '\\x1b[23~' , '\\x1b[22~' ] ,\n\tF12: '\\x1b[24~' ,\n\t\n\tSHIFT_F1: [ '\\x1bO1;2P' , '\\x1bO2P' , '\\x1b[1;2P' ] ,\n\tSHIFT_F2: [ '\\x1bO1;2Q' , '\\x1bO2Q' , '\\x1b[1;2Q' ] ,\n\tSHIFT_F3: [ '\\x1bO1;2R' , '\\x1bO2R' , '\\x1b[1;2R' ] ,\n\tSHIFT_F4: [ '\\x1bO1;2S' , '\\x1bO2S' , '\\x1b[1;2S' ] ,\n\tSHIFT_F5: '\\x1b[15;2~' ,\n\tSHIFT_F6: '\\x1b[17;2~' ,\n\tSHIFT_F7: '\\x1b[18;2~' ,\n\tSHIFT_F8: '\\x1b[19;2~' ,\n\tSHIFT_F9: '\\x1b[20;2~' ,\n\tSHIFT_F10: '\\x1b[21;2~' ,\n\tSHIFT_F11: [ '\\x1b[23;2~' , '\\x1b[22;2~' ] ,\n\tSHIFT_F12: '\\x1b[24;2~' ,\n\t\n\tCTRL_F1: [ '\\x1bO1;5P' , '\\x1bO5P' , '\\x1b[1;5P' ] ,\n\tCTRL_F2: [ '\\x1bO1;5Q' , '\\x1bO5Q' , '\\x1b[1;5Q' ] ,\n\tCTRL_F3: [ '\\x1bO1;5R' , '\\x1bO5R' /*, '\\x1b[1;5R'*/ ] ,\t// also used for cursor location response... :/\n\tCTRL_F4: [ '\\x1bO1;5S' , '\\x1bO5S' , '\\x1b[1;5S' ] ,\n\tCTRL_F5: '\\x1b[15;5~' ,\n\tCTRL_F6: '\\x1b[17;5~' ,\n\tCTRL_F7: '\\x1b[18;5~' ,\n\tCTRL_F8: '\\x1b[19;5~' ,\n\tCTRL_F9: '\\x1b[20;5~' ,\n\tCTRL_F10: '\\x1b[21;5~' ,\n\tCTRL_F11: [ '\\x1b[23;5~' , '\\x1b[22;5~' ] ,\n\tCTRL_F12: '\\x1b[24;5~' ,\n\t\n\tCTRL_SHIFT_F1: [ '\\x1bO1;6P' , '\\x1bO6P' , '\\x1b[1;6P' ] ,\n\tCTRL_SHIFT_F2: [ '\\x1bO1;6Q' , '\\x1bO6Q' , '\\x1b[1;6Q' ] ,\n\tCTRL_SHIFT_F3: [ '\\x1bO1;6R' , '\\x1bO6R' /*, '\\x1b[1;6R'*/ ] ,\t// also used for cursor location response... :/\n\tCTRL_SHIFT_F4: [ '\\x1bO1;6S' , '\\x1bO6S' , '\\x1b[1;6S' ] ,\n\tCTRL_SHIFT_F5: '\\x1b[15;6~' ,\n\tCTRL_SHIFT_F6: '\\x1b[17;6~' ,\n\tCTRL_SHIFT_F7: '\\x1b[18;6~' ,\n\tCTRL_SHIFT_F8: '\\x1b[19;6~' ,\n\tCTRL_SHIFT_F9: '\\x1b[20;6~' ,\n\tCTRL_SHIFT_F10: '\\x1b[21;6~' ,\n\tCTRL_SHIFT_F11: [ '\\x1b[23;6~' , '\\x1b[22;6~' ] ,\n\tCTRL_SHIFT_F12: '\\x1b[24;6~' ,\n\t\n\tSHIFT_TAB: '\\x1b[Z' ,\n\tALT_TAB: '\\x1b\\x09' ,\t// Also CTRL_ALT_I, most of time it is grabbed by the window manager before reaching the terminal\n\t\n\tSHIFT_UP: '\\x1b[1;2A' ,\n\tSHIFT_DOWN: '\\x1b[1;2B' ,\n\tSHIFT_RIGHT: '\\x1b[1;2C' ,\n\tSHIFT_LEFT: '\\x1b[1;2D' ,\n\tALT_UP: '\\x1b[1;3A' ,\n\tALT_DOWN: '\\x1b[1;3B' ,\n\tALT_RIGHT: '\\x1b[1;3C' ,\n\tALT_LEFT: '\\x1b[1;3D' ,\n\tCTRL_UP: '\\x1b[1;5A' ,\n\tCTRL_DOWN: '\\x1b[1;5B' ,\n\tCTRL_RIGHT: '\\x1b[1;5C' ,\n\tCTRL_LEFT: '\\x1b[1;5D' ,\n\t\n\tNUL: '\\x00' ,\n\t\n\t//CTRL_SPACE: '\\x00' ,\t// also NUL\n\tALT_SPACE: '\\x1b ',\n\tCTRL_ALT_SPACE: '\\x1b\\x00',\n\t\n\tCURSOR_LOCATION: { starter: '\\x1b[' , ender: 'R' , event: 'terminal' , handler: 'cursorLocation' } ,\n\tSCREEN_SIZE: { starter: '\\x1b[8;' , ender: 't' , event: 'terminal' , handler: 'screenSize' } ,\n\tCOLOR_REGISTER: { starter: '\\x1b]4;' , ender: '\\x07' , event: 'terminal' , handler: 'colorRegister' } ,\n\t\n\tFOCUS_IN: { code: '\\x1b[I' , event: 'terminal' , data: {} } ,\n\tFOCUS_OUT: { code: '\\x1b[O' , event: 'terminal' , data: {} } ,\n\t\n\tMOUSE: [\n\t\t{ code: '\\x1b[<' , event: 'mouse' , handler: 'mouseSGRProtocol' } ,\n\t\t{ code: '\\x1b[M' , event: 'mouse' , handler: 'mouseX11Protocol' }\n\t]\n} ;\n\n\n\n// Complete with Modifier + [A-Z]\nfor ( var i = 1 ; i <= 26 ; i ++ )\n{\n\tkeymap[ 'CTRL_' + String.fromCharCode( 64 + i ) ] = String.fromCharCode( i ) ;\n\tkeymap[ 'ALT_' + String.fromCharCode( 64 + i ) ] = '\\x1b' + String.fromCharCode( 96 + i ) ;\n\tkeymap[ 'CTRL_ALT_' + String.fromCharCode( 64 + i ) ] = '\\x1b' + String.fromCharCode( i ) ;\n\tkeymap[ 'ALT_SHIFT_' + String.fromCharCode( 64 + i ) ] = '\\x1b' + String.fromCharCode( 64 + i ) ;\n}\n\n\n\nmodule.exports = {\n\tesc: esc ,\n\tkeymap: keymap ,\n\thandler: handler ,\n\tsupport: {\n\t\tdeltaEscapeSequence: true ,\n\t\t\"256colors\": false ,\n\t\t\"24bitsColors\": false\n\t} ,\n\tcolorRegister: require( '../colorScheme/xterm.json' )\n} ;\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/demo/spaceship.js":"#!/usr/bin/env node\n/*\n\tThe Cedric's Swiss Knife (CSK) - CSK terminal demo\n\t\n\tCopyright (c) 2009 - 2014 Cédric Ronvel \n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\nvar fs = require( 'fs' ) ;\nvar termkit = require( '../lib/termkit.js' ) ;\nvar term ;\nvar ScreenBuffer = termkit.ScreenBuffer ;\n\n\n\n// Buffers\nvar viewport , sprites = {} ;\n\n\n\nfunction init( callback )\n{\n\ttermkit.getDetectedTerminal( function( error , detectedTerm ) {\n\t\t\n\t\tif ( error ) { throw new Error( 'Cannot detect terminal.' ) ; }\n\t\t\n\t\tterm = detectedTerm ;\n\t\t\n\t\tviewport = ScreenBuffer.create( {\n\t\t\tdst: term ,\n\t\t\twidth: Math.min( term.width ) ,\n\t\t\theight: Math.min( term.height - 1 ) ,\n\t\t\ty: 2\n\t\t} ) ;\n\t\t\n\t\tcreateBackground() ;\n\t\tcreateSpaceship() ;\n\t\t\n\t\t//term.fullscreen() ;\n\t\tterm.moveTo.eraseLine.bgWhite.green( 1 , 1 , 'Arrow keys: move the ship - CTRL-C: Quit\\n' ) ;\n\t\tterm.hideCursor() ;\n\t\tterm.grabInput() ;\n\t\tterm.on( 'key' , inputs ) ;\n\t\tcallback() ;\n\t} ) ;\n}\n\n\n\nfunction terminate()\n{\n\t//term.fullscreen( false ) ;\n\tterm.hideCursor( false ) ;\n\tterm.grabInput( false ) ;\n\t\n\tsetTimeout( function() {\n\t\tterm.moveTo( 1 , term.height , '\\n\\n' ) ;\n\t\tprocess.exit() ;\n\t} , 100 ) ;\n}\n\n\n\nfunction createBackground()\n{\n\tsprites.background = ScreenBuffer.create( { width: viewport.width * 4 , height: viewport.height } ) ;\n\t\n\tsprites.planet = ScreenBuffer.createFromChars(\n\t\t{ attr: { color: 'yellow' , bold: false } , transparencyChar: ' ' } ,\n\t\tfs.readFileSync( __dirname + '/data/saturn.txt' )\n\t) ;\n\t\n\tsprites.planet = ScreenBuffer.loadSync( __dirname + '/data/saturn.sbuf' ) ;\n\t\n\tcreateBackgroundStars( sprites.background.width * sprites.background.height * 0.004 ) ;\n\tcreateBackgroundTrails( sprites.background.width * sprites.background.height * 0.008 ) ;\n\tcreateBackgroundPlanets( sprites.background.width * sprites.background.height * 0.0001 ) ;\n}\n\n\n\nfunction createBackgroundTrails( nTrails )\n{\n\tvar i , j , x , y , length ;\n\t\n\tfor ( i = 0 ; i < nTrails ; i ++ )\n\t{\n\t\tx = Math.floor( Math.random() * sprites.background.width ) ;\n\t\ty = Math.floor( Math.random() * sprites.background.height ) ;\n\t\tlength = 3 + Math.floor( Math.random() * 8 ) ;\n\t\t\n\t\tfor ( j = 0 ; j < length ; j ++ )\n\t\t{\n\t\t\tsprites.background.put( {\n\t\t\t\tx: ( x + j ) % sprites.background.width ,\n\t\t\t\ty: y ,\n\t\t\t\tattr: { color: 8 }\n\t\t\t} , '-' ) ;\n\t\t}\n\t}\n}\n\n\n\nfunction createBackgroundStars( nStars )\n{\n\tvar i , x , y , c , char , stars = [ '*' , '.' , 'o' , '+' , '°' ] ;\n\t\n\tfor ( i = 0 ; i < nStars ; i ++ )\n\t{\n\t\tx = Math.floor( Math.random() * sprites.background.width ) ;\n\t\ty = Math.floor( Math.random() * sprites.background.height ) ;\n\t\tchar = stars[ Math.floor( Math.random() * stars.length ) ] ;\n\t\tc = Math.floor( Math.random() * 16 ) ;\n\t\t\n\t\tsprites.background.put( {\n\t\t\tx: x ,\n\t\t\ty: y ,\n\t\t\tattr: { color: c }\n\t\t} , char ) ;\n\t}\n}\n\n\n\nfunction createBackgroundPlanets( nPlanets )\n{\n\tvar i , x , y ;\n\t\n\tfor ( i = 0 ; i < nPlanets ; i ++ )\n\t{\n\t\tx = Math.floor( Math.random() * sprites.background.width ) ;\n\t\ty = Math.floor( Math.random() * sprites.background.height ) ;\n\t\t\n\t\tsprites.planet.draw( {\n\t\t\tdst: sprites.background ,\n\t\t\tx: Math.floor( x - sprites.planet.width / 2 ) ,\n\t\t\ty: Math.floor( y - sprites.planet.height / 2 ) ,\n\t\t\tblending: true ,\n\t\t\twrap: 'x'\n\t\t} ) ;\n\t}\n}\n\n\n\nfunction createSpaceship()\n{\n\t/*\n\tsprites.spaceship = ScreenBuffer.createFromChars(\n\t\t{ attr: { color: 'cyan' , bold: true } , transparencyChar: '#' , transparencyType: ScreenBuffer.TRANSPARENCY } ,\n\t\tfs.readFileSync( __dirname + '/data/spaceship1.txt' )\n\t) ;\n\t*/\n\t\n\tsprites.spaceship = ScreenBuffer.loadSync( __dirname + '/data/spaceship1.sbuf' ) ;\n\t\n\tsprites.spaceship.x = 3 ;\n\tsprites.spaceship.y = Math.floor( viewport.height / 2 - sprites.spaceship.height / 2 ) ;\n}\n\n\n\nfunction inputs( key )\n{\n\tswitch ( key )\n\t{\n\t\tcase 'UP' :\n\t\t\tsprites.spaceship.y -- ;\n\t\t\tbreak ;\n\t\tcase 'DOWN' :\n\t\t\tsprites.spaceship.y ++ ;\n\t\t\tbreak ;\n\t\tcase 'LEFT' :\n\t\t\tsprites.spaceship.x -- ;\n\t\t\tbreak ;\n\t\tcase 'RIGHT' :\n\t\t\tsprites.spaceship.x ++ ;\n\t\t\tbreak ;\n\t\tcase 'CTRL_C':\n\t\t\tterminate() ;\n\t\t\tbreak ;\n\t}\n}\n\n\n\nfunction nextPosition()\n{\n\tsprites.background.x -- ;\n}\n\n\n\nvar frames = 0 ;\nfunction draw()\n{\n\tsprites.background.draw( { dst: viewport , tile: true } ) ;\n\tsprites.spaceship.draw( { dst: viewport , blending: true , wrap: 'both' } ) ;\n\tvar stats = viewport.draw( { delta: true } ) ;\n\t\n\tterm.moveTo.eraseLine.bgWhite.green( 1 , 1 ,\n\t\t'Arrow keys: move the ship - CTRL-C: Quit - Redraw stats: %d cells, %d moves, %d attrs, %d writes\\n' ,\n\t\tstats.cells , stats.moves , stats.attrs , stats.writes\n\t) ;\n\t\n\tframes ++ ;\n}\n\n\n\nfunction animate()\n{\n\tdraw() ;\n\tnextPosition() ;\n\tsetTimeout( animate , 50 ) ;\n}\n\n\n\ninit( function() {\n\tanimate() ;\n} ) ;\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/gpm.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n/*\n\tThis module try to stay close to the original GPM lib written in C.\n*/\n\n\n\nvar net = require( 'net' ) ;\n//var events = require( 'events' ) ;\nvar NextGenEvents = require( 'nextgen-events' ) ;\nvar termkit = require( './termkit.js' ) ;\n\n//var async = require( 'async-kit' ) ;\n\n\n\nvar gpm = {} ;\nmodule.exports = gpm ;\n\n\n\n\n\n\t\t\t/* GPM structures & constants */\n\t\t\t/* as found in the GPM source code: src/headers/gpm.h */\n\n\n\n// Can't figure out the usage of the GPM_MAGIC constant ATM\nvar gpmMagic = Buffer.allocUnsafe( 4 ) ;\ngpmMagic.writeUInt32LE( 0x47706D4C , 0 ) ;\n\n\n\n// Return a Buffer containing a Gpm_Connect structure, using a pid and a ttyIndex\ngpm.connectStructureBuffer = function connectStructureBuffer( gpmConnect )\n{\n\tvar buffer = Buffer.allocUnsafe( 16 ) ;\n\t\n\tif ( gpmConnect.eventMask === undefined ) { gpmConnect.eventMask = 65535 ; }\n\tif ( gpmConnect.defaultMask === undefined ) { gpmConnect.defaultMask = 0 ; }\n\tif ( gpmConnect.minMod === undefined ) { gpmConnect.minMod = 0 ; }\n\tif ( gpmConnect.maxMod === undefined ) { gpmConnect.maxMod = 65535 ; }\n\t\n\t//Looks like it want Little Endian\n\tbuffer.writeUInt16LE( gpmConnect.eventMask , 0 ) ;\t// eventMask: wanted events\n\tbuffer.writeUInt16LE( gpmConnect.defaultMask , 2 ) ;\t// defaultMask: things handled by default\n\tbuffer.writeUInt16LE( gpmConnect.minMod , 4 ) ;\t// minMod: want everything (modifier keys)\n\tbuffer.writeUInt16LE( gpmConnect.maxMod , 6 ) ;\t// maxMod: all modifiers keys included\n\tbuffer.writeUInt32LE( gpmConnect.pid , 8 ) ;\t// pid\n\tbuffer.writeUInt32LE( gpmConnect.vc , 12 ) ;\t// vc: the TTY index \n\t\n\t//console.log( buffer ) ;\n\t\n\treturn buffer ;\n} ;\n\n\n\n// Extract a Gpm_Event from a Buffer\ngpm.eventStructure = function eventStructure( buffer )\n{\n\tvar event = {} ;\n\t\n\t//Looks like it is in Little Endian\n\tevent.buttons = buffer.readUInt8( 0 ) ;\n\tevent.modifiers = buffer.readUInt8( 1 ) ;\n\t\n\tevent.vc = buffer.readUInt16LE( 2 ) ;\n\t\n\tevent.dx = buffer.readInt16LE( 4 ) ;\n\tevent.dy = buffer.readInt16LE( 6 ) ;\n\tevent.x = buffer.readInt16LE( 8 ) ;\n\tevent.y = buffer.readInt16LE( 10 ) ;\n\t\n\tevent.eType = buffer.readUInt32LE( 12 ) ;\n\t\n\tevent.clicks = buffer.readUInt32LE( 16 ) ;\n\t\n\tevent.margin = buffer.readUInt32LE( 20 ) ;\n\t\n\tevent.wdx = buffer.readInt16LE( 24 ) ;\n\tevent.wdy = buffer.readInt16LE( 26 ) ;\n\t\n\t//console.log( event ) ;\n\t\n\treturn event ;\n} ;\n\n\n\n//enum Gpm_Etype (comments are copy-paste of gpm.h)\n\ngpm.MOVE = 1 ;   \ngpm.DRAG = 2 ;\t// exactly one of the bare ones is active at a time\ngpm.DOWN = 4 ;\ngpm.UP = 8 ;\n\ngpm.SINGLE = 16 ;\t// at most one in three is set\ngpm.DOUBLE = 32 ;\ngpm.TRIPLE = 64 ;\t// WARNING: I depend on the values\n\ngpm.MFLAG = 128 ;\t// motion during click?\ngpm.HARD = 256 ;\t// if set in the defaultMask, force an already used event to pass over to another handler\n\ngpm.ENTER = 512 ;\t// enter event, user in Roi's (Region Of Interest)\ngpm.LEAVE = 1024 ;\t// leave event, used in Roi's\n                                         \n\n\n//enum Gpm_Margin\n\ngpm.TOP = 1 ;\ngpm.BOT = 2 ;\ngpm.LFT = 4 ;\ngpm.RGT = 8 ;\n\n\n\n\n\n\t\t\t/* GPM event handler */\n\n\n\ngpm.Handler = function Handler() { throw new Error( '[terminal] Cannot create a gpm.Handler object directly, use gpm.createHandler() instead' ) ; } ;\ngpm.Handler.prototype = Object.create( NextGenEvents.prototype ) ;\ngpm.Handler.prototype.constructor = gpm.Handler ;\n\n\n\n// Create a new GPM Handler\ngpm.createHandler = function createHandler( options )\n{\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\t\n\tif ( options.raw === undefined ) { options.raw = true ; }\n\tif ( options.stdin === undefined ) { options.stdin = 0 ; /*process.stdin ;*/ }\n\tif ( options.mode === undefined ) { options.mode = 'motion' ; }\n\t\n\tvar connectMode = { pid: process.pid } ;\n\t\n\tconnectMode.defaultMask =\n\t\tgpm.MOVE | gpm.DRAG | gpm.DOWN | gpm.UP | gpm.SINGLE | gpm.DOUBLE | gpm.TRIPLE | gpm.MFLAG | gpm.HARD ;\n\t\n\tswitch ( options.mode )\n\t{\n\t\tcase 'button' :\n\t\t\tconnectMode.eventMask = gpm.DOWN | gpm.UP ;\n\t\t\tbreak ;\n\t\tcase 'drag' :\n\t\t\tconnectMode.eventMask = gpm.DRAG | gpm.DOWN | gpm.UP ;\n\t\t\tbreak ;\n\t\tcase 'motion' :\t/* jshint ignore:line */\n\t\tdefault :\n\t\t\tconnectMode.eventMask = gpm.MOVE | gpm.DRAG | gpm.DOWN | gpm.UP ;\n\t\t\tbreak ;\n\t}\n\t\n\tvar handler = Object.create( gpm.Handler.prototype ) ;\n\t\n\t\n\tvar tty = termkit.tty.getPath( options.stdin ) ;\n\t\n\t//if ( ! tty.index ) { handler.emit( 'error' , new Error( 'Not a TTY' ) ) ; return ; }\n\t\n\t//console.log( 'TTY:' , tty.index ) ;\n\tconnectMode.vc = tty.index || 0 ;\n\t\n\thandler.socket = new net.Socket() ;\n\tvar gpmConnect = gpm.connectStructureBuffer( connectMode ) ;\n\t\n\thandler.socket.connect( '/dev/gpmctl' , function() {\n\t\t//console.log( 'Connected' ) ;\n\t\thandler.socket.write( gpmConnect ) ;\n\t} ) ;\n\t\n\t// Re-emit event\n\thandler.socket.on( 'error' , function( error ) { handler.emit( 'error' , error ) ; handler.close() ; } ) ;\n\thandler.socket.on( 'end' , function() { handler.emit( 'end' ) ; } ) ;\n\thandler.socket.on( 'close' , function() { handler.emit( 'close' ) ; handler.close() ; } ) ;\n\t\n\thandler.socket.on( 'data' , function( buffer ) {\n\t\t\n\t\t//console.log( 'data' , buffer.length , buffer , '\\n' , eventStructure( buffer ) ) ;\n\t\tvar rawEvent = gpm.eventStructure( buffer ) ;\n\t\t\n\t\tif ( options.raw ) { handler.emit( 'mouse' , rawEvent ) ; return ; }\n\t\t\n\t\tvar terminalKitEvent = gpm.raw2terminalKitEvent( rawEvent ) ;\n\t\thandler.emit( 'mouse' , terminalKitEvent[ 0 ] , terminalKitEvent[ 1 ] ) ;\n\t} ) ;\n\t\n\treturn handler ;\n} ;\n\n\n\n// End/Close the underlying connection\ngpm.Handler.prototype.close = function handlerClose()\n{\n\tif ( this.socket )\n\t{\n\t\tthis.socket.destroy() ;\n\t\tthis.socket = undefined ;\n\t}\n} ;\n\n\n\n// Transform raw GPM event to terminal-kit event\ngpm.raw2terminalKitEvent = function raw2terminalKitEvent( event )\n{\n\tvar name ;\n\t\n\tvar terminalKitEvent = {\n\t\tshift: event.modifiers & 1 ? true : false ,\n\t\t//altGr: event.modifiers & 2 ? true : false ,\t// terminal-kit do not use altGr\n\t\tctrl: event.modifiers & 4 ? true : false ,\n\t\talt: event.modifiers & 8 ? true : false ,\n\t\tx: event.x ,\n\t\ty: event.y\n\t} ;\n\t\n\tif ( event.eType & gpm.DOWN )\n\t{\n\t\tname = 'MOUSE_LEFT_BUTTON_PRESSED' ;\n\t}\n\telse if ( event.eType & gpm.UP )\n\t{\n\t\tname = 'MOUSE_LEFT_BUTTON_RELEASED' ;\n\t}\n\telse if ( event.eType & gpm.MOVE || event.eType & gpm.DRAG )\n\t{\n\t\tname = 'MOUSE_MOTION' ;\n\t}\n\telse\n\t{\n\t\tname = 'MOUSE_UNKNOWN' ;\n\t}\n\t\n\treturn [ name , terminalKitEvent ] ;\n} ;\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/lib/terminfo.js":"/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n/*\n\tKnown tput/infocmp command name.\n\tThis will be used later, when the terminfo support will be coded.\n\thttp://pubs.opengroup.org/onlinepubs/7990989799/xcurses/terminfo.html\n*/\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/endian-benchmark.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n/* jshint unused:false */\n/* global describe, it, before, after */\n\n\n\nvar size = 100 , loop = 1000000 ;\nvar buf = new Buffer( size * 4 ) ;\n\n\n\nfunction test( method )\n{\n\tvar i , j , t1 , t2 , values = [] ;\n\t\n\t// First prepare random values, we do not want that those operation pollute the benchmark\n\tfor ( i = 0 ; i < loop ; i ++ )\n\t{\n\t\tvalues[ i ] = [] ;\n\t\tfor ( j = 0 ; j < 10 ; j ++ )\n\t\t{\n\t\t\tvalues[ i ][ j ] = [ Math.floor( Math.random() * ( 1 << 30 ) ) , Math.floor( Math.random() * size ) ] ;\n\t\t}\n\t}\n\t\n\t\n\t// Now start the real benchmark\n\tt1 = new Date() ;\n\t\n\tfor ( i = 0 ; i < loop ; i ++ )\n\t{\n\t\t// Partly unroll the loop, we dont want to benchmark the 'for' loop\n\t\tbuf[ method ]( values[ i ][ 0 ][ 0 ] , values[ i ][ 0 ][ 1 ] ) ;\n\t\tbuf[ method ]( values[ i ][ 1 ][ 0 ] , values[ i ][ 1 ][ 1 ] ) ;\n\t\tbuf[ method ]( values[ i ][ 2 ][ 0 ] , values[ i ][ 2 ][ 1 ] ) ;\n\t\tbuf[ method ]( values[ i ][ 3 ][ 0 ] , values[ i ][ 3 ][ 1 ] ) ;\n\t\tbuf[ method ]( values[ i ][ 4 ][ 0 ] , values[ i ][ 4 ][ 1 ] ) ;\n\t\tbuf[ method ]( values[ i ][ 5 ][ 0 ] , values[ i ][ 5 ][ 1 ] ) ;\n\t\tbuf[ method ]( values[ i ][ 6 ][ 0 ] , values[ i ][ 6 ][ 1 ] ) ;\n\t\tbuf[ method ]( values[ i ][ 7 ][ 0 ] , values[ i ][ 7 ][ 1 ] ) ;\n\t\tbuf[ method ]( values[ i ][ 8 ][ 0 ] , values[ i ][ 8 ][ 1 ] ) ;\n\t\tbuf[ method ]( values[ i ][ 9 ][ 0 ] , values[ i ][ 9 ][ 1 ] ) ;\n\t}\n\t\n\tt2 = new Date() ;\n\t\n\t// Display the result\n\tconsole.log( method , 'time:' , t2 - t1 , 'ms' ) ;\n}\n\n\n\ntest( 'writeUInt32BE' ) ;\ntest( 'writeUInt32BE' ) ;\ntest( 'writeUInt32LE' ) ;\ntest( 'writeUInt32LE' ) ;\ntest( 'writeInt32BE' ) ;\ntest( 'writeInt32BE' ) ;\ntest( 'writeInt32LE' ) ;\ntest( 'writeInt32LE' ) ;\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/event-loop-hanging.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n/* jshint unused:false */\n/* global describe, it, before, after */\n\n\nvar term = require( '../lib/termkit.js' ).terminal ;\n\n// Looks like it's not possible to ref() again stdin, so it's a no-go:\n// program will keep hanging if they have used stdin even once\n\n/*\nterm.grabInput() ;\n\nterm.on( 'key' , function( key ) {\n\tif ( key === 'CTRL_C' ) { process.exit() ; }\n} ) ;\n\nterm.grabInput( false ) ;\n\nprocess.stdin.removeAllListeners( 'data' ) ;\nterm.stdin.removeAllListeners( 'data' ) ;\n//*/\n\n//*\nfunction noop() {}\nprocess.stdin.on( 'data' , noop ) ;\n\nprocess.stdin.removeListener( 'data' , noop ) ;\n\nconsole.log( process._getActiveHandles() ) ;\nconsole.log( process._getActiveRequests() ) ;\n\n//process.stdin.unref() ;\n//process.stdin.ref() ;\n//process.stdin.removeAllListeners( 'data' ) ;\n\n//*/\n\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/file-input-doc1.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\"use strict\" ;\n\nvar term = require( 'terminal-kit' ).terminal ;\n\nterm( 'Choose a file: ' ) ;\n\nterm.fileInput(\n\t//{ baseDir: __dirname + '/../' } ,\n\t{ baseDir: '../' } ,\n\tfunction( error , input ) {\n\t\tif ( error )\n\t\t{\n\t\t\tterm.red.bold( \"\\nAn error occurs: \" + error + \"\\n\" ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tterm.green( \"\\nYour file is '%s'\\n\" , input ) ;\n\t\t}\n\t\t\n\t\tprocess.exit() ;\n\t}\n) ;\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/image-viewer.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\nvar termkit = require( 'terminal-kit' ) ;\nvar term = termkit.terminal ;\nvar path = require( 'path' ) ;\n\n\n\nif ( process.argv.length <= 2 )\n{\n\tterm.magenta( \"Usage is: ./%s <file-path> [-m] [<max-scale>]\\n\" , path.basename( process.argv[ 1 ] ) ) ;\n\tterm.gray( \"-m: load inside a ScreenBuffer and interactively move the image\\n\" , path.basename( process.argv[ 1 ] ) ) ;\n\tprocess.exit( 1 ) ;\n}\n\n\n\nvar screen , image , filler = { attr: {\n\t// 8-bit\n\tcolor: 'black' ,\n\tbgColor: 'black' ,\n\t// 32-bit\n\tr: 0 ,\n\tg: 0 ,\n\tb: 0 ,\n\tbgR: 0 ,\n\tbgG: 0 ,\n\tbgB: 0 ,\n} } ;\n\n\n\nvar SB = term.support['24bitsColors'] ? termkit.ScreenBufferHD : termkit.ScreenBuffer ;\nvar url = process.argv[ 2 ] ;\nvar move ;\nvar maxScale ;\n\n\n\n// Can't depend on minimist just for a sample code, so we had to parse the command line by ourself\nif ( process.argv[ 3 ] === '-m' )\n{\n\tmove = true ;\n\tmaxScale = process.argv[ 4 ] || 2 ;\n}\nelse\n{\n\tif ( process.argv[ 4 ] === '-m' )\n\t{\n\t\tmove = true ;\n\t\tmaxScale = process.argv[ 3 ] || 2 ;\n\t}\n\telse\n\t{\n\t\tmove = false ;\n\t\tmaxScale = process.argv[ 3 ] || 1 ;\n\t}\n}\n\n\n\nif ( ! move )\n{\n\tterm.drawImage(\n\t\turl ,\n\t\t{ shrink: { width: term.width * maxScale , height: ( term.height - 1 ) * 2 * maxScale } } ,\n\t\tfunction() {}\n\t) ;\n\n\treturn ;\n}\n\n\n\nSB.loadImage(\n\turl ,\n\t{\n\t\tterminal: term ,\n\t\tshrink: { width: term.width * maxScale , height: ( term.height - 1 ) * 2 * maxScale } \n\t} ,\n\tfunction( error , image_ )\n\t{\n\t\timage = image_ ;\n\t\t\n\t\tif ( error )\n\t\t{\n\t\t\tterm.red( \"%E\\n\" , error ) ;\n\t\t\tprocess.exit( 1 ) ;\n\t\t}\n\t\t\n\t\tscreen = SB.create( { dst: term , height: term.height - 1 , noFill: true } ) ;\n\t\tscreen.y = 2 ;\n\t\t\n\t\timage.dst = screen ;\n\t\t\n\t\tterm.clear() ;\n\t\tterm.grabInput() ;\n\t\tterm.hideCursor() ;\n\n\t\tterm.on( 'key' , function( key , matches , data ) {\n\t\t\t\n\t\t\tswitch ( key )\n\t\t\t{\n\t\t\t\tcase 'UP' :\n\t\t\t\t\timage.y += term.height / 20 ;\n\t\t\t\t\tredraw() ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase 'DOWN' :\n\t\t\t\t\timage.y -= term.height / 20 ;\n\t\t\t\t\tredraw() ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase 'LEFT' :\n\t\t\t\t\timage.x += term.width / 20 ;\n\t\t\t\t\tredraw() ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase 'RIGHT' :\n\t\t\t\t\timage.x -= term.width / 20 ;\n\t\t\t\t\tredraw() ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase 'q' :\n\t\t\t\tcase 'CTRL_C' :\n\t\t\t\t\tterminate() ;\n\t\t\t\t\tbreak ;\n\t\t\t}\n\t\t} ) ;\n\t\t\n\t\tredraw() ;\n\t\tterm.moveTo( 1 , 1 ).bgWhite.blue.eraseLineAfter( \"Arrows keys: move   Q/CTRL-C: quit\" ) ;\n\t}\n) ;\n\n\n\nfunction redraw()\n{\n\tscreen.fill( filler ) ;\n\timage.draw() ;\n\tscreen.draw( { delta: true } ) ;\n}\n\n\n\nfunction terminate()\n{\n\tterm.hideCursor( false ) ;\n\t//term.applicationKeypad( false ) ;\n\tterm.styleReset() ;\n\tterm.moveTo( term.width , term.height ) ;\n\tterm( '\\n' ) ;\n\tterm.processExit() ;\n} \n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/input-field-doc1.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\"use strict\" ;\n\nvar term = require( 'terminal-kit' ).terminal ;\n\nvar history = [ 'John' , 'Jack' , 'Joey' , 'Billy' , 'Bob' ] ;\n\nvar autoComplete = [\n\t'Barack Obama' , 'George W. Bush' , 'Bill Clinton' , 'George Bush' ,\n\t'Ronald W. Reagan' , 'Jimmy Carter' , 'Gerald Ford' , 'Richard Nixon' ,\n\t'Lyndon Johnson' , 'John F. Kennedy' , 'Dwight Eisenhower' ,\n\t'Harry Truman' , 'Franklin Roosevelt'\n] ;\n\nterm( 'Please enter your name: ' ) ;\n\nterm.inputField(\n\t{ history: history , autoComplete: autoComplete , autoCompleteMenu: true } ,\n\tfunction( error , input ) {\n\n\t\tterm.green( \"\\nYour name is '%s'\\n\" , input ) ;\n\t\tprocess.exit() ;\n\t}\n) ;\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/input-field-doc2.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\"use strict\" ;\n\nvar fs = require( 'fs' ) ;\nvar termkit = require( 'terminal-kit' ) ;\nvar term = termkit.terminal ;\n\nvar autoCompleter = function autoCompleter( inputString , callback )\n{  \n    fs.readdir( __dirname , function( error , files ) {\n        callback( undefined , termkit.autoComplete( files , inputString , true ) ) ;\n    } ) ;\n} ;\n    \nterm( 'Choose a file: ' ) ;\n\nterm.inputField(\n\t{ autoComplete: autoCompleter , autoCompleteMenu: true } ,\n\tfunction( error , input ) {\n\t\tif ( error )\n\t\t{\n\t\t\tterm.red.bold( \"\\nAn error occurs: \" + error + \"\\n\" ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tterm.green( \"\\nYour file is '%s'\\n\" , input ) ;\n\t\t}\n\t\t\n\t\tprocess.exit() ;\n\t}\n) ;\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/input-field-doc3.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\"use strict\" ;\n\n\n\nvar fs = require( 'fs' ) ;\nvar termkit = require( 'terminal-kit' ) ;\nvar term = termkit.terminal ;\n\nvar autoCompleter = function autoCompleter( inputString , callback )\n{  \n    var index = inputString.lastIndexOf( ' ' ) ;\n    var prefix = inputString.slice( 0 , index + 1 ) ;\n    inputString = inputString.slice( index + 1 ) ;\n    \n    fs.readdir( __dirname , function( error , files ) {\n        callback( undefined , termkit.autoComplete( files , inputString , true , prefix ) ) ;\n    } ) ;\n} ;\n    \nterm( 'Choose a file: ' ) ;\n\nterm.inputField(\n\t{ autoComplete: autoCompleter , autoCompleteMenu: true } ,\n\tfunction( error , input ) {\n\t\tif ( error )\n\t\t{\n\t\t\tterm.red.bold( \"\\nAn error occurs: \" + error + \"\\n\" ) ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tterm.green( \"\\nYour file is '%s'\\n\" , input ) ;\n\t\t}\n\t\t\n\t\tprocess.exit() ;\n\t}\n) ;\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/input-field-doc4.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\"use strict\" ;\n\nvar term = require( 'terminal-kit' ).terminal ;\n\nterm( 'shell> ' ) ;\n\nvar autoComplete = [\n\t'dnf install' ,\n\t'dnf install nodejs' ,\n\t'dnf search' ,\n\t'sudo' ,\n\t'sudo dnf install' ,\n\t'sudo dnf install nodejs' ,\n\t'sudo dnf search' ,\n] ;\n\nterm.inputField(\n\t{\n\t\tautoComplete: autoComplete ,\n\t\tautoCompleteHint: true ,\n\t\tautoCompleteMenu: true ,\n\t\ttokenHook: function( token , isEndOfInput , previousTokens , term , config ) {\n\t\t\tvar previousText = previousTokens.join( ' ' ) ;\n\t\t\t\n\t\t\tswitch ( token )\n\t\t\t{\n\t\t\t\tcase 'sudo' :\n\t\t\t\t\tconfig.style = term.red ;\n\t\t\t\t\treturn previousTokens.length ? null : term.bold.red ;\n\t\t\t\tcase 'dnf' :\n\t\t\t\t\treturn previousText === '' || previousText === 'sudo' ? term.brightMagenta : null ;\n\t\t\t\tcase 'install' :\n\t\t\t\t\tconfig.style = term.brightBlue ;\n\t\t\t\t\tconfig.hintStyle = term.brightBlack.italic ;\n\t\t\t\t\treturn previousText === 'dnf' || previousText === 'sudo dnf' ? term.brightYellow : null ;\n\t\t\t\tcase 'search' :\n\t\t\t\t\tconfig.style = term.brightBlue ;\n\t\t\t\t\treturn previousText === 'dnf' || previousText === 'sudo dnf' ? term.brightCyan : null ;\n\t\t\t}\n\t\t}\n\t} ,\n\tfunction( error , input ) {\n\t\tterm.green( \"\\nYour command is: '%s'\\n\" , input ) ;\n\t\tprocess.exit() ;\n\t}\n) ;\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/is-tty.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\nconsole.log( process.stdout.isTTY ? 'is a TTY' : 'NOT a TTY' ) ;\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/progress-bar-doc1.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\"use strict\" ;\n\nvar term = require( 'terminal-kit' ).terminal ;\n\nvar progressBar , progress = 0 ;\n\n\nfunction doProgress()\n{\n\t// Add random progress\n\tprogress += Math.random() / 10 ;\n\tprogressBar.update( progress ) ;\n\t\n\tif ( progress >= 1 )\n\t{\n\t\t// Cleanup and exit\n\t\tsetTimeout( function() { term( '\\n' ) ; process.exit() ; } , 200 ) ;\n\t}\n\telse\n\t{\n\t\tsetTimeout( doProgress , 100 + Math.random() * 400 ) ;\n\t}\n}\n\n\nprogressBar = term.progressBar( {\n\twidth: 80 ,\n\ttitle: 'Serious stuff in progress:' ,\n\teta: true ,\n\tpercent: true\n} ) ;\n\ndoProgress() ;\n                                ","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/progress-bar-doc2.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\"use strict\" ;\n\nvar term = require( 'terminal-kit' ).terminal ;\n\nvar progressBar ;\n\nvar thingsToDo = [\n\t'update my lib' ,\n\t'data analysing' ,\n\t'serious business' ,\n\t'decrunching data' ,\n\t'do my laundry' ,\n\t'optimizing'\n] ;\n\nvar countDown = thingsToDo.length ;\n\n\nfunction start()\n{\n\tif ( ! thingsToDo.length ) { return ; }\n\t\n\tvar task = thingsToDo.shift() ;\n\t\n\tprogressBar.startItem( task ) ;\n\t\n\t// Finish the task in...\n\tsetTimeout( done.bind( null , task ) , 500 + Math.random() * 1200 ) ;\n\t\n\t// Start another parallel task in...\n\tsetTimeout( start , 400 + Math.random() * 400 ) ;\n}\n\n\nfunction done( task )\n{\n\tprogressBar.itemDone( task ) ;\n\tcountDown -- ;\n\t\n\t// Cleanup and exit\n\tif ( ! countDown )\n\t{\n\t\tsetTimeout( function() { term( '\\n' ) ; process.exit() ; } , 200 ) ;\n\t}\n}\n\n\nprogressBar = term.progressBar( {\n\twidth: 80 ,\n\ttitle: 'Daily tasks:' ,\n\teta: true ,\n\tpercent: true ,\n\titems: thingsToDo.length\n} ) ;\n\nstart() ;\n                                ","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/screenbuffer-compatible-methods.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n/* jshint unused:false */\n\n\n\nvar terminal = require( '../lib/termkit.js' ) ;\n\n\n\nterminal.getDetectedTerminal( function( error , term ) {\n\t\n\tvar i ;\n\t\n\tterm.put( { x: 10 , y: 10 , attr: { color: 'cyan' , bold: true } } , 'Cyan!' ) ;\n\tterm.put( { x: 20 , y: 15 , attr: { color: 'red' , italic: true } } , 'Red!' ) ;\n\tterm.put( { x: 30 , y: 20 } , 'No attr!' ) ;\n\tterm( '\\n\\n' ) ;\n} ) ;\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/single-line-menu-doc1.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\"use strict\" ;\n\nvar term = require( 'terminal-kit' ).terminal ;\n\nvar items = [ 'File' , 'Edit' , 'View' , 'History' , 'Bookmarks' , 'Tools' , 'Help' ] ;\n\nvar options = {\n\ty: 1 ,\t// the menu will be on the top of the terminal\n\tstyle: term.inverse ,\n\tselectedStyle: term.dim.blue.bgGreen\n} ;\n\nterm.clear() ;\n\nterm.singleLineMenu( items , options , function( error , response ) {\n\tterm( '\\n' ).eraseLineAfter.green(\n\t\t\"#%s selected: %s (%s,%s)\\n\" ,\n\t\tresponse.selectedIndex ,\n\t\tresponse.selectedText ,\n\t\tresponse.x ,\n\t\tresponse.y\n\t) ;\n\tprocess.exit() ;\n} ) ;\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/slow-typing-doc1.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\"use strict\" ;\n\nvar term = require( 'terminal-kit' ).terminal ;\n\nterm.slowTyping(\n\t'What a wonderful world!\\n' ,\n\t{ flashStyle: term.brightWhite } ,\n\tfunction() { process.exit() ; }\n) ;\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/write-anywhere.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n/* jshint unused:false */\n\n\n\nvar term = require( '../lib/termkit.js' ).terminal ;\n\nterm.grabInput( { mouse: 'button' } ) ;\n\nterm.on( 'key' , function( key , matches , data ) {\n\t\n\tswitch ( key )\n\t{\n\t\tcase 'UP' :\n\t\t\tterm.up( 1 ) ;\n\t\t\tbreak ;\n\t\tcase 'DOWN' :\n\t\t\tterm.down( 1 ) ;\n\t\t\tbreak ;\n\t\tcase 'LEFT' :\n\t\t\tterm.left( 1 ) ;\n\t\t\tbreak ;\n\t\tcase 'RIGHT' :\n\t\t\tterm.right( 1 ) ;\n\t\t\tbreak ;\n\t\tcase 'INSERT' :\n\t\t\tterm.insert( 1 ) ;\n\t\t\tbreak ;\n\t\tcase 'ALT_INSERT' :\n\t\t\tterm.insertLine( 1 ) ;\n\t\t\tbreak ;\n\t\tcase 'DELETE' :\n\t\t\tterm.delete( 1 ) ;\n\t\t\tbreak ;\n\t\tcase 'ALT_DELETE' :\n\t\t\tterm.deleteLine( 1 ) ;\n\t\t\tbreak ;\n\t\tcase 'CTRL_C' :\n\t\t\tprocess.exit() ;\n\t\t\tbreak ;\n\t\tdefault:\n\t\t\t// Echo anything else\n\t\t\tterm.noFormat( Buffer.isBuffer( data.code ) ? data.code : String.fromCharCode( data.code ) ) ;\n\t\t\t//console.error( require( 'string-kit' ).escape.control( data.code.toString() ) ) ;\n\t\t\tbreak ;\n\t}\n} ) ;\n\nterm.on( 'mouse' , function( name , data ) {\n\tterm.moveTo( data.x , data.y ) ;\n} ) ;\n","/home/travis/build/npmtest/node-npmtest-terminal-kit/node_modules/terminal-kit/sample/yes-no-doc1.js":"#!/usr/bin/env node\n/*\n\tTerminal Kit\n\t\n\tCopyright (c) 2009 - 2017 Cédric Ronvel\n\t\n\tThe MIT License (MIT)\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\"use strict\" ;\n\nvar term = require( 'terminal-kit' ).terminal ;\n\nfunction question()\n{\n\tterm( 'Do you like javascript? [Y|n]\\n' ) ;\n\t\n\t// Exit on y and ENTER key\n\t// Ask again on n\n\tterm.yesOrNo( { yes: [ 'y' , 'ENTER' ] , no: [ 'n' ] } , function( error , result ) {\n\t\n\t\tif ( result )\n\t\t{\n\t\t\tterm.green( \"'Yes' detected! Good bye!\\n\" ) ;\n\t\t\tprocess.exit() ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tterm.red( \"'No' detected, are you sure?\\n\" ) ;\n\t\t\tquestion() ;\n\t\t}\n\t} ) ;\n}\n\nquestion() ;\n"}